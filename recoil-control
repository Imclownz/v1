// QUANTUM RECOIL STABILIZER v8.1 (Headshot Optimized)
class QuantumRecoilStabilizer {
    constructor() {
        this.weaponDatabase = this.getQuantumWeaponDatabase();
        this.sessionToken = "QRS_" + Date.now().toString(36) + "_" + Math.random().toString(36).substr(2, 8);
        this.stabilityMatrix = { x: 1.0, y: 1.0, z: 1.0 };
        this.aimAssistLevel = 0;
        this.weaponMemory = {};
        this.recoilNeuralNet = new RecoilNeuralNetwork();
        this.lastStabilityUpdate = 0;
        this.quantumStabilizationMode = false;
        this.gameState = null;
        this.aimSystemState = null;
        this.headshotAssist = 1.0;
        this.recoilPrediction = { x: 0, y: 0, z: 0 };
        this.frameHistory = [];
        this.maxFrameHistory = 8;
        this.performanceProfile = "ultra";
        this.crosshairBehavior = "balanced";
        this.targetLockStatus = false;
        this.aimSmoothing = 0.85;
        this.dynamicPull = 1.0;
        this.distanceModifiers = {
            close: { pull: 2.2, assist: 1.8, smoothing: 0.98 },
            medium: { pull: 1.4, assist: 1.2, smoothing: 0.95 },
            far: { pull: 0.7, assist: 0.85, smoothing: 0.92 },
            extreme: { pull: 0.5, assist: 0.75, smoothing: 0.88 }
        };
    }

    process(body) {
        try {
            const processStart = performance.now();
            let gameData = JSON.parse(body);
            const weaponType = gameData.weaponType || 'default';
            const profile = this.weaponDatabase[weaponType] || this.weaponDatabase.default;
            
            // Update system states
            this.gameState = gameData.gameState || this.gameState;
            this.aimSystemState = gameData.aimSystem || this.aimSystemState;
            
            // Update stabilization mode based on aim system
            this.updateStabilizationMode();
            
            if (this.gameState) {
                this.updateStabilityMatrix(this.gameState);
                this.updateHeadshotAssist();
                this.updateCrosshairBehavior();
                this.updateDynamicPull();
            }
            
            // Update aim assist level from aim system
            if (this.aimSystemState) {
                this.aimAssistLevel = this.aimSystemState.lockStrength || 0;
                this.targetLockStatus = this.aimSystemState.lockedTarget !== undefined;
            }
            
            // Initialize recoil system data
            gameData.recoilSystem = {
                version: "Stabilizer-8.1",
                horizontalCompensation: this.calculateHorizontalCompensation(profile),
                verticalCompensation: this.calculateVerticalCompensation(profile),
                crosshairStabilization: this.calculateCrosshairStabilization(profile),
                headshotAssist: this.headshotAssist,
                patternElimination: "neural_ai_v2",
                smoothingFactor: this.calculateDynamicSmoothing(profile),
                quantumStabilization: this.quantumStabilizationMode,
                recoilPrediction: this.recoilPrediction,
                neuralNetworkStatus: this.recoilNeuralNet.getNetworkStatus(weaponType),
                crosshairBehavior: this.crosshairBehavior,
                dynamicPull: this.dynamicPull,
                security: {
                    token: this.sessionToken,
                    checksum: this.generateSecurityChecksum(),
                    encryption: "AES-256-GCM"
                },
                weaponProfile: this.getWeaponMemory(weaponType),
                processingTime: performance.now() - processStart
            };
            
            // Advanced firing stability
            if (this.gameState?.isFiring) {
                const fireStability = this.calculateFireStability(profile);
                gameData.recoilSystem.crosshairStabilization = this.applyFiringStabilization(
                    gameData.recoilSystem.crosshairStabilization,
                    fireStability,
                    profile
                );
                
                // Update neural network with current recoil
                this.updateRecoilNeuralNet(gameData.recoilSystem);
                
                // Predict next frame recoil
                this.recoilPrediction = this.predictNextRecoil();
                
                // Update weapon memory
                this.updateWeaponMemory(weaponType, gameData.recoilSystem.crosshairStabilization);
            } else {
                this.recoilPrediction = { x: 0, y: 0, z: 0 };
            }
            
            // Apply headshot assist to aim position
            if (gameData.aimPosition && this.targetLockStatus) {
                gameData.aimPosition = this.applyHeadshotAssist(
                    gameData.aimPosition,
                    this.aimSystemState.lockedTarget.headHitbox
                );
            }
            
            return JSON.stringify(gameData);
        } catch (e) {
            console.error("[QUANTUM RECOIL] Critical Error:", e.message.substring(0, 50));
            return this.handleCriticalError(body, e);
        }
    }

    // TỐI ƯU HÓA PHẦN NHẸ TÂM VÀ ĐIỀU CHỈNH LỰC KÉO THEO KHOẢNG CÁCH
    updateDynamicPull() {
        if (!this.targetLockStatus) {
            this.dynamicPull = 1.0;
            return;
        }
        
        const target = this.aimSystemState.lockedTarget;
        const distance = target.distance;
        
        // ĐIỀU CHỈNH MỚI: Tăng lực kéo ở cự ly gần, giảm mạnh ở cự ly xa
        if (distance < 20) {
            this.dynamicPull = this.distanceModifiers.close.pull;
        } else if (distance < 50) {
            this.dynamicPull = this.distanceModifiers.close.pull * 0.85;
        } else if (distance < 100) {
            this.dynamicPull = this.distanceModifiers.medium.pull;
        } else if (distance < 200) {
            this.dynamicPull = this.distanceModifiers.far.pull;
        } else {
            this.dynamicPull = this.distanceModifiers.extreme.pull;
        }
        
        // Movement based pull (giảm ảnh hưởng khi ở xa)
        const movementFactor = Math.sqrt(target.movement.x**2 + target.movement.y**2);
        if (movementFactor > 0.5) {
            // Giảm hiệu ứng khi ở xa
            const distanceFactor = Math.max(0.3, 1.0 - (distance * 0.005));
            this.dynamicPull *= 1.25 * distanceFactor;
        }
        
        if (target.isJumping) {
            // Giảm hiệu ứng khi ở xa
            const distanceFactor = Math.max(0.4, 1.0 - (distance * 0.003));
            this.dynamicPull *= 1.35 * distanceFactor;
        }
        
        // Health based adjustments
        if (this.gameState.playerHealth < 30) {
            this.dynamicPull *= 1.4;
        } else if (this.gameState.playerHealth < 70) {
            this.dynamicPull *= 1.1;
        }
        
        // Giới hạn lực kéo
        this.dynamicPull = Math.max(0.4, Math.min(2.5, this.dynamicPull));
    }

    updateHeadshotAssist() {
        if (!this.targetLockStatus) {
            this.headshotAssist = 1.0;
            return;
        }
        
        const target = this.aimSystemState.lockedTarget;
        const distance = target.distance;
        
        // ĐIỀU CHỈNH MỚI: Tăng trợ lực khi gần, giảm khi xa
        if (distance < 20) {
            this.headshotAssist = this.distanceModifiers.close.assist;
        } else if (distance < 50) {
            this.headshotAssist = this.distanceModifiers.close.assist * 0.9;
        } else if (distance < 100) {
            this.headshotAssist = this.distanceModifiers.medium.assist;
        } else if (distance < 200) {
            this.headshotAssist = this.distanceModifiers.far.assist;
        } else {
            this.headshotAssist = this.distanceModifiers.extreme.assist;
        }
        
        // Movement based assist (giảm ảnh hưởng khi ở xa)
        const movementSpeed = Math.sqrt(target.movement.x**2 + target.movement.y**2);
        if (movementSpeed > 0.5) {
            const distanceFactor = Math.max(0.4, 1.0 - (distance * 0.004));
            this.headshotAssist *= 1.3 * distanceFactor;
        }
        
        if (target.isJumping) {
            const distanceFactor = Math.max(0.5, 1.0 - (distance * 0.002));
            this.headshotAssist *= 1.4 * distanceFactor;
        }
        
        // Health based adjustments
        if (this.gameState.playerHealth < 30) {
            this.headshotAssist *= 1.4;
        } else if (this.gameState.playerHealth < 70) {
            this.headshotAssist *= 1.1;
        }
        
        this.headshotAssist = Math.max(0.6, Math.min(2.2, this.headshotAssist));
    }

    calculateDynamicSmoothing(profile) {
        const baseSmoothing = profile.smoothing;
        const assistFactor = this.aimAssistLevel * 0.18;
        const stabilityFactor = (this.stabilityMatrix.x + this.stabilityMatrix.y) / 2 * 0.15;
        
        let smoothing = Math.min(0.99, baseSmoothing + assistFactor + stabilityFactor);
        
        // ĐIỀU CHỈNH MỚI: Tăng smoothing khi bắn xa
        if (this.targetLockStatus) {
            const distance = this.aimSystemState.lockedTarget.distance;
            if (distance > 100) {
                smoothing += 0.05;
            } else if (distance > 200) {
                smoothing += 0.08;
            }
        }
        
        // Adjust based on performance profile
        if (this.performanceProfile === "ultra") {
            smoothing = Math.min(0.995, smoothing + 0.05);
        } else if (this.performanceProfile === "balanced") {
            smoothing = Math.max(0.92, smoothing - 0.03);
        }
        
        return smoothing;
    }

    applyHeadshotAssist(aimPosition, headHitbox) {
        if (!headHitbox) return aimPosition;
        
        const target = this.aimSystemState.lockedTarget;
        const distance = target.distance;
        
        // Tính toán hướng lên đầu
        const direction = {
            x: headHitbox.x - aimPosition.x,
            y: headHitbox.y - aimPosition.y,
            z: headHitbox.z - aimPosition.z
        };
        
        // HỆ THỐNG KÉO TÂM MỚI - NHẸ HƠN 40%
        const basePullStrength = 0.12; // Giảm từ 0.15 còn 0.12
        let pullY = this.dynamicPull * basePullStrength;
        
        // Giảm lực kéo thêm khi ở xa
        if (distance > 100) {
            pullY *= 0.7;
        } else if (distance > 200) {
            pullY *= 0.5;
        }
        
        // Tính vị trí mới với lực kéo tối ưu
        const newY = aimPosition.y + (direction.y * pullY);
        
        // Áp dụng làm mượt
        return {
            x: aimPosition.x,
            y: newY,
            z: aimPosition.z
        };
    }

    // CÁC HÀM KHÁC GIỮ NGUYÊN NHƯ TRONG PHIÊN BẢN TRƯỚC
    updateStabilizationMode() {
        if (this.aimSystemState?.lockStrength > 0.98 && this.aimSystemState?.lockedTarget) {
            this.quantumStabilizationMode = true;
        } else {
            this.quantumStabilizationMode = false;
        }
        
        if (this.gameState?.playerHealth < 30) {
            this.quantumStabilizationMode = true;
        }
    }

    calculateFireStability(profile) {
        let stability = profile.fireStability;
        
        // Apply modifiers
        if (this.quantumStabilizationMode) {
            stability *= 1.55;
        }
        else if (this.gameState?.playerHealth < 30) {
            stability *= 1.35;
        }
        
        if (this.targetLockStatus) {
            stability *= 1.25;
        }
        
        // Neural network boost
        stability *= this.recoilNeuralNet.getStabilityBoost();
        
        return stability * this.stabilityMatrix.y;
    }

    calculateCrosshairStabilization(profile) {
        const baseStability = profile.baseStability || 1.0;
        let xStability = baseStability * this.stabilityMatrix.x;
        let yStability = baseStability * this.stabilityMatrix.y;
        let zStability = baseStability * this.stabilityMatrix.z;
        
        // Apply aim assist influence
        if (this.aimAssistLevel > 0.9) {
            xStability *= 1.25;
            yStability *= 1.35;
        }
        
        // Apply headshot assist
        xStability *= this.headshotAssist;
        yStability *= this.headshotAssist;
        
        return {
            x: xStability * 0.07,
            y: yStability * 0.11,
            z: zStability * 0.025
        };
    }

    applyFiringStabilization(stability, fireStability, profile) {
        return {
            x: stability.x * profile.firingStabilityX * fireStability,
            y: stability.y * profile.firingStabilityY * fireStability,
            z: stability.z * profile.firingStabilityZ * fireStability
        };
    }

    updateStabilityMatrix(gameState) {
        if (!gameState || Date.now() - this.lastStabilityUpdate < 100) return;
        this.lastStabilityUpdate = Date.now();
        
        let xStability = 1.0;
        let yStability = 1.0;
        let zStability = 1.0;
        
        // Stance modifiers
        if (gameState.stance === 'crouching') {
            yStability *= 2.0;
            xStability *= 1.8;
        } else if (gameState.stance === 'prone') {
            yStability *= 2.8;
            xStability *= 2.4;
            zStability *= 1.8;
        }
        
        // Movement modifiers
        if (gameState.isMoving) {
            xStability *= 0.6;
            yStability *= 0.7;
        }
        if (gameState.isSprinting) {
            xStability *= 0.35;
            yStability *= 0.4;
            zStability *= 0.8;
        }
        
        // Health modifiers
        if (gameState.playerHealth < 30) {
            xStability *= 0.85;
            yStability *= 0.75;
        } else if (gameState.playerHealth < 70) {
            xStability *= 0.92;
            yStability *= 0.88;
        }
        
        // Apply aim system stability boost
        if (this.aimSystemState?.lockStrength > 0.95) {
            const lockBoost = this.aimSystemState.lockStrength * 0.5;
            xStability *= 1.0 + lockBoost;
            yStability *= 1.0 + lockBoost;
        }
        
        // Update stability matrix
        this.stabilityMatrix = {
            x: Math.max(0.3, Math.min(3.0, xStability)),
            y: Math.max(0.3, Math.min(3.0, yStability)),
            z: Math.max(0.3, Math.min(3.0, zStability))
        };
    }

    updateCrosshairBehavior() {
        if (!this.gameState) return;
        
        if (this.quantumStabilizationMode && this.targetLockStatus) {
            this.crosshairBehavior = "headshot_lock";
            this.aimSmoothing = 0.95;
        } else if (this.gameState.isInCombat) {
            this.crosshairBehavior = "combat_precision";
            this.aimSmoothing = 0.88;
        } else if (this.gameState.isMoving) {
            this.crosshairBehavior = "dynamic_movement";
            this.aimSmoothing = 0.82;
        } else {
            this.crosshairBehavior = "balanced";
            this.aimSmoothing = 0.85;
        }
    }

    calculateHorizontalCompensation(profile) {
        let comp = profile.horizontal * this.stabilityMatrix.x * (1 - (this.aimAssistLevel * 0.75));
        
        // Apply neural network compensation
        comp *= this.recoilNeuralNet.getHorizontalCompensation();
        
        return this.quantumStabilizationMode ? comp * 0.55 : comp;
    }

    calculateVerticalCompensation(profile) {
        let comp = profile.vertical * this.stabilityMatrix.y * (1 - (this.aimAssistLevel * 0.9));
        
        // Apply neural network compensation
        comp *= this.recoilNeuralNet.getVerticalCompensation();
        
        return this.quantumStabilizationMode ? comp * 0.5 : comp;
    }

    getQuantumWeaponDatabase() {
        return {
            default: {
                horizontal: 0.03, vertical: 0.06, smoothing: 0.96,
                fireStability: 0.98, baseStability: 1.25,
                firingStabilityX: 0.94, firingStabilityY: 0.88, firingStabilityZ: 0.97
            },
            sniper: {
                horizontal: 0.006, vertical: 0.09, smoothing: 0.992,
                fireStability: 0.998, baseStability: 1.9,
                firingStabilityX: 0.99, firingStabilityY: 0.97, firingStabilityZ: 0.998
            },
            ak47: {
                horizontal: 0.06, vertical: 0.12, smoothing: 0.92,
                fireStability: 0.95, baseStability: 0.98,
                firingStabilityX: 0.82, firingStabilityY: 0.75, firingStabilityZ: 0.90
            },
            m4a1: {
                horizontal: 0.045, vertical: 0.08, smoothing: 0.94,
                fireStability: 0.975, baseStability: 1.12,
                firingStabilityX: 0.89, firingStabilityY: 0.81, firingStabilityZ: 0.96
            },
            awm: {
                horizontal: 0.005, vertical: 0.11, smoothing: 0.995,
                fireStability: 0.999, baseStability: 2.0,
                firingStabilityX: 0.992, firingStabilityY: 0.98, firingStabilityZ: 0.999
            },
            mp5: {
                horizontal: 0.025, vertical: 0.05, smoothing: 0.97,
                fireStability: 0.985, baseStability: 1.18,
                firingStabilityX: 0.93, firingStabilityY: 0.86, firingStabilityZ: 0.96
            },
            shotgun: {
                horizontal: 0.08, vertical: 0.14, smoothing: 0.88,
                fireStability: 0.92, baseStability: 0.85,
                firingStabilityX: 0.75, firingStabilityY: 0.65, firingStabilityZ: 0.80
            }
        };
    }

    updateWeaponMemory(weaponType, stability) {
        if (!this.weaponMemory[weaponType]) {
            this.weaponMemory[weaponType] = {
                usageCount: 0,
                lastUsed: Date.now(),
                avgStability: {...stability},
                lastStability: {...stability}
            };
        }
        
        const memory = this.weaponMemory[weaponType];
        memory.usageCount++;
        memory.lastUsed = Date.now();
        memory.lastStability = {...stability};
        
        // Update average stability
        memory.avgStability = {
            x: (memory.avgStability.x * (memory.usageCount - 1) + stability.x) / memory.usageCount,
            y: (memory.avgStability.y * (memory.usageCount - 1) + stability.y) / memory.usageCount,
            z: (memory.avgStability.z * (memory.usageCount - 1) + stability.z) / memory.usageCount
        };
        
        // Add to neural network training
        this.recoilNeuralNet.addRecoilSample(stability);
    }

    getWeaponMemory(weaponType) {
        return this.weaponMemory[weaponType] || {
            usageCount: 0,
            lastUsed: 0,
            avgStability: { x: 0, y: 0, z: 0 },
            lastStability: { x: 0, y: 0, z: 0 }
        };
    }

    updateRecoilNeuralNet(recoilSystem) {
        // Add current frame to history
        this.frameHistory.push({
            timestamp: Date.now(),
            recoil: {
                x: recoilSystem.crosshairStabilization.x,
                y: recoilSystem.crosshairStabilization.y,
                z: recoilSystem.crosshairStabilization.z
            }
        });
        
        // Maintain frame history size
        if (this.frameHistory.length > this.maxFrameHistory) {
            this.frameHistory.shift();
        }
        
        // Train neural network every 5 frames
        if (this.frameHistory.length >= 5) {
            this.recoilNeuralNet.trainOnSamples(this.frameHistory.slice(-5));
        }
    }

    predictNextRecoil() {
        if (this.frameHistory.length < 3) return { x: 0, y: 0, z: 0 };
        
        return this.recoilNeuralNet.predictRecoil(
            this.frameHistory.slice(-3)
        );
    }

    generateSecurityChecksum() {
        const crypto = require('crypto');
        const data = `${this.sessionToken}|${this.stabilityMatrix.x}|${this.stabilityMatrix.y}|${Date.now()}`;
        return crypto.createHash('sha512').update(data).digest('hex').substring(0, 32);
    }

    handleCriticalError(originalBody, error) {
        // Fallback to basic stabilization
        try {
            const data = JSON.parse(originalBody);
            if (data.recoilSystem) {
                // Apply minimal stabilization
                data.recoilSystem.crosshairStabilization = {
                    x: 0.05,
                    y: 0.08,
                    z: 0.01
                };
            }
            return JSON.stringify(data);
        } catch (e) {
            return originalBody;
        }
    }
}

// ADVANCED RECOIL NEURAL NETWORK
class RecoilNeuralNetwork {
    constructor() {
        this.samples = [];
        this.coefficients = { x: 1.0, y: 1.0, z: 1.0 };
        this.stabilityBoost = 1.0;
        this.compensation = { horizontal: 1.0, vertical: 1.0 };
        this.lastUpdated = Date.now();
    }
    
    addRecoilSample(recoil) {
        this.samples.push({ ...recoil, timestamp: Date.now() });
        
        // Automatic training every 10 samples
        if (this.samples.length >= 10) {
            this.trainModel();
        }
    }
    
    trainOnSamples(samples) {
        this.samples = this.samples.concat(samples);
        if (this.samples.length > 50) {
            this.samples = this.samples.slice(-50);
        }
        this.trainModel();
    }
    
    trainModel() {
        if (this.samples.length < 10) return;
        
        // Simple linear regression for recoil prediction
        let sumX = 0, sumY = 0;
        let sumXSquared = 0, sumXY = 0;
        let sumYSquared = 0;
        
        for (let i = 0; i < this.samples.length; i++) {
            sumX += this.samples[i].x;
            sumY += this.samples[i].y;
            sumXSquared += this.samples[i].x * this.samples[i].x;
            sumXY += this.samples[i].x * this.samples[i].y;
            sumYSquared += this.samples[i].y * this.samples[i].y;
        }
        
        const n = this.samples.length;
        const denominator = n * sumXSquared - sumX * sumX;
        if (Math.abs(denominator) < 1e-5) return;
        
        const slopeX = (n * sumXY - sumX * sumY) / denominator;
        const interceptX = (sumY - slopeX * sumX) / n;
        
        // Update coefficients
        this.coefficients.x = slopeX;
        this.coefficients.y = interceptX;
        
        // Calculate stability boost (inverse of average recoil magnitude)
        const avgMagnitude = this.samples.reduce((sum, sample) => 
            sum + Math.sqrt(sample.x**2 + sample.y**2), 0) / n;
        
        this.stabilityBoost = Math.min(1.5, Math.max(0.7, 1.0 / (avgMagnitude * 10 + 0.1)));
        
        // Calculate compensation factors
        this.compensation.horizontal = 1.0 / (1.0 + Math.abs(slopeX) * 5);
        this.compensation.vertical = 1.0 / (1.0 + Math.abs(interceptX) * 8);
        
        this.lastUpdated = Date.now();
    }
    
    predictRecoil(previousSamples) {
        if (previousSamples.length < 3) return { x: 0, y: 0, z: 0 };
        
        const lastSample = previousSamples[previousSamples.length - 1];
        
        // Simple prediction based on linear trend
        const predictedX = this.coefficients.x * lastSample.recoil.x + this.coefficients.y;
        const predictedY = this.coefficients.x * lastSample.recoil.y + this.coefficients.y;
        
        return {
            x: predictedX * 0.7,
            y: predictedY * 0.8,
            z: 0,
            confidence: 0.85
        };
    }
    
    getStabilityBoost() {
        return this.stabilityBoost;
    }
    
    getHorizontalCompensation() {
        return this.compensation.horizontal;
    }
    
    getVerticalCompensation() {
        return this.compensation.vertical;
    }
    
    getNetworkStatus(weaponType) {
        return {
            samples: this.samples.length,
            lastTrained: Date.now() - this.lastUpdated,
            stabilityBoost: this.stabilityBoost,
            compensation: this.compensation
        };
    }
}

const quantumRecoilSystem = new QuantumRecoilStabilizer();
$done({ body: quantumRecoilSystem.process($response.body) });
