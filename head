// HEAD PROTECTION SYSTEM v4.0 (Precision Headshot Edition)
class HeadProtectionSystem {
    constructor() {
        this.protectionEnabled = true;
        this.protectionMode = "dynamic";
        this.headHitboxOffset = { x: 0, y: -0.4, z: 0 };
        this.realHeadPosition = { x: 0, y: 0, z: 0 };
        this.sessionToken = "HPS_" + Date.now().toString(36);
        this.lastUpdate = Date.now();
        this.camouflageIntensity = 0.95; // Tăng độ ngụy trang
        this.adaptiveProtection = true;
        this.headTracking = new HeadTrackingSystem(); // Hệ thống theo dõi đầu
    }

    process(body) {
        try {
            let data = JSON.parse(body);
            
            if (this.protectionEnabled && data.playerPosition) {
                this.realHeadPosition = this.calculateRealHeadPosition(data.playerPosition, data.playerStance);
                data.playerHeadPosition = this.generateFakeHeadPosition(data.playerPosition, data.playerStance);
                
                if (data.playerHitboxes) {
                    data.playerHitboxes = this.maskRealHeadHitbox(data.playerHitboxes);
                }
                
                // Theo dõi và dự đoán vị trí đầu
                if (data.targets) {
                    data.targets = this.headTracking.trackHeads(data.targets);
                }
                
                data.headProtection = {
                    active: true,
                    mode: this.protectionMode,
                    camouflage: this.camouflageIntensity,
                    security: {
                        token: this.sessionToken,
                        checksum: this.generateChecksum()
                    }
                };
            }
            
            return JSON.stringify(data);
        } catch (e) {
            console.error("[HEAD PROTECTION] Error:", e.message.substring(0, 20));
            return body;
        }
    }

    calculateRealHeadPosition(playerPosition, stance) {
        let yOffset = 1.0;
        if (stance === 'crouching') yOffset = 0.75;
        else if (stance === 'prone') yOffset = 0.4;
        
        return {
            x: playerPosition.x,
            y: playerPosition.y + yOffset,
            z: playerPosition.z
        };
    }

    generateFakeHeadPosition(playerPosition, stance) {
        let fakePosition = { ...playerPosition };
        this.updateProtectionMode();
        
        if (this.protectionMode === "static") {
            fakePosition.y -= 0.45;
        } else if (this.protectionMode === "random") {
            fakePosition.x += (Math.random() * 0.7 - 0.35);
            fakePosition.y -= 0.3 + (Math.random() * 0.4);
            fakePosition.z += (Math.random() * 0.7 - 0.35);
        } else {
            const timeFactor = Date.now() / 600; // Tăng tốc độ di chuyển đầu giả
            fakePosition.x += Math.sin(timeFactor * 2.0) * 0.2;
            fakePosition.y -= 0.4 + Math.cos(timeFactor * 3.0) * 0.15;
            fakePosition.z += Math.cos(timeFactor * 1.8) * 0.2;
        }
        
        return fakePosition;
    }

    updateProtectionMode() {
        if (Date.now() - this.lastUpdate > 10000) {
            const modes = ["dynamic", "static", "random"];
            this.protectionMode = modes[Math.floor(Math.random() * modes.length)];
            this.camouflageIntensity = 0.8 + Math.random() * 0.2;
            this.lastUpdate = Date.now();
        }
    }

    maskRealHeadHitbox(hitboxes) {
        return hitboxes.map(hitbox => {
            if (hitbox.type === 'head') {
                return {
                    ...hitbox,
                    position: {
                        x: hitbox.position.x + (Math.random() * 0.3 - 0.15),
                        y: hitbox.position.y - 0.35,
                        z: hitbox.position.z + (Math.random() * 0.3 - 0.15)
                    },
                    radius: hitbox.radius * 0.6, // Thu nhỏ hitbox
                    camouflage: this.camouflageIntensity
                };
            }
            return hitbox;
        });
    }

    generateChecksum() {
        const crypto = require('crypto');
        const data = this.sessionToken + this.protectionMode;
        return crypto.createHash('sha256').update(data).digest('hex').substring(0, 16);
    }
}

class HeadTrackingSystem {
    trackHeads(targets) {
        return targets.map(target => {
            const predictedHeadPosition = this.predictHeadMovement(target);
            return {
                ...target,
                headHitbox: predictedHeadPosition
            };
        });
    }

    predictHeadMovement(target) {
        const movementFactor = 1.1;
        return {
            x: target.position.x + (target.movement.x * movementFactor),
            y: target.position.y + target.headHeight + (target.movement.y * movementFactor),
            z: target.position.z + (target.movement.z * movementFactor)
        };
    }
}

const headProtection = new HeadProtectionSystem();
$done({ body: headProtection.process($response.body) });
