// perfectlock-ultimate-pro.js
class PerfectLockUltimateProSystem {
    constructor() {
        this.lockStrength = 0.995;
        this.targetHistory = new Map();
        this.sessionToken = `PLOCK_PRO_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 12)}`;
        this.weaponProfiles = this.getEnhancedWeaponProfiles();
        this.ballisticCalculator = new AdvancedBallisticCalculator();
        this.lastLockTime = 0;
        this.performanceMode = "turbo";
        this.aimPredictionLevel = 4;
        this.targetPriorityQueue = [];
        this.aimStabilizer = 0.92;
        this.neuralWeights = this.generateNeuralWeights();
    }

    process(body) {
        try {
            const data = JSON.parse(body);
            this.updatePerformanceMode(data.performanceState);
            
            if (data.gameState) this.updateCombatState(data.gameState);
            
            if (data.targets?.length > 0) {
                const enhancedTargets = this.enhanceTargets(data.targets, data.playerPosition, data.currentWeapon);
                const lockedTarget = this.selectOptimalTarget(enhancedTargets);
                
                if (lockedTarget) {
                    const perfectAim = this.calculatePrecisionAim(lockedTarget, data.playerPosition, data.currentWeapon);
                    data.aimPosition = this.applyNeuralLock(perfectAim, data.currentAimPosition, lockedTarget);
                    
                    if (this.lockStrength > 0.97 && data.recoilSystem?.crosshairStabilization) {
                        const stabilizationBoost = 1.8 - (lockedTarget.distance * 0.002);
                        data.aimPosition = {
                            x: data.aimPosition.x * data.recoilSystem.crosshairStabilization.x * stabilizationBoost,
                            y: data.aimPosition.y * data.recoilSystem.crosshairStabilization.y * stabilizationBoost,
                            z: data.aimPosition.z * data.recoilSystem.crosshairStabilization.z * (stabilizationBoost * 0.9)
                        };
                        data.recoilSystem.aimLockStrength = this.lockStrength;
                    }
                    
                    if (this.performanceMode !== "low") {
                        data.bulletTrajectory = this.calculateAdaptiveTrajectory(
                            data.playerPosition,
                            data.aimPosition,
                            lockedTarget,
                            data.currentWeapon
                        );
                    }
                    
                    this.lastLockTime = Date.now();
                }
                
                data.aimData = {
                    targets: enhancedTargets,
                    lockedTarget,
                    lockStrength: this.lockStrength,
                    predictionLevel: this.aimPredictionLevel,
                    neuralProfile: this.neuralWeights.profile
                };
            }
            
            data.aimSystem = this.getSystemMetadata();
            return JSON.stringify(data);
        } catch (e) {
            console.error("[PERFECTLOCK PRO] Error:", e.message.substring(0, 50));
            return body;
        }
    }

    updatePerformanceMode(performanceState) {
        if (!performanceState) return;
        
        if (performanceState.cpuUsage > 0.85 || performanceState.memoryUsage > 85) {
            this.performanceMode = "balanced";
            this.aimPredictionLevel = 3;
        } else if (performanceState.cpuUsage > 0.7 || performanceState.memoryUsage > 75) {
            this.performanceMode = "turbo";
            this.aimPredictionLevel = 4;
        } else {
            this.performanceMode = "ultra";
            this.aimPredictionLevel = 5;
        }
    }

    enhanceTargets(targets, playerPosition, weaponType) {
        return targets.map(target => {
            const distance = this.calculatePreciseDistance(playerPosition, target.position);
            const bulletSpeed = this.weaponProfiles[weaponType]?.bulletVelocity || 500;
            const travelTime = distance / bulletSpeed;
            
            const movementPrediction = this.neuralMovementPrediction(target);
            
            return {
                ...target,
                distance,
                movement: movementPrediction,
                travelTime,
                headHitbox: this.calculateHeadHitbox(target, travelTime),
                threatLevel: this.calculateThreatLevel(target)
            };
        });
    }

    neuralMovementPrediction(target) {
        const now = Date.now();
        const history = this.targetHistory.get(target.id) || {
            positions: [],
            timestamps: [],
            movementPatterns: []
        };

        history.positions.push(target.position);
        history.timestamps.push(now);
        
        const maxHistory = Math.min(10, 3 + this.aimPredictionLevel);
        if (history.positions.length > maxHistory) {
            history.positions.shift();
            history.timestamps.shift();
        }
        
        let predictedX = 0, predictedY = 0, predictedZ = 0;
        const weightFactor = this.neuralWeights.sensitivity;
        
        if (history.positions.length > 1) {
            for (let i = 1; i < history.positions.length; i++) {
                const dx = history.positions[i].x - history.positions[i-1].x;
                const dy = history.positions[i].y - history.positions[i-1].y;
                const dz = history.positions[i].z - history.positions[i-1].z;
                const dt = (history.timestamps[i] - history.timestamps[i-1]) / 1000;
                
                predictedX += (dx / dt) * weightFactor * (i / history.positions.length);
                predictedY += (dy / dt) * weightFactor * (i / history.positions.length);
                predictedZ += (dz / dt) * weightFactor * (i / history.positions.length);
            }
            
            const avgFactor = 1 / (history.positions.length - 1);
            predictedX *= avgFactor;
            predictedY *= avgFactor;
            predictedZ *= avgFactor;
        }
        
        history.movementPatterns.push({x: predictedX, y: predictedY, z: predictedZ});
        this.targetHistory.set(target.id, history);
        
        return {x: predictedX, y: predictedY, z: predictedZ};
    }

    calculateHeadHitbox(target, travelTime) {
        const headHeight = target.isCrouching ? target.height * 0.85 : target.height * 0.92;
        const headRadius = target.isCrouching ? 0.22 : 0.25;
        
        const currentHead = {
            x: target.position.x,
            y: target.position.y + headHeight,
            z: target.position.z
        };
        
        return {
            x: currentHead.x + (target.movement.x * travelTime * 1.25 * this.neuralWeights.accuracy),
            y: currentHead.y + (target.movement.y * travelTime * 1.25 * this.neuralWeights.accuracy),
            z: currentHead.z + (target.movement.z * travelTime * 1.25 * this.neuralWeights.accuracy),
            radius: headRadius
        };
    }

    calculateThreatLevel(target) {
        let threat = 0;
        threat += target.isAimingAtPlayer ? 40 : 0;
        threat += (100 - target.health) * 0.6;
        threat += target.isShooting ? 30 : 0;
        threat -= target.isReloading ? 20 : 0;
        return Math.max(0, threat);
    }

    selectOptimalTarget(targets) {
        return targets.sort((a, b) => {
            if (a.isLocked && !b.isLocked) return -1;
            if (!a.isLocked && b.isLocked) return 1;
            
            const aScore = this.calculateTacticalScore(a);
            const bScore = this.calculateTacticalScore(b);
            
            return bScore - aScore;
        })[0];
    }

    calculateTacticalScore(target) {
        let score = 0;
        
        // Tăng trọng số cho mục tiêu gần và đang bắn
        score += Math.max(0, 150 - (target.distance / 1.5));
        score += target.isShooting ? 50 : 0;
        
        score += target.threatLevel * 1.2;
        score += (100 - target.health) * 0.9;
        
        // Giảm phạt cho mục tiêu di chuyển
        const speed = Math.sqrt(target.movement.x**2 + target.movement.y**2 + target.movement.z**2);
        score -= Math.min(40, speed * 10);
        
        score += target.isAiming ? 25 : 0;
        score += speed < 0.1 ? 15 : 0;
        
        return score;
    }

    calculatePrecisionAim(target, playerPosition, weaponType) {
        let aimPosition = {
            x: target.headHitbox.x,
            y: target.headHitbox.y,
            z: target.headHitbox.z
        };
        
        if (['sniper', 'dmr'].includes(weaponType)) {
            const gravity = this.ballisticCalculator.getGravity(weaponType);
            const drop = this.ballisticCalculator.calculateAdvancedDrop(
                target.distance, 
                this.weaponProfiles[weaponType].bulletVelocity, 
                gravity,
                target.movement
            );
            aimPosition.y += drop;
        }
        
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        aimPosition.y += weaponProfile.verticalOffset * this.neuralWeights.precision;
        
        // Giảm độ lệch ngẫu nhiên để tăng độ chính xác
        const randFactor = 0.01 - (this.lockStrength * 0.005);
        aimPosition.x += (Math.random() * randFactor) - (randFactor / 2);
        aimPosition.y += (Math.random() * randFactor * 0.7) - (randFactor / 3);
        
        return aimPosition;
    }

    applyNeuralLock(targetPosition, currentPosition, target) {
        const direction = {
            x: targetPosition.x - currentPosition.x,
            y: targetPosition.y - currentPosition.y,
            z: targetPosition.z - currentPosition.z
        };
        
        const distanceFactor = Math.min(1, 80 / target.distance);
        const speedFactor = 1 - (Math.sqrt(
            target.movement.x**2 + 
            target.movement.y**2 + 
            target.movement.z**2
        ) * 0.15);
        
        const neuralLockFactor = this.lockStrength * distanceFactor * speedFactor * this.neuralWeights.aggression;
        
        return {
            x: currentPosition.x + (direction.x * neuralLockFactor),
            y: currentPosition.y + (direction.y * neuralLockFactor * this.aimStabilizer),
            z: currentPosition.z + (direction.z * neuralLockFactor * 0.85)
        };
    }

    calculateAdaptiveTrajectory(start, end, target, weaponType) {
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        const guidedFactor = weaponProfile.guidedFactor * this.neuralWeights.tracking;
        
        return {
            start,
            end: target.headHitbox,
            speed: weaponProfile.bulletVelocity,
            isGuided: guidedFactor > 0.3,
            correction: {
                x: (target.movement.x * target.travelTime * guidedFactor),
                y: (target.movement.y * target.travelTime * guidedFactor * 1.1),
                z: (target.movement.z * target.travelTime * guidedFactor)
            },
            predictionAccuracy: this.neuralWeights.accuracy
        };
    }

    getEnhancedWeaponProfiles() {
        return {
            default: {
                bulletVelocity: 450,
                verticalOffset: 0.06,
                guidedFactor: 0.35
            },
            sniper: {
                bulletVelocity: 1350,
                verticalOffset: -0.018,
                guidedFactor: 0.78,
                headshotMultiplier: 2.5
            },
            ar: {
                bulletVelocity: 850,
                verticalOffset: 0.035,
                guidedFactor: 0.45,
                headshotMultiplier: 1.8
            },
            smg: {
                bulletVelocity: 550,
                verticalOffset: 0.075,
                guidedFactor: 0.25,
                headshotMultiplier: 1.5
            },
            shotgun: {
                bulletVelocity: 380,
                verticalOffset: 0.12,
                guidedFactor: 0.15,
                headshotMultiplier: 2.0
            },
            dmr: {
                bulletVelocity: 950,
                verticalOffset: -0.015,
                guidedFactor: 0.65,
                headshotMultiplier: 2.2
            }
        };
    }

    updateCombatState(gameState) {
        const combatIntensity = gameState.combatIntensity || 0;
        const timeSinceCombat = Date.now() - this.lastLockTime;
        
        if (gameState.isInCombat || timeSinceCombat < 4000) {
            this.lockStrength = Math.min(0.999, 0.97 + (combatIntensity * 0.02));
        } else {
            this.lockStrength = Math.max(0.96, this.lockStrength - 0.01);
        }
        
        if (gameState.isAiming) this.lockStrength = 0.992;
        if (gameState.playerHealth < 25) this.lockStrength = 0.999;
        
        this.aimStabilizer = 0.90 + (this.lockStrength * 0.05);
    }

    generateNeuralWeights() {
        return {
            aggression: 0.85 + (Math.random() * 0.15),
            accuracy: 0.92 + (Math.random() * 0.08),
            precision: 0.88 + (Math.random() * 0.12),
            tracking: 0.90 + (Math.random() * 0.10),
            sensitivity: 0.95 + (Math.random() * 0.05),
            profile: ['sniper', 'assault', 'rusher'][Math.floor(Math.random() * 3)]
        };
    }

    getSystemMetadata() {
        return {
            version: "Ultimate-Pro-5.2",
            lockStrength: this.lockStrength,
            performanceMode: this.performanceMode,
            predictionLevel: this.aimPredictionLevel,
            neuralNetwork: this.neuralWeights,
            security: {
                token: this.sessionToken,
                checksum: this.generateSecureChecksum(),
                behavior: this.getRandomBehavior()
            }
        };
    }

    generateSecureChecksum() {
        const crypto = require('crypto');
        const data = `${this.sessionToken}${this.lockStrength}${Date.now()}`;
        return crypto.createHash('sha3-512').update(data).digest('hex');
    }

    getRandomBehavior() {
        const behaviors = ["tactical", "aggressive", "adaptive", "stealth", "balanced"];
        return behaviors[Math.floor(Math.random() * behaviors.length)];
    }

    calculatePreciseDistance(pos1, pos2) {
        const dx = pos1.x - pos2.x;
        const dy = pos1.y - pos2.y;
        const dz = pos1.z - pos2.z;
        return Math.sqrt(dx*dx + dy*dy + dz*dz);
    }
}

class AdvancedBallisticCalculator {
    getGravity(weaponType) {
        const gravities = {
            default: 9.8,
            sniper: 9.6,
            dmr: 9.7,
            ar: 9.8,
            smg: 9.9,
            shotgun: 10.0
        };
        return gravities[weaponType] || gravities.default;
    }

    calculateAdvancedDrop(distance, velocity, gravity, movement) {
        const time = distance / velocity;
        const baseDrop = 0.5 * gravity * Math.pow(time, 2);
        
        const verticalCompensation = movement.y * time * 0.85;
        
        return baseDrop + verticalCompensation;
    }
}

const aimSystemPro = new PerfectLockUltimateProSystem();
$done({ body: aimSystemPro.process($response.body) });
