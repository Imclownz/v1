// HEADSHOT MASTER v35.0 (ULTIMATE HEADSHOT SYSTEM)
class UltimateHeadshotSystem {
    constructor() {
        // Cấu hình cơ bản
        this.lockStrength = 0.99999;
        this.targetHistory = new Map();
        this.sessionToken = `HS_ULTRA_${Date.now().toString(36)}_${Math.random().toString(36).substr(2, 9)}`;
        this.weaponProfiles = this.getPrecisionWeaponProfiles();
        this.aimPredictionLevel = 15;
        this.aimStabilizer = 0.9998;
        this.headshotAccuracy = 0.999;
        this.headshotExpansion = 10.0; // Mở rộng vùng headshot 10x
        this.maxHistory = 30;
        this.lockedHeadPosition = null;
        this.lastTargetId = null;
        this.targetSwitchCooldown = 0;
        this.emergencyLockMode = false;
        
        // Module chính
        this.targetDetector = new AdvancedTargetDetector();
        this.autoAimSystem = new AutoAimSystem();
        this.bulletTracker = new BulletTracker();
        this.targetPredictor = new TargetPredictor();
        this.aimLockController = new AimLockController();
        this.recoilCompensator = new RecoilCompensator();
        this.performanceOptimizer = new PerformanceOptimizer();
        this.stealthModule = new StealthModule();
        this.combatAnalyzer = new CombatAnalyzer();
    }

    process(body) {
        try {
            const startTime = Date.now();
            const data = JSON.parse(body);
            
            // Tối ưu hiệu suất
            this.performanceOptimizer.adjustSettings(data.performanceState);
            
            // Phân tích tình huống chiến đấu
            this.combatAnalyzer.analyze(data.gameState);
            
            // Tự động phát hiện kẻ địch
            const detectedTargets = this.targetDetector.detectTargets(data);
            data.targets = detectedTargets;
            
            if (detectedTargets.length > 0) {
                // Phân tích và ưu tiên mục tiêu
                const priorityTarget = this.selectPriorityTarget(detectedTargets, data.gameState);
                
                // Áp dụng khóa aim tự động
                if (priorityTarget) {
                    const aimData = this.autoAimSystem.acquireTarget(
                        priorityTarget, 
                        data.currentAimPosition,
                        data.playerPosition,
                        data.currentWeapon,
                        data.gameState
                    );
                    
                    // Cập nhật vị trí ngắm
                    data.aimPosition = aimData.position;
                    
                    // Áp dụng khóa đầu chặt
                    if (aimData.lockStrength >= 0.99) {
                        data.autoFire = true;
                        data.fireMode = "headshot_lock";
                        
                        // Tính toán đường đạn chính xác
                        data.bulletTrajectory = this.bulletTracker.calculatePrecisionTrajectory(
                            data.playerPosition,
                            aimData.position,
                            priorityTarget,
                            data.currentWeapon,
                            data.gameState
                        );
                        
                        // Tự động điều chỉnh theo di chuyển của mục tiêu
                        if (this.aimLockController.isTargetMoving(priorityTarget)) {
                            const newPosition = this.targetPredictor.predictNextPosition(
                                priorityTarget,
                                data.bulletTrajectory.travelTime
                            );
                            data.aimPosition = this.aimLockController.adjustAimForMovement(
                                data.aimPosition,
                                newPosition
                            );
                        }
                    }
                    
                    // Bù giật súng
                    if (data.gameState?.isFiring) {
                        data.aimPosition = this.recoilCompensator.compensate(
                            data.aimPosition,
                            data.currentWeapon,
                            data.gameState.recoilPattern
                        );
                    }
                    
                    this.lastLockTime = Date.now();
                }
                
                // Che giấu hành vi
                this.stealthModule.concealAimBehavior(data);
            }
            
            // Tạo dữ liệu hệ thống
            data.aimSystem = this.getSystemMetadata(startTime);
            return JSON.stringify(data);
        } catch (e) {
            console.error("[ULTIMATE SYSTEM] Error:", e.message);
            return body;
        }
    }
    
    selectPriorityTarget(targets, gameState) {
        if (targets.length === 0) return null;
        
        // Tính điểm ưu tiên cho từng mục tiêu
        let maxPriority = -1;
        let selectedTarget = null;
        
        for (const target of targets) {
            let priority = 0;
            
            // Ưu tiên mục tiêu gần
            priority += (200 - Math.min(200, target.distance)) * 0.8;
            
            // Ưu tiên mục tiêu đang nhắm vào người chơi
            if (target.isAimingAtPlayer) priority += 70;
            
            // Ưu tiên mục tiêu có máu thấp
            if (target.health < 30) priority += 50;
            
            // Ưu tiên mục tiêu nguy hiểm
            if (target.isHighThreat) priority += 60;
            
            // Ưu tiên mục tiêu đứng yên
            if (target.movementSpeed < 0.1) priority += 40;
            
            // Điều chỉnh theo trạng thái người chơi
            if (gameState.playerHealth < 30) {
                priority += (100 - target.distance) * 1.5;
            }
            
            if (priority > maxPriority) {
                maxPriority = priority;
                selectedTarget = target;
            }
        }
        
        return selectedTarget;
    }
    
    getSystemMetadata(startTime) {
        return {
            version: "35.0",
            mode: "auto_headshot_lock",
            features: {
                autoTargetDetection: true,
                bulletTracking: true,
                predictiveAiming: true,
                headshotExpansion: this.headshotExpansion,
                stealthMode: true
            },
            performance: {
                processingTime: Date.now() - startTime,
                fps: this.performanceOptimizer.currentFPS
            },
            lockStatus: {
                strength: this.lockStrength,
                targetId: this.lastTargetId
            }
        };
    }
    
    getPrecisionWeaponProfiles() {
        return {
            default: {
                bulletVelocity: 380,
                stability: 0.95,
                horizontalRecoil: 0.035,
                verticalRecoil: 0.065,
                aimAssistFactor: 1.0
            },
            sniper: {
                bulletVelocity: 950,
                stability: 0.99,
                horizontalRecoil: 0.008,
                verticalRecoil: 0.095,
                aimAssistFactor: 1.2
            },
            ak47: {
                bulletVelocity: 360,
                stability: 0.92,
                horizontalRecoil: 0.065,
                verticalRecoil: 0.125,
                aimAssistFactor: 0.95
            },
            m4a1: {
                bulletVelocity: 400,
                stability: 0.94,
                horizontalRecoil: 0.048,
                verticalRecoil: 0.085,
                aimAssistFactor: 1.1
            },
            shotgun: {
                bulletVelocity: 300,
                stability: 0.85,
                horizontalRecoil: 0.075,
                verticalRecoil: 0.135,
                aimAssistFactor: 0.85
            }
        };
    }
}

// =============== MODULE PHÁT HIỆN MỤC TIÊU TỰ ĐỘNG ===============
class AdvancedTargetDetector {
    constructor() {
        this.detectionAlgorithms = {
            visual: new VisualDetection(),
            radar: new RadarDetection()
        };
        this.targetConfidenceThreshold = 0.85;
        this.minDetectionSize = 15;
    }
    
    detectTargets(gameData) {
        const targets = [];
        
        // Phát hiện qua hình ảnh
        if (gameData.visualData) {
            const visualTargets = this.detectionAlgorithms.visual.process(gameData.visualData);
            targets.push(...visualTargets.filter(t => t.confidence >= this.targetConfidenceThreshold));
        }
        
        // Phát hiện qua radar
        if (gameData.radarData) {
            const radarTargets = this.detectionAlgorithms.radar.process(gameData.radarData);
            targets.push(...radarTargets.filter(t => t.confidence >= this.targetConfidenceThreshold));
        }
        
        // Kết hợp và loại bỏ trùng lặp
        const mergedTargets = this.mergeTargets(targets);
        
        // Tăng cường dữ liệu mục tiêu
        return mergedTargets.map(target => 
            this.enhanceTarget(target, gameData.playerPosition)
        );
    }
    
    mergeTargets(targets) {
        const merged = [];
        const positionTolerance = 1.5;
        
        for (const target of targets) {
            let existing = null;
            
            // Tìm mục tiêu trùng lặp trong phạm vi cho phép
            for (const mergedTarget of merged) {
                const distance = this.calculateDistance(
                    target.position, 
                    mergedTarget.position
                );
                
                if (distance < positionTolerance) {
                    existing = mergedTarget;
                    break;
                }
            }
            
            if (existing) {
                // Kết hợp dữ liệu từ các nguồn khác nhau
                existing.confidence = Math.max(existing.confidence, target.confidence);
                existing.position = {
                    x: (existing.position.x + target.position.x) / 2,
                    y: (existing.position.y + target.position.y) / 2,
                    z: (existing.position.z + target.position.z) / 2
                };
                
                // Kết hợp các thuộc tính bổ sung
                if (target.team) existing.team = target.team;
                if (target.health) existing.health = target.health;
            } else {
                merged.push({...target});
            }
        }
        
        return merged;
    }
    
    enhanceTarget(target, playerPosition) {
        // Tính toán thông tin bổ sung
        target.distance = this.calculateDistance(target.position, playerPosition);
        target.headHitbox = this.calculateHeadHitbox(target);
        target.priority = this.calculateThreatLevel(target);
        return target;
    }
    
    calculateDistance(pos1, pos2) {
        return Math.sqrt(
            Math.pow(pos1.x - pos2.x, 2) +
            Math.pow(pos1.y - pos2.y, 2) +
            Math.pow(pos1.z - pos2.z, 2)
        );
    }
    
    calculateHeadHitbox(target) {
        // Tính toán vùng headshot dựa trên model nhân vật
        const headRadius = target.type === 'player' ? 0.35 : 0.25;
        const headHeightOffset = target.isCrouching ? 0.65 : 1.65;
        
        return {
            x: target.position.x,
            y: target.position.y + headHeightOffset,
            z: target.position.z,
            radius: headRadius
        };
    }
    
    calculateThreatLevel(target) {
        let threat = 0;
        
        // Mục tiêu đang nhắm vào người chơi
        if (target.isAimingAtPlayer) threat += 8;
        
        // Mục tiêu có vũ khí mạnh
        if (target.weaponType === 'sniper' || target.weaponType === 'shotgun') threat += 7;
        
        // Mục tiêu gần
        if (target.distance < 20) threat += 6;
        
        return threat;
    }
}

// =============== MODULE TỰ ĐỘNG KHÓA AIM ===============
class AutoAimSystem {
    constructor() {
        this.lockSpeed = 0.15;
        this.maxLockTime = 0.5;
        this.lockThreshold = 0.95;
        this.smoothingFactor = 0.85;
        this.headshotPriority = 9.5;
        this.maxAimHeight = 1.8; // Giới hạn tâm ngắm không vượt quá chiều cao này
    }
    
    acquireTarget(target, currentAimPos, playerPos, weaponType, gameState) {
        // Tính vị trí aim chính xác
        const perfectAim = this.calculatePerfectAim(target, playerPos, weaponType);
        
        // Dịch chuyển tâm súng
        const newAimPos = this.moveAimToTarget(currentAimPos, perfectAim, gameState, target);
        
        // Tính độ bám của khóa
        const lockStrength = this.calculateLockStrength(newAimPos, perfectAim, target);
        
        return {
            position: newAimPos,
            lockStrength: lockStrength
        };
    }
    
    calculatePerfectAim(target, playerPos, weaponType) {
        // Tính toán vị trí aim hoàn hảo (có dự đoán chuyển động)
        const basePos = target.headHitbox;
        const travelTime = this.calculateBulletTravelTime(playerPos, basePos, weaponType);
        const predictedMovement = this.predictMovement(target, travelTime);
        
        return {
            x: basePos.x + predictedMovement.x,
            y: basePos.y + predictedMovement.y,
            z: basePos.z + predictedMovement.z
        };
    }
    
    calculateBulletTravelTime(startPos, endPos, weaponType) {
        const distance = Math.sqrt(
            Math.pow(endPos.x - startPos.x, 2) +
            Math.pow(endPos.y - startPos.y, 2) +
            Math.pow(endPos.z - startPos.z, 2)
        );
        
        const weaponProfile = this.getWeaponProfile(weaponType);
        return distance / weaponProfile.bulletVelocity;
    }
    
    predictMovement(target, time) {
        // Dự đoán chuyển động đơn giản dựa trên vận tốc hiện tại
        return {
            x: target.movement.x * time * 1.2,
            y: target.movement.y * time * 1.2,
            z: target.movement.z * time * 0.8
        };
    }
    
    moveAimToTarget(currentPos, targetPos, gameState, target) {
        // Tính toán tốc độ di chuyển tâm ngắm
        const distance = Math.sqrt(
            Math.pow(targetPos.x - currentPos.x, 2) +
            Math.pow(targetPos.y - currentPos.y, 2)
        );
        
        // Giảm lực kéo khi bắn ở tầm xa
        let moveSpeed = Math.min(1.0, this.lockSpeed * (1 + distance / 50));
        if (distance > 100) moveSpeed *= 0.7;
        if (distance > 200) moveSpeed *= 0.5;
        
        // Tính toán hướng di chuyển
        const direction = {
            x: targetPos.x - currentPos.x,
            y: targetPos.y - currentPos.y,
            z: targetPos.z - currentPos.z
        };
        
        // Áp dụng làm mượt
        const newPos = {
            x: currentPos.x + direction.x * moveSpeed * this.smoothingFactor,
            y: currentPos.y + direction.y * moveSpeed * this.smoothingFactor,
            z: currentPos.z + direction.z * moveSpeed * this.smoothingFactor * 0.95
        };
        
        // Ngăn chặn tình trạng lố đầu
        const maxY = target.position.y + this.maxAimHeight;
        if (newPos.y > maxY) {
            newPos.y = Math.min(newPos.y, maxY);
        }
        
        return newPos;
    }
    
    calculateLockStrength(aimPos, targetPos, target) {
        // Tính toán độ chính xác của khóa aim
        const distance = Math.sqrt(
            Math.pow(aimPos.x - targetPos.x, 2) +
            Math.pow(aimPos.y - targetPos.y, 2)
        );
        
        const maxDistance = target.headHitbox.radius * 3;
        return Math.max(0, 1 - (distance / maxDistance));
    }
    
    getWeaponProfile(weaponType) {
        const profiles = {
            default: { bulletVelocity: 380 },
            sniper: { bulletVelocity: 950 },
            ak47: { bulletVelocity: 360 },
            m4a1: { bulletVelocity: 400 },
            shotgun: { bulletVelocity: 300 }
        };
        
        return profiles[weaponType] || profiles.default;
    }
}

// =============== MODULE THEO DÕI ĐƯỜNG ĐẠN ===============
class BulletTracker {
    constructor() {
        this.bulletPhysics = new BulletPhysics();
        this.trajectoryCalculator = new TrajectoryCalculator();
        this.impactPredictor = new ImpactPredictor();
    }
    
    calculatePrecisionTrajectory(startPos, aimPos, target, weaponType, gameState) {
        // Tính toán thời gian đạn bay
        const travelTime = this.calculateBulletTravelTime(startPos, aimPos, weaponType);
        
        // Dự đoán vị trí mục tiêu sau thời gian đạn bay
        const predictedPos = this.predictFuturePosition(target, travelTime);
        
        // Tính toán hiệu chỉnh đường đạn
        const correction = this.calculateTrajectoryCorrection(startPos, predictedPos, weaponType, gameState);
        
        return {
            start: startPos,
            end: predictedPos,
            correction: correction,
            travelTime: travelTime,
            guaranteedHit: this.impactPredictor.willHitHead(predictedPos, target)
        };
    }
    
    calculateBulletTravelTime(startPos, endPos, weaponType) {
        const distance = Math.sqrt(
            Math.pow(endPos.x - startPos.x, 2) +
            Math.pow(endPos.y - startPos.y, 2) +
            Math.pow(endPos.z - startPos.z, 2)
        );
        
        const weaponProfile = this.getWeaponProfile(weaponType);
        return distance / weaponProfile.bulletVelocity;
    }
    
    predictFuturePosition(target, time) {
        // Dự đoán vị trí tương lai dựa trên vận tốc hiện tại
        return {
            x: target.position.x + target.movement.x * time,
            y: target.position.y + target.movement.y * time,
            z: target.position.z + target.movement.z * time
        };
    }
    
    calculateTrajectoryCorrection(startPos, endPos, weaponType, gameState) {
        const gravity = 9.81;
        const windEffect = gameState.environment?.wind || {x: 0, y: 0, z: 0};
        const distance = Math.sqrt(
            Math.pow(endPos.x - startPos.x, 2) +
            Math.pow(endPos.y - startPos.y, 2)
        );
        
        // Tính toán hiệu chỉnh trọng lực
        const drop = 0.5 * gravity * Math.pow(distance / 400, 2);
        
        // Tính toán hiệu chỉnh gió
        const windCorrection = {
            x: windEffect.x * distance * 0.0015,
            y: windEffect.y * distance * 0.0015,
            z: windEffect.z * distance * 0.0005
        };
        
        return {
            x: windCorrection.x,
            y: -drop + windCorrection.y,
            z: windCorrection.z
        };
    }
    
    willHitHead(predictedPos, target) {
        // Kiểm tra xem đạn có trúng đầu không
        const headPos = target.headHitbox;
        const distance = Math.sqrt(
            Math.pow(predictedPos.x - headPos.x, 2) +
            Math.pow(predictedPos.y - headPos.y, 2)
        );
        
        return distance <= (headPos.radius * 1.2);
    }
    
    getWeaponProfile(weaponType) {
        const profiles = {
            default: { bulletVelocity: 380 },
            sniper: { bulletVelocity: 950 },
            ak47: { bulletVelocity: 360 },
            m4a1: { bulletVelocity: 400 },
            shotgun: { bulletVelocity: 300 }
        };
        
        return profiles[weaponType] || profiles.default;
    }
}

// =============== MODULE DỰ ĐOÁN CHUYỂN ĐỘNG MỤC TIÊU ===============
class TargetPredictor {
    constructor() {
        this.predictionModels = {
            linear: new LinearPredictionModel(),
            erratic: new ErraticPredictionModel(),
            jumping: new JumpPredictionModel()
        };
        this.movementHistory = new Map();
        this.maxHistorySize = 20;
        this.predictionAccuracy = 0.92;
    }
    
    predictNextPosition(target, timeAhead) {
        // Lấy lịch sử di chuyển
        const history = this.getMovementHistory(target.id);
        
        // Thêm vị trí hiện tại vào lịch sử
        this.updateHistory(target, history);
        
        // Chọn mô hình dự đoán phù hợp
        const modelType = this.determineMovementPattern(target, history);
        const predictionModel = this.predictionModels[modelType];
        
        // Tạo dự đoán
        return predictionModel.predict(target, history, timeAhead);
    }
    
    getMovementHistory(targetId) {
        if (!this.movementHistory.has(targetId)) {
            this.movementHistory.set(targetId, {
                positions: [],
                timestamps: [],
                velocities: []
            });
        }
        return this.movementHistory.get(targetId);
    }
    
    updateHistory(target, history) {
        const currentTime = Date.now();
        
        // Thêm vị trí hiện tại
        history.positions.push({...target.position});
        history.timestamps.push(currentTime);
        
        // Tính vận tốc nếu có đủ dữ liệu
        if (history.positions.length > 1) {
            const lastPos = history.positions[history.positions.length - 2];
            const currentPos = history.positions[history.positions.length - 1];
            const timeDiff = (history.timestamps[history.timestamps.length - 1] - 
                             history.timestamps[history.timestamps.length - 2]) / 1000;
            
            if (timeDiff > 0) {
                const velocity = {
                    x: (currentPos.x - lastPos.x) / timeDiff,
                    y: (currentPos.y - lastPos.y) / timeDiff,
                    z: (currentPos.z - lastPos.z) / timeDiff
                };
                history.velocities.push(velocity);
            }
        }
        
        // Giới hạn lịch sử
        if (history.positions.length > this.maxHistorySize) {
            history.positions.shift();
            history.timestamps.shift();
            if (history.velocities.length > 0) history.velocities.shift();
        }
    }
    
    determineMovementPattern(target, history) {
        if (history.velocities.length < 3) return 'linear';
        
        // Tính toán độ biến thiên hướng di chuyển
        let directionChanges = 0;
        for (let i = 1; i < history.velocities.length; i++) {
            const prev = history.velocities[i-1];
            const curr = history.velocities[i];
            
            const angleChange = Math.abs(
                Math.atan2(curr.y, curr.x) - Math.atan2(prev.y, prev.x)
            );
            
            if (angleChange > 0.5) directionChanges++;
        }
        
        const changeRatio = directionChanges / history.velocities.length;
        
        if (target.isJumping) return 'jumping';
        if (changeRatio > 0.4) return 'erratic';
        return 'linear';
    }
}

// =============== MÔ HÌNH DỰ ĐOÁN TUYẾN TÍNH ===============
class LinearPredictionModel {
    predict(target, history, timeAhead) {
        if (history.velocities.length === 0) return target.position;
        
        const lastVelocity = history.velocities[history.velocities.length - 1];
        
        return {
            x: target.position.x + lastVelocity.x * timeAhead,
            y: target.position.y + lastVelocity.y * timeAhead,
            z: target.position.z + lastVelocity.z * timeAhead
        };
    }
}

// =============== MÔ HÌNH DỰ ĐOÁN KHÔNG TUYẾN TÍNH ===============
class ErraticPredictionModel {
    predict(target, history, timeAhead) {
        if (history.velocities.length < 2) {
            return new LinearPredictionModel().predict(target, history, timeAhead);
        }
        
        // Tính gia tốc trung bình
        let accelSum = {x: 0, y: 0, z: 0};
        for (let i = 1; i < history.velocities.length; i++) {
            const prev = history.velocities[i-1];
            const curr = history.velocities[i];
            const timeDiff = (history.timestamps[i] - history.timestamps[i-1]) / 1000;
            
            if (timeDiff > 0) {
                accelSum.x += (curr.x - prev.x) / timeDiff;
                accelSum.y += (curr.y - prev.y) / timeDiff;
                accelSum.z += (curr.z - prev.z) / timeDiff;
            }
        }
        
        const avgAccel = {
            x: accelSum.x / (history.velocities.length - 1),
            y: accelSum.y / (history.velocities.length - 1),
            z: accelSum.z / (history.velocities.length - 1)
        };
        
        const lastVelocity = history.velocities[history.velocities.length - 1];
        
        // Dự đoán với gia tốc
        return {
            x: target.position.x + lastVelocity.x * timeAhead + 0.5 * avgAccel.x * timeAhead * timeAhead,
            y: target.position.y + lastVelocity.y * timeAhead + 0.5 * avgAccel.y * timeAhead * timeAhead,
            z: target.position.z + lastVelocity.z * timeAhead + 0.5 * avgAccel.z * timeAhead * timeAhead
        };
    }
}

// =============== MÔ HÌNH DỰ ĐOÁN KHI NHẢY ===============
class JumpPredictionModel {
    predict(target, history, timeAhead) {
        const basePrediction = new LinearPredictionModel().predict(target, history, timeAhead);
        
        // Tính toán quỹ đạo nhảy
        if (target.isJumping) {
            const gravity = 9.81;
            const jumpVelocity = 4.5;
            const jumpHeight = jumpVelocity * timeAhead - 0.5 * gravity * timeAhead * timeAhead;
            
            return {
                x: basePrediction.x,
                y: basePrediction.y + jumpHeight,
                z: basePrediction.z
            };
        }
        
        return basePrediction;
    }
}

// =============== MODULE KIỂM SOÁT KHÓA AIM ===============
class AimLockController {
    constructor() {
        this.lockSensitivity = 0.95;
        this.minLockTime = 0.3;
        this.maxLockDistance = 200;
        this.lastLockTime = 0;
    }
    
    isTargetLocked(target, aimPosition) {
        const distance = this.calculateAimDistance(aimPosition, target.headHitbox);
        return distance < (target.headHitbox.radius * 0.5);
    }
    
    isTargetMoving(target) {
        const speed = Math.sqrt(
            target.movement.x * target.movement.x +
            target.movement.y * target.movement.y
        );
        return speed > 0.1;
    }
    
    adjustAimForMovement(currentAim, newPosition) {
        // Tính toán sự dịch chuyển cần thiết
        const moveVector = {
            x: newPosition.x - currentAim.x,
            y: newPosition.y - currentAim.y,
            z: newPosition.z - currentAim.z
        };
        
        // Áp dụng với độ nhạy
        return {
            x: currentAim.x + moveVector.x * this.lockSensitivity,
            y: currentAim.y + moveVector.y * this.lockSensitivity,
            z: currentAim.z + moveVector.z * this.lockSensitivity * 0.9
        };
    }
    
    canAcquireLock(target) {
        // Kiểm tra điều kiện khóa
        const currentTime = Date.now();
        const timeSinceLastLock = currentTime - this.lastLockTime;
        
        if (timeSinceLastLock < this.minLockTime * 1000) return false;
        if (target.distance > this.maxLockDistance) return false;
        
        return true;
    }
    
    calculateAimDistance(aimPos, targetPos) {
        return Math.sqrt(
            Math.pow(aimPos.x - targetPos.x, 2) +
            Math.pow(aimPos.y - targetPos.y, 2)
        );
    }
}

// =============== MODULE BÙ GIẬT SÚNG ===============
class RecoilCompensator {
    constructor() {
        this.recoilPatterns = {
            default: { vertical: 0.1, horizontal: 0.03 },
            sniper: { vertical: 0.25, horizontal: 0.01 },
            ak47: { vertical: 0.15, horizontal: 0.05 },
            m4a1: { vertical: 0.12, horizontal: 0.04 },
            shotgun: { vertical: 0.18, horizontal: 0.08 }
        };
        this.compensationFactors = {
            vertical: 0.85,
            horizontal: 0.75
        };
        this.learnRate = 0.85;
    }
    
    compensate(aimPosition, weaponType, recoilData) {
        // Lấy mẫu giật của vũ khí
        const pattern = this.getRecoilPattern(weaponType);
        
        // Cập nhật mẫu giật dựa trên dữ liệu thực tế
        this.updatePattern(weaponType, recoilData);
        
        // Tính toán lượng bù cần thiết
        const compensation = {
            x: pattern.horizontal * this.compensationFactors.horizontal,
            y: pattern.vertical * this.compensationFactors.vertical,
            z: 0
        };
        
        // Áp dụng bù giật
        return {
            x: aimPosition.x - compensation.x,
            y: aimPosition.y - compensation.y,
            z: aimPosition.z - compensation.z
        };
    }
    
    getRecoilPattern(weaponType) {
        return this.recoilPatterns[weaponType] || this.recoilPatterns.default;
    }
    
    updatePattern(weaponType, newPattern) {
        if (!newPattern) return;
        
        const currentPattern = this.getRecoilPattern(weaponType);
        
        // Cập nhật mẫu giật với tỷ lệ học tập
        const updatedPattern = {
            vertical: currentPattern.vertical * (1 - this.learnRate) + newPattern.vertical * this.learnRate,
            horizontal: currentPattern.horizontal * (1 - this.learnRate) + newPattern.horizontal * this.learnRate
        };
        
        this.recoilPatterns[weaponType] = updatedPattern;
    }
}

// =============== MODULE TỐI ƯU HIỆU SUẤT ===============
class PerformanceOptimizer {
    constructor() {
        this.qualityProfiles = {
            low: { aimLevel: 8, detectionRate: 0.8 },
            medium: { aimLevel: 10, detectionRate: 0.9 },
            high: { aimLevel: 12, detectionRate: 0.95 },
            ultra: { aimLevel: 15, detectionRate: 0.99 }
        };
        this.currentProfile = "high";
        this.currentFPS = 60;
    }
    
    adjustSettings(performanceState) {
        if (!performanceState) return;
        
        this.currentFPS = performanceState.fps || 60;
        
        if (this.currentFPS < 45) {
            this.currentProfile = "low";
        } else if (this.currentFPS < 60) {
            this.currentProfile = "medium";
        } else if (this.currentFPS < 90) {
            this.currentProfile = "high";
        } else {
            this.currentProfile = "ultra";
        }
    }
    
    getSettings() {
        return this.qualityProfiles[this.currentProfile];
    }
}

// =============== MODULE CHE GIẤU ===============
class StealthModule {
    constructor() {
        this.randomizationFactors = {
            reactionTime: 0.15,
            aimPrecision: 0.1,
            lockTime: 0.2
        };
        this.behaviorPatterns = [];
        this.lastBehaviorChange = 0;
    }
    
    concealAimBehavior(gameData) {
        const currentTime = Date.now();
        
        // Thay đổi hành vi định kỳ
        if (currentTime - this.lastBehaviorChange > 30000) {
            this.randomizeBehaviorPattern();
            this.lastBehaviorChange = currentTime;
        }
        
        // Áp dụng pattern hành vi hiện tại
        this.applyCurrentPattern(gameData);
    }
    
    randomizeBehaviorPattern() {
        // Tạo pattern hành vi ngẫu nhiên
        this.behaviorPatterns = [
            { type: 'reaction', value: Math.random() * 0.2 },
            { type: 'precision', value: Math.random() * 0.15 },
            { type: 'smoothness', value: 0.7 + Math.random() * 0.3 }
        ];
    }
    
    applyCurrentPattern(gameData) {
        for (const pattern of this.behaviorPatterns) {
            switch (pattern.type) {
                case 'reaction':
                    gameData.responseTime += pattern.value * 100;
                    break;
                case 'precision':
                    if (gameData.aimPosition) {
                        gameData.aimPosition.x += (Math.random() * 2 - 1) * pattern.value;
                        gameData.aimPosition.y += (Math.random() * 2 - 1) * pattern.value;
                    }
                    break;
                case 'smoothness':
                    // Điều chỉnh độ mượt của chuyển động
                    break;
            }
        }
    }
}

// =============== MODULE PHÂN TÍCH CHIẾN ĐẤU ===============
class CombatAnalyzer {
    constructor() {
        this.threatLevels = {};
        this.combatStates = ["calm", "active", "intense", "critical"];
        this.currentState = "calm";
        this.stateHistory = [];
    }
    
    analyze(gameState) {
        if (!gameState) return;
        
        // Phân tích mức độ nguy hiểm
        const threatScore = this.calculateThreatScore(gameState);
        
        // Cập nhật trạng thái chiến đấu
        this.updateCombatState(threatScore);
        
        // Lưu lịch sử trạng thái
        this.stateHistory.push({
            state: this.currentState,
            timestamp: Date.now()
        });
        
        // Giới hạn lịch sử
        if (this.stateHistory.length > 50) {
            this.stateHistory.shift();
        }
    }
    
    calculateThreatScore(gameState) {
        let score = 0;
        
        // Số lượng kẻ địch
        score += Math.min(5, gameState.enemyCount) * 0.8;
        
        // Khoảng cách gần nhất
        if (gameState.nearestEnemyDistance < 20) score += 3;
        else if (gameState.nearestEnemyDistance < 50) score += 2;
        
        // Máu của người chơi
        if (gameState.playerHealth < 30) score += 2.5;
        else if (gameState.playerHealth < 60) score += 1.5;
        
        // Thời gian chiến đấu liên tục
        if (gameState.combatDuration > 30) score += 1.0;
        
        return Math.min(10, score);
    }
    
    updateCombatState(threatScore) {
        if (threatScore > 8) {
            this.currentState = "critical";
        } else if (threatScore > 6) {
            this.currentState = "intense";
        } else if (threatScore > 3) {
            this.currentState = "active";
        } else {
            this.currentState = "calm";
        }
    }
    
    isInCombat() {
        return this.currentState !== "calm";
    }
}

// =============== HỆ THỐNG CON PHÁT HIỆN HÌNH ẢNH ===============
class VisualDetection {
    process(visualData) {
        const targets = [];
        
        // Giả lập quá trình phát hiện mục tiêu bằng hình ảnh
        for (const entity of visualData.entities) {
            if (entity.type === 'player' && entity.visible) {
                targets.push({
                    id: entity.id,
                    position: entity.position,
                    confidence: 0.9,
                    type: 'player',
                    team: entity.team
                });
            }
        }
        
        return targets;
    }
}

// =============== HỆ THỐNG CON PHÁT HIỆN RADAR ===============
class RadarDetection {
    process(radarData) {
        const targets = [];
        
        // Giả lập phát hiện mục tiêu qua radar
        for (const blip of radarData.blips) {
            if (blip.size > 5 && blip.movement > 0.1) {
                targets.push({
                    id: `radar_${blip.id}`,
                    position: blip.position,
                    confidence: 0.8,
                    type: 'radar_target'
                });
            }
        }
        
        return targets;
    }
}

// =============== HỆ THỐNG CON VẬT LÝ ĐẠN ===============
class BulletPhysics {
    calculateBulletDrop(distance, bulletVelocity, gravity) {
        const time = distance / bulletVelocity;
        return 0.5 * gravity * time * time;
    }
    
    calculateWindDrift(distance, windSpeed, bulletMass) {
        return (windSpeed * distance) / (bulletMass * 100);
    }
}

// =============== HỆ THỐNG CON TÍNH TOÁN QUỸ ĐẠO ===============
class TrajectoryCalculator {
    calculateTrajectory(startPos, endPos, bulletVelocity, gravity, wind) {
        const distance = Math.sqrt(
            Math.pow(endPos.x - startPos.x, 2) +
            Math.pow(endPos.y - startPos.y, 2)
        );
        
        const time = distance / bulletVelocity;
        const drop = 0.5 * gravity * time * time;
        const windDrift = wind.x * time * 0.3;
        
        return {
            x: endPos.x + windDrift,
            y: endPos.y - drop,
            z: endPos.z
        };
    }
}

// =============== HỆ THỐNG CON DỰ ĐOÁN TÁC ĐỘNG ===============
class ImpactPredictor {
    predictImpact(projectile, target) {
        const distance = Math.sqrt(
            Math.pow(projectile.position.x - target.position.x, 2) +
            Math.pow(projectile.position.y - target.position.y, 2)
        );
        
        return distance < target.radius;
    }
    
    calculateDamage(projectile, target, hitLocation) {
        let damage = projectile.baseDamage;
        
        // Nhân hệ số vị trí trúng đạn
        if (hitLocation === 'head') damage *= 2.5;
        else if (hitLocation === 'body') damage *= 1.0;
        else damage *= 0.7;
        
        return damage;
    }
}

// =============== KHỞI CHẠY HỆ THỐNG ===============
const aimSystem = new UltimateHeadshotSystem();
$done({ body: aimSystem.process($response.body) });
