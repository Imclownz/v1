// perfectlock-ultimate.js
class PerfectLockUltimateSystem {
    constructor() {
        this.lockStrength = 0.99;
        this.targetHistory = new Map();
        this.sessionToken = `PLOCK_${Date.now().toString(36)}_${Math.random().toString(36).substring(2, 10)}`;
        this.weaponProfiles = this.getWeaponProfiles();
        this.ballisticCalculator = new BallisticCalculator();
        this.lastLockTime = 0;
        this.performanceMode = "balanced";
        this.aimPredictionLevel = 3;
    }

    process(body) {
        try {
            const data = JSON.parse(body);
            
            // Cập nhật chế độ hiệu năng
            this.updatePerformanceMode(data.performanceState);
            
            // Cập nhật dữ liệu trò chơi
            if (data.gameState) this.updateGameState(data.gameState);
            
            // Xử lý khi có mục tiêu
            if (data.targets && data.targets.length > 0) {
                const enhancedTargets = this.enhanceTargets(data.targets, data.playerPosition, data.currentWeapon);
                const lockedTarget = this.selectAndLockTarget(enhancedTargets);
                
                if (lockedTarget) {
                    data.aimPosition = this.calculatePerfectAim(lockedTarget, data.playerPosition, data.currentWeapon);
                    data.aimPosition = this.applyPerfectLock(data.aimPosition, data.currentAimPosition, lockedTarget.distance);
            if (data.recoilSystem && data.recoilSystem.crosshairStabilization) {
    // Tăng độ ổn định khi khóa mục tiêu
    if (data.aimSystem.lockStrength > 0.95) {
        data.aimPosition = {
            x: data.aimPosition.x * data.recoilSystem.crosshairStabilization.x * 1.5,
            y: data.aimPosition.y * data.recoilSystem.crosshairStabilization.y * 1.5,
            z: data.aimPosition.z * data.recoilSystem.crosshairStabilization.z * 1.2
        };
    }
    
    // Gửi thông tin về hệ thống recoil
    data.recoilSystem.aimLockStrength = data.aimSystem.lockStrength;
}
                    
                    // Tính toán đường đạn dẫn đường chỉ ở chế độ hiệu năng cao
                    if (this.performanceMode === "high") {
                        data.bulletTrajectory = this.calculateGuidedTrajectory(
                            data.playerPosition,
                            data.aimPosition,
                            lockedTarget,
                            data.currentWeapon
                        );
                    }
                    
                    // Đánh dấu thời gian khóa cuối cùng
                    this.lastLockTime = Date.now();
                }
                
                data.aimData = {
                    targets: enhancedTargets,
                    lockedTarget,
                    lockStrength: this.lockStrength,
                    predictionLevel: this.aimPredictionLevel
                };
            }
            
            // Thêm metadata hệ thống
            data.aimSystem = this.getSystemMetadata();
            
            return JSON.stringify(data);
        } catch (e) {
            console.error("[PERFECTLOCK ULTIMATE] Error:", e.message.substring(0, 30));
            return body;
        }
    }

    updatePerformanceMode(performanceState) {
        if (!performanceState) return;
        
        // Tự động điều chỉnh chế độ hiệu năng
        if (performanceState.cpuUsage > 0.8 || performanceState.memoryUsage > 80) {
            this.performanceMode = "low";
            this.aimPredictionLevel = 1;
        } else if (performanceState.cpuUsage > 0.6 || performanceState.memoryUsage > 70) {
            this.performanceMode = "balanced";
            this.aimPredictionLevel = 2;
        } else {
            this.performanceMode = "high";
            this.aimPredictionLevel = 3;
        }
    }

    enhanceTargets(targets, playerPosition, weaponType) {
        return targets.map(target => {
            // Tính khoảng cách nâng cao
            const distance = this.calculateDistance(playerPosition, target.position);
            
            // Tính toán thời gian đạn bay
            const bulletSpeed = this.weaponProfiles[weaponType]?.bulletVelocity || 400;
            const travelTime = distance / bulletSpeed;
            
            // Chỉ tính toán chuyển động phức tạp ở chế độ hiệu năng cao
            let movementVector = { x: 0, y: 0, z: 0 };
            if (this.aimPredictionLevel > 1) {
                movementVector = this.calculateMovementVector(target);
            }
            
            return {
                ...target,
                distance,
                movement: movementVector,
                travelTime,
                predictedHeadPosition: this.predictHeadPosition(target, travelTime)
            };
        });
    }

    calculateMovementVector(target) {
        const now = Date.now();
        
        if (!this.targetHistory.has(target.id)) {
            this.targetHistory.set(target.id, {
                positions: [target.position],
                timestamps: [now]
            });
            return { x: 0, y: 0, z: 0 };
        }
        
        const history = this.targetHistory.get(target.id);
        history.positions.push(target.position);
        history.timestamps.push(now);
        
        // Giữ lịch sử tùy theo cấp độ dự đoán
        const maxHistory = this.aimPredictionLevel + 2;
        if (history.positions.length > maxHistory) {
            history.positions.shift();
            history.timestamps.shift();
        }
        
        // Tính vector chuyển động trung bình
        let totalX = 0, totalY = 0, totalZ = 0;
        let totalTime = 0;
        
        for (let i = 1; i < history.positions.length; i++) {
            const dx = history.positions[i].x - history.positions[i-1].x;
            const dy = history.positions[i].y - history.positions[i-1].y;
            const dz = history.positions[i].z - history.positions[i-1].z;
            const dt = (history.timestamps[i] - history.timestamps[i-1]) / 1000;
            
            totalX += dx / dt;
            totalY += dy / dt;
            totalZ += dz / dt;
            totalTime += dt;
        }
        
        const avgX = totalX / (history.positions.length - 1);
        const avgY = totalY / (history.positions.length - 1);
        const avgZ = totalZ / (history.positions.length - 1);
        
        return { x: avgX, y: avgY, z: avgZ };
    }

    predictHeadPosition(target, travelTime) {
        // Vị trí đầu hiện tại
        const currentHead = {
            x: target.position.x,
            y: target.position.y + target.height * 0.9,
            z: target.position.z
        };
        
        // Dự đoán vị trí đầu tương lai
        return {
            x: currentHead.x + (target.movement.x * travelTime * 1.15),
            y: currentHead.y + (target.movement.y * travelTime * 1.15),
            z: currentHead.z + (target.movement.z * travelTime * 1.15)
        };
    }

    selectAndLockTarget(targets) {
        // Ưu tiên mục tiêu đã khóa trước đó
        for (const target of targets) {
            if (target.isLocked && target.visible) {
                return target;
            }
        }
        
        // Tìm mục tiêu tốt nhất với thuật toán nâng cao
        return targets.reduce((best, current) => {
            if (!best) return current;
            
            // Tính điểm ưu tiên
            const currentScore = this.calculateTargetScore(current);
            const bestScore = this.calculateTargetScore(best);
            
            return currentScore > bestScore ? current : best;
        }, null);
    }

    calculateTargetScore(target) {
        let score = 0;
        
        // Ưu tiên mục tiêu gần
        score += Math.max(0, 100 - (target.distance / 2));
        
        // Ưu tiên mục tiêu ít máu
        score += (100 - target.health) * 0.8;
        
        // Ưu tiên mục tiêu di chuyển chậm
        const speed = Math.sqrt(
            target.movement.x * target.movement.x +
            target.movement.y * target.movement.y +
            target.movement.z * target.movement.z
        );
        score += Math.max(0, 50 - (speed * 10));
        
        // Trừ điểm nếu mục tiêu đang nhắm vào người chơi
        if (target.isAimingAtPlayer) score -= 30;
        
        return score;
    }

    calculatePerfectAim(target, playerPosition, weaponType) {
        // Vị trí đầu dự đoán
        let aimPosition = target.predictedHeadPosition;
        
        // Bù trọng lực cho đạn (với súng bắn tỉa)
        if (weaponType === 'sniper') {
            const gravity = 9.8; // m/s²
            const drop = 0.5 * gravity * Math.pow(target.travelTime, 2);
            aimPosition.y += drop;
        }
        
        // Hiệu chỉnh vũ khí
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        aimPosition.y += weaponProfile.verticalOffset;
        
        return aimPosition;
    }

    applyPerfectLock(targetPosition, currentPosition, distance) {
        // Tính toán hướng đến mục tiêu
        const direction = {
            x: targetPosition.x - currentPosition.x,
            y: targetPosition.y - currentPosition.y,
            z: targetPosition.z - currentPosition.z
        };
        
        // Áp dụng hiệu ứng khóa hoàn hảo
        const lockFactor = this.lockStrength * Math.min(1, 100 / distance);
        
        return {
            x: currentPosition.x + (direction.x * lockFactor),
            y: currentPosition.y + (direction.y * lockFactor),
            z: currentPosition.z + (direction.z * lockFactor * 0.8)
        };
    }

    calculateGuidedTrajectory(start, end, target, weaponType) {
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        const guidedFactor = weaponProfile.guidedFactor || 0;
        
        return {
            start,
            end: target.predictedHeadPosition,
            speed: weaponProfile.bulletVelocity,
            isGuided: guidedFactor > 0,
            correction: {
                x: (target.movement.x * target.travelTime * guidedFactor),
                y: (target.movement.y * target.travelTime * guidedFactor),
                z: (target.movement.z * target.travelTime * guidedFactor)
            }
        };
    }

    getWeaponProfiles() {
        return {
            default: {
                bulletVelocity: 400,
                verticalOffset: 0.05,
                guidedFactor: 0.3
            },
            sniper: {
                bulletVelocity: 1200,
                verticalOffset: -0.02,
                guidedFactor: 0.7
            },
            ar: {
                bulletVelocity: 800,
                verticalOffset: 0.03,
                guidedFactor: 0.4
            },
            smg: {
                bulletVelocity: 500,
                verticalOffset: 0.07,
                guidedFactor: 0.2
            },
            shotgun: {
                bulletVelocity: 350,
                verticalOffset: 0.1,
                guidedFactor: 0.1
            }
        };
    }

    updateGameState(gameState) {
        // Tăng cường độ khóa trong chiến đấu
        const inCombat = gameState.isInCombat || (Date.now() - this.lastLockTime < 3000);
        
        if (inCombat) {
            this.lockStrength = Math.min(0.999, this.lockStrength + 0.1);
        } else {
            this.lockStrength = Math.max(0.95, this.lockStrength - 0.05);
        }
        
        // Tăng cường khi ngắm bắn
        if (gameState.isAiming) {
            this.lockStrength = 0.995;
        }
        
        // Tăng cường khi máu thấp
        if (gameState.playerHealth < 30) {
            this.lockStrength = 0.999;
        }
    }

    getSystemMetadata() {
        return {
            version: "Ultimate-4.0",
            lockStrength: this.lockStrength,
            performanceMode: this.performanceMode,
            predictionLevel: this.aimPredictionLevel,
            security: {
                token: this.sessionToken,
                checksum: this.generateChecksum(),
                behaviorProfile: this.getRandomBehavior()
            }
        };
    }

    generateChecksum() {
        const crypto = require('crypto');
        const data = this.sessionToken + this.lockStrength;
        return crypto.createHash('sha512').update(data).digest('hex');
    }

    getRandomBehavior() {
        const behaviors = ["sniper", "assault", "stealth", "aggressive"];
        return behaviors[Math.floor(Math.random() * behaviors.length)];
    }
}

class BallisticCalculator {
    calculateDrop(distance, bulletVelocity, gravity = 9.8) {
        const time = distance / bulletVelocity;
        return 0.5 * gravity * Math.pow(time, 2);
    }
}

const aimSystem = new PerfectLockUltimateSystem();
$done({ body: aimSystem.process($response.body) });
