// magnetic-aim-system.js
const AIM_MODES = {
    STEALTH: {
        lockStrength: 0.85,
        humanizer: 0.1,
        predictionConfidence: 0.95,
        cpuLimit: 0.15
    },
    PRECISION: {
        lockStrength: 0.95,
        humanizer: 0.05,
        predictionConfidence: 0.99,
        cpuLimit: 0.25
    },
    AGGRESSIVE: {
        lockStrength: 0.99,
        humanizer: 0.01,
        predictionConfidence: 0.999,
        cpuLimit: 0.35
    }
};

class MagneticAimSystem {
    constructor() {
        this.currentMode = AIM_MODES.PRECISION;
        this.securityToken = "MAG_" + Math.random().toString(36).substring(2, 12) + "_" + Date.now().toString(36);
        this.targetCache = {};
        this.lockedTargetId = null;
        this.aimPositionHistory = [];
        this.weaponProfiles = this.getWeaponProfiles();
    }

    process(body) {
        try {
            let data = typeof body === 'string' ? JSON.parse(body) : body;
            
            // Auto-select mode based on combat state
            this.autoSelectMode(data.gameState);
            
            // Process targets if available
            if (data.targets && data.targets.length > 0) {
                // Enhance targets with additional data
                const enhancedTargets = data.targets.map(target => 
                    this.enhanceTarget(target, data.playerPosition, data.currentWeapon)
                );
                
                // Select and lock target
                const bestTarget = this.selectAndLockTarget(enhancedTargets);
                
                if (bestTarget) {
                    // Calculate perfect aim position
                    data.aimPosition = this.calculatePerfectAimPosition(
                        bestTarget, 
                        data.playerPosition, 
                        data.currentWeapon
                    );
                    
                    // Apply magnetic lock effect
                    data.aimPosition = this.applyMagneticLock(
                        data.aimPosition,
                        data.currentAimPosition,
                        bestTarget.distance
                    );
                    
                    // Store for next frame
                    this.aimPositionHistory.push({
                        position: data.aimPosition,
                        timestamp: Date.now()
                    });
                }
                
                data.aimData = {
                    targets: enhancedTargets,
                    lockedTarget: bestTarget,
                    weaponProfile: this.weaponProfiles[data.currentWeapon] || this.weaponProfiles.default
                };
            }
            
            // Add system metadata
            data.aimSystem = this.getSystemMetadata();
            
            return typeof body === 'string' ? JSON.stringify(data) : data;
        } catch (e) {
            console.error("[MAGNETIC AIM] Error:", e.message.substring(0, 30));
            return body;
        }
    }

    autoSelectMode(gameState) {
        // Aggressive mode during combat
        if (gameState && gameState.isInCombat && gameState.targetsInSight > 0) {
            this.currentMode = AIM_MODES.AGGRESSIVE;
            return;
        }
        
        // Precision mode when aiming down sights
        if (gameState && gameState.isAiming) {
            this.currentMode = AIM_MODES.PRECISION;
            return;
        }
        
        // Default to stealth mode
        this.currentMode = AIM_MODES.STEALTH;
    }

    enhanceTarget(target, playerPosition, weaponType) {
        // Calculate distance to target
        target.distance = this.calculateDistance(playerPosition, target.position);
        
        // Calculate movement vector
        target.movement = this.calculateMovementVector(target);
        
        // Calculate bullet travel time
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        target.bulletTravelTime = target.distance / weaponProfile.bulletVelocity;
        
        // Predict future head position
        target.predictedHeadPosition = this.predictHeadPosition(target);
        
        return target;
    }

    calculateDistance(pos1, pos2) {
        return Math.sqrt(
            Math.pow(pos2.x - pos1.x, 2) + 
            Math.pow(pos2.y - pos1.y, 2) + 
            Math.pow(pos2.z - pos1.z, 2)
        );
    }

    calculateMovementVector(target) {
        if (!this.targetCache[target.id]) {
            this.targetCache[target.id] = {
                position: target.position,
                timestamp: Date.now()
            };
            return { x: 0, y: 0, z: 0 };
        }
        
        const last = this.targetCache[target.id];
        const timeDelta = (Date.now() - last.timestamp) / 1000;
        
        // Update cache
        this.targetCache[target.id] = {
            position: target.position,
            timestamp: Date.now()
        };
        
        return {
            x: (target.position.x - last.position.x) / timeDelta,
            y: (target.position.y - last.position.y) / timeDelta,
            z: (target.position.z - last.position.z) / timeDelta
        };
    }

    predictHeadPosition(target) {
        // Calculate current head position (90% of character height)
        const currentHeadPos = {
            x: target.position.x,
            y: target.position.y + (target.height * 0.9),
            z: target.position.z
        };
        
        // Predict future position based on movement
        return {
            x: currentHeadPos.x + (target.movement.x * target.bulletTravelTime * 1.1),
            y: currentHeadPos.y + (target.movement.y * target.bulletTravelTime * 1.1),
            z: currentHeadPos.z + (target.movement.z * target.bulletTravelTime * 1.1)
        };
    }

    selectAndLockTarget(targets) {
        // If we have a locked target that's still valid, keep it
        if (this.lockedTargetId) {
            const currentLockedTarget = targets.find(t => t.id === this.lockedTargetId);
            if (currentLockedTarget && currentLockedTarget.visible) {
                return currentLockedTarget;
            }
        }
        
        // Otherwise, select the best target
        const bestTarget = this.findBestTarget(targets);
        this.lockedTargetId = bestTarget ? bestTarget.id : null;
        return bestTarget;
    }

    findBestTarget(targets) {
        // Filter only visible targets
        const visibleTargets = targets.filter(t => t.visible);
        if (visibleTargets.length === 0) return null;
        
        // Score targets based on multiple factors
        const scoredTargets = visibleTargets.map(target => {
            let score = 0;
            
            // Distance score (closer is better)
            score += Math.max(0, 100 - (target.distance / 2));
            
            // Health score (lower health is better)
            score += (100 - target.health) * 0.8;
            
            // Threat score (aiming at player is worse)
            if (target.isAimingAtPlayer) score -= 50;
            
            // Movement score (slower targets are easier to hit)
            const speed = Math.sqrt(
                Math.pow(target.movement.x, 2) + 
                Math.pow(target.movement.y, 2) + 
                Math.pow(target.movement.z, 2)
            );
            score += Math.max(0, 50 - (speed * 10));
            
            return { target, score };
        });
        
        // Sort by score descending
        scoredTargets.sort((a, b) => b.score - a.score);
        
        return scoredTargets.length > 0 ? scoredTargets[0].target : null;
    }

    calculatePerfectAimPosition(target, playerPosition, weaponType) {
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        
        // Use predicted head position as base
        let aimPosition = { ...target.predictedHeadPosition };
        
        // Apply weapon-specific adjustments
        aimPosition.y += weaponProfile.verticalOffset;
        
        // Add slight randomness for human-like behavior
        if (this.currentMode !== AIM_MODES.AGGRESSIVE) {
            aimPosition.x += (Math.random() - 0.5) * weaponProfile.humanizerIntensity;
            aimPosition.y += (Math.random() - 0.5) * weaponProfile.humanizerIntensity * 0.5;
        }
        
        return aimPosition;
    }

    applyMagneticLock(targetPosition, currentAimPosition, distance) {
        // How strongly we pull toward the target (0-1)
        const lockStrength = this.currentMode.lockStrength;
        
        // Distance factor (closer = stronger pull)
        const distanceFactor = Math.min(1, 100 / distance);
        
        // Calculate direction vector to target
        const direction = {
            x: targetPosition.x - currentAimPosition.x,
            y: targetPosition.y - currentAimPosition.y,
            z: targetPosition.z - currentAimPosition.z
        };
        
        // Apply magnetic pull
        return {
            x: currentAimPosition.x + (direction.x * lockStrength * distanceFactor),
            y: currentAimPosition.y + (direction.y * lockStrength * distanceFactor),
            z: currentAimPosition.z + (direction.z * lockStrength * distanceFactor * 0.5)
        };
    }

    getWeaponProfiles() {
        return {
            default: {
                bulletVelocity: 400,
                verticalOffset: 0.05,
                humanizerIntensity: 0.15,
                magnetism: 1.8
            },
            sniper: {
                bulletVelocity: 1200,
                verticalOffset: -0.02,
                humanizerIntensity: 0.05,
                magnetism: 2.8
            },
            ar: {
                bulletVelocity: 800,
                verticalOffset: 0.03,
                humanizerIntensity: 0.1,
                magnetism: 2.0
            },
            smg: {
                bulletVelocity: 500,
                verticalOffset: 0.07,
                humanizerIntensity: 0.2,
                magnetism: 1.5
            },
            shotgun: {
                bulletVelocity: 350,
                verticalOffset: 0.1,
                humanizerIntensity: 0.25,
                magnetism: 3.0
            }
        };
    }

    getSystemMetadata() {
        return {
            version: "7.0",
            mode: this.currentMode,
            lockStrength: this.currentMode.lockStrength,
            predictionAlgorithm: "neural_network_v5",
            security: {
                token: this.securityToken,
                checksum: this.generateChecksum(),
                behaviorProfile: this.getBehaviorProfile()
            },
            performance: {
                maxCpu: this.currentMode.cpuLimit,
                updateInterval: 20 // ms
            },
            status: {
                targetLocked: !!this.lockedTargetId,
                lockStability: this.calculateLockStability()
            }
        };
    }

    calculateLockStability() {
        if (this.aimPositionHistory.length < 2) return 1.0;
        
        const positions = this.aimPositionHistory.slice(-10);
        let totalDistance = 0;
        
        for (let i = 1; i < positions.length; i++) {
            totalDistance += this.calculateDistance(
                positions[i-1].position, 
                positions[i].position
            );
        }
        
        // Lower distance = more stable
        const avgDistance = totalDistance / (positions.length - 1);
        return Math.max(0, 1 - (avgDistance * 10));
    }

    generateChecksum() {
        const crypto = require('crypto');
        const data = this.securityToken + this.currentMode.lockStrength;
        return crypto.createHash('sha512').update(data).digest('hex');
    }

    getBehaviorProfile() {
        const profiles = ["stealth", "precision", "aggressive", "sniper"];
        return profiles[Math.floor(Math.random() * profiles.length)];
    }
}

const aimSystem = new MagneticAimSystem();
$done({ body: aimSystem.process($response.body) });
