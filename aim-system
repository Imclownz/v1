// PERFECTLOCK HEADSHOT MASTER v11.0 (Free Fire Headshot Engine)
class PerfectLockHeadshotMaster {
    constructor() {
        this.lockStrength = 0.9999;
        this.targetHistory = new Map();
        this.sessionToken = `FFHS_${Date.now().toString(36)}`;
        this.weaponProfiles = this.getFreeFireWeaponProfiles();
        this.lastLockTime = 0;
        this.aimPredictionLevel = 8;
        this.aimStabilizer = 0.995;
        this.overshootGuard = 0.88; // Giảm 12% overshoot
        this.stickyFactor = 0.97; // Tăng độ dính
        this.freeFireHitbox = {
            headRadius: 0.35,  // Hitbox đầu Free Fire nhỏ hơn các game khác 
            neckOffset: 0.22   // Vùng chuyển tiếp cổ-đầu dễ headshot nhất 
        };
        this.freeFirePhysics = {
            gravity: 9.8,
            bulletVelocity: 400,
            headMovementFactor: 1.28 // Giảm hệ số dự đoán so với trước
        };
    }

    process(body) {
        try {
            const startTime = performance.now();
            const data = JSON.parse(body);
            
            if (data.targets?.length > 0) {
                const enhancedTargets = this.applyFreeFireTargetFilter(data.targets);
                const lockedTarget = this.selectFreeFirePriorityTarget(enhancedTargets);
                
                if (lockedTarget) {
                    // Tính toán điểm bắn tối ưu cho Free Fire
                    const perfectAim = this.calculateFreeFireHeadshot(
                        lockedTarget, 
                        data.playerPosition,
                        data.currentWeapon
                    );
                    
                    // Áp dụng cơ chế bám đầu đặc biệt
                    data.aimPosition = this.applyFreeFireStickyLock(
                        perfectAim, 
                        data.currentAimPosition, 
                        lockedTarget
                    );
                    
                    // Tự động bắn khi khóa chắc
                    if (this.lockStrength > 0.99) {
                        data.autoFire = true;
                        data.fireMode = "headshot_burst";
                    }
                    
                    // Ghi nhận lịch sử mục tiêu
                    this.updateTargetHistory(lockedTarget.id, perfectAim);
                }
                
                data.aimData = {
                    targets: enhancedTargets,
                    lockedTarget,
                    lockStrength: this.lockStrength,
                    predictionLevel: this.aimPredictionLevel,
                    processingTime: performance.now() - startTime
                };
            }
            
            // Cập nhật trạng thái
            if (data.gameState) this.updateCombatState(data.gameState);
            
            data.aimSystem = {
                version: "11.0",
                mode: "freefire_headshot",
                security: {
                    token: this.sessionToken,
                    checksum: this.generateChecksum()
                },
                overshootGuard: this.overshootGuard // Hiển thị trạng thái bảo vệ
            };
            
            return JSON.stringify(data);
        } catch (e) {
            console.error("[HEADSHOT MASTER] FreeFire Error:", e.message.substring(0,25));
            return body;
        }
    }

    // CƠ CHẾ BÁM ĐẦU ĐẶC BIỆT CHO FREE FIRE
    applyFreeFireStickyLock(targetPosition, currentPosition, target) {
        const direction = {
            x: targetPosition.x - currentPosition.x,
            y: targetPosition.y - currentPosition.y,
            z: targetPosition.z - currentPosition.z
        };
        
        const distance = Math.max(1, target.distance);
        const distanceFactor = Math.min(1.15, 120 / distance);
        const speedFactor = 1.1 - (Math.hypot(target.movement.x, target.movement.y) * 0.02);
        
        // Tính toán vị trí cuối cùng với độ dính cao
        let finalPosition = {
            x: currentPosition.x + (direction.x * distanceFactor * speedFactor * this.stickyFactor * this.overshootGuard),
            y: currentPosition.y + (direction.y * distanceFactor * speedFactor * this.stickyFactor * this.aimStabilizer * this.overshootGuard),
            z: currentPosition.z + (direction.z * distanceFactor * speedFactor * this.stickyFactor * 0.96 * this.overshootGuard)
        };
        
        // Giới hạn không vượt quá hitbox đầu (sử dụng headRadius)
        const headBoundaryX = target.headHitbox.x * 1.03;
        const headBoundaryY = target.headHitbox.y * 1.03;
        const headBoundaryZ = target.headHitbox.z * 1.03;
        
        finalPosition.x = Math.min(headBoundaryX, Math.max(target.headHitbox.x * 0.97, finalPosition.x));
        finalPosition.y = Math.min(headBoundaryY, Math.max(target.headHitbox.y * 0.97, finalPosition.y));
        finalPosition.z = Math.min(headBoundaryZ, Math.max(target.headHitbox.z * 0.97, finalPosition.z));
        
        return finalPosition;
    }

    // TÍNH TOÁN HEADSHOT CHUẨN FREE FIRE
    calculateFreeFireHeadshot(target, playerPosition, weaponType) {
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        const distance = Math.max(1, target.distance);
        const travelTime = distance / weaponProfile.bulletVelocity;
        
        // Dự đoán vị trí đầu với độ chính xác cao
        const predictedPosition = {
            x: target.headHitbox.x + (target.movement.x * travelTime * this.freeFirePhysics.headMovementFactor),
            // Ưu tiên bắn cổ (neckOffset) thay vì đầu
            y: target.headHitbox.y + this.freeFireHitbox.neckOffset + (target.movement.y * travelTime * this.freeFirePhysics.headMovementFactor),
            z: target.headHitbox.z + (target.movement.z * travelTime * this.freeFirePhysics.headMovementFactor)
        };
        
        // Hiệu chỉnh trọng lực Free Fire
        const gravityOffset = 0.5 * this.freeFirePhysics.gravity * travelTime * travelTime;
        predictedPosition.y -= gravityOffset * 0.85;
        
        // Hiệu chỉnh cho hitbox thực tế (thêm ngẫu nhiên trong phạm vi hitbox)
        const hitboxCorrection = {
            x: (Math.random() * 0.05) - 0.025,
            y: target.isCrouching ? 0.15 : (target.isJumping ? -0.1 : -0.08)
        };
        
        // Áp dụng hiệu chỉnh
        return {
            x: predictedPosition.x + hitboxCorrection.x,
            y: predictedPosition.y + hitboxCorrection.y,
            z: predictedPosition.z
        };
    }

    // LỌC MỤC TIÊU THEO CƠ CHẾ FREE FIRE
    applyFreeFireTargetFilter(targets) {
        return targets
            .filter(target => target.health > 0 && target.isVisible)
            .sort((a, b) => {
                // Ưu tiên: khoảng cách gần + kích thước đầu lớn + ít di chuyển
                const aPriority = (100 - a.distance) + (a.headHitboxSize * 50) - (a.movementSpeed * 10);
                const bPriority = (100 - b.distance) + (b.headHitboxSize * 50) - (b.movementSpeed * 10);
                return bPriority - aPriority;
            });
    }

    // CẬP NHẬT TRẠNG THÁI CHIẾN ĐẤU
    updateCombatState(gameState) {
        if (gameState.isInCombat) {
            this.lockStrength = Math.min(0.9999, 0.995 + (gameState.combatIntensity * 0.004));
            this.aimPredictionLevel = 9; // Tăng độ chính xác khi giao chiến
        } else {
            this.lockStrength = Math.max(0.985, this.lockStrength - 0.001);
        }
        
        if (gameState.playerHealth < 30) {
            this.lockStrength = 0.9995;
            this.overshootGuard = 0.92; // Tăng bảo vệ khi máu thấp
        }
    }

    // CẬP NHẬT LỊCH SỬ MỤC TIÊU (dùng cho bộ lọc rung tâm)
    updateTargetHistory(targetId, position) {
        if (!this.targetHistory.has(targetId)) {
            this.targetHistory.set(targetId, []);
        }
        
        const history = this.targetHistory.get(targetId);
        history.push({position, timestamp: performance.now()});
        
        // Giới hạn lịch sử
        if (history.length > 10) history.shift();
    }

    // BỘ LỌC RUNG TÂM (Áp dụng khi địch di chuyển nhanh) 
    applyJitterFilter(target) {
        const history = this.targetHistory.get(target.id);
        if (!history || history.length < 3) return target.position;
        
        // Kalman Filter giảm nhiễu chuyển động
        let filteredX = 0, filteredY = 0;
        history.forEach((pos, index) => {
            const weight = 0.6 - (0.1 * index); // Giảm dần trọng số theo thời gian
            filteredX += pos.position.x * weight;
            filteredY += pos.position.y * weight;
        });
        return { 
            x: filteredX / history.length, 
            y: filteredY / history.length 
        };
    }

    getFreeFireWeaponProfiles() {
        return {
            default: {bulletVelocity: 380, stability: 0.95},
            sniper: {bulletVelocity: 950, stability: 0.99},
            ak47: {bulletVelocity: 360, stability: 0.92},
            m4a1: {bulletVelocity: 400, stability: 0.94},
            shotgun: {bulletVelocity: 300, stability: 0.85}
        };
    }

    generateChecksum() {
        const crypto = require('crypto');
        return crypto.createHash('sha256').update(this.sessionToken).digest('hex').substring(0,16);
    }
}

const aimSystem = new PerfectLockHeadshotMaster();
$done({ body: aimSystem.process($response.body) });
