// PERFECTLOCK HEADSHOT MASTER v9.0 (Bullet Stabilization)
class PerfectLockHeadshotMaster {
    constructor() {
        this.lockStrength = 0.9999;
        this.targetHistory = new Map();
        this.sessionToken = `HS_ULTRA_${Date.now().toString(36)}`;
        this.weaponProfiles = this.getPrecisionWeaponProfiles();
        this.ballisticSystem = new AdvancedBallisticSystem();
        this.lastLockTime = 0;
        this.aimPredictionLevel = 7;
        this.aimStabilizer = 0.995;
        this.headshotAccuracy = 0.99;
        this.maxHistory = 10;
        this.overshootProtection = 1.0;
        this.stickyHeadLock = true;
        this.bulletStabilization = true;
        this.headLockPro = true;
        this.performanceProfile = "ultra";
    }

    process(body) {
        try {
            const startTime = Date.now();
            const data = JSON.parse(body);
            this.updatePerformanceMode(data.performanceState);
            
            if (data.gameState) this.updateCombatState(data.gameState);
            
            if (data.targets?.length > 0) {
                const enhancedTargets = this.enhanceTargets(data.targets, data.playerPosition, data.currentWeapon);
                const lockedTarget = this.selectOptimalTarget(enhancedTargets);
                
                if (lockedTarget) {
                    // Tính toán điểm bắn chính xác với công nghệ Head Lock Pro
                    const perfectAim = this.calculatePrecisionAim(lockedTarget, data.playerPosition, data.currentWeapon);
                    
                    // Áp dụng khóa đầu địch với cơ chế chống vượt quá
                    data.aimPosition = this.applyHeadLockPro(
                        perfectAim, 
                        data.currentAimPosition, 
                        lockedTarget,
                        data.gameState?.isFiring
                    );
                    
                    // Ổn định đường đạn cho tất cả viên đạn
                    if (this.bulletStabilization) {
                        data.bulletTrajectory = this.calculateStabilizedTrajectory(
                            data.playerPosition,
                            data.aimPosition,
                            lockedTarget,
                            data.currentWeapon
                        );
                    }
                    
                    // Tăng cường ổn định khi khóa mục tiêu
                    if (this.lockStrength > 0.99 && data.recoilSystem?.crosshairStabilization) {
                        const stabilizationBoost = 3.0 - (lockedTarget.distance * 0.0005);
                        data.aimPosition = {
                            x: data.aimPosition.x * data.recoilSystem.crosshairStabilization.x * stabilizationBoost,
                            y: data.aimPosition.y * data.recoilSystem.crosshairStabilization.y * stabilizationBoost,
                            z: data.aimPosition.z * data.recoilSystem.crosshairStabilization.z * (stabilizationBoost * 0.99)
                        };
                    }
                    
                    this.lastLockTime = Date.now();
                }
                
                data.aimData = {
                    targets: enhancedTargets,
                    lockedTarget,
                    lockStrength: this.lockStrength,
                    predictionLevel: this.aimPredictionLevel,
                    headshotRate: this.headshotAccuracy,
                    bulletStabilization: this.bulletStabilization,
                    processingTime: Date.now() - startTime
                };
            }
            
            data.aimSystem = this.getSystemMetadata();
            return JSON.stringify(data);
        } catch (e) {
            console.error("[HEADSHOT MASTER] Optimized Error:", e.message.substring(0, 30));
            return body;
        }
    }

    // CÔNG NGHỆ HEAD LOCK PRO - KHÓA CHẶT ĐẦU ĐỊCH KHÔNG VƯỢT QUÁ
    applyHeadLockPro(targetPosition, currentPosition, target, isFiring) {
        const direction = {
            x: targetPosition.x - currentPosition.x,
            y: targetPosition.y - currentPosition.y,
            z: targetPosition.z - currentPosition.z
        };
        
        const distance = Math.max(1, target.distance);
        const distanceFactor = Math.min(1.25, 150 / distance);
        const speedFactor = 1.15 - (Math.sqrt(target.movement.x**2 + target.movement.y**2) * 0.03);
        const stickyFactor = this.stickyHeadLock ? 0.95 : 0.88;
        
        // Hệ số bảo vệ không vượt quá đầu địch
        const overshootProtection = this.overshootProtection * (isFiring ? 0.92 : 0.98);
        
        // Tính toán vị trí cuối cùng với giới hạn không vượt quá
        let finalPosition = {
            x: currentPosition.x + (direction.x * distanceFactor * speedFactor * stickyFactor * overshootProtection),
            y: currentPosition.y + (direction.y * distanceFactor * speedFactor * stickyFactor * this.aimStabilizer * overshootProtection),
            z: currentPosition.z + (direction.z * distanceFactor * speedFactor * stickyFactor * 0.97 * overshootProtection)
        };
        
        // Đảm bảo không vượt quá vị trí đầu địch
        const maxMovement = {
            x: target.headHitbox.x * 1.05,
            y: target.headHitbox.y * 1.05,
            z: target.headHitbox.z * 1.05
        };
        
        // Áp dụng giới hạn tối đa
        finalPosition.x = Math.min(maxMovement.x, Math.max(target.headHitbox.x * 0.95, finalPosition.x));
        finalPosition.y = Math.min(maxMovement.y, Math.max(target.headHitbox.y * 0.95, finalPosition.y));
        finalPosition.z = Math.min(maxMovement.z, Math.max(target.headHitbox.z * 0.95, finalPosition.z));
        
        return finalPosition;
    }

    // CÔNG NGHỆ DỰ ĐOÁN CHUYỂN ĐỘNG THỜI GIAN THỰC
    neuralMovementPrediction(target) {
        const now = Date.now();
        let history = this.targetHistory.get(target.id);
        if (!history) {
            history = { 
                positions: [], 
                timestamps: [], 
                velocities: [],
                accelerations: [] 
            };
            this.targetHistory.set(target.id, history);
        }
        
        // Giới hạn lịch sử để tối ưu hiệu năng
        if (history.positions.length >= this.maxHistory) {
            history.positions.shift();
            history.timestamps.shift();
            history.velocities.shift();
            history.accelerations.shift();
        }
        
        // Lưu vị trí hiện tại
        history.positions.push({...target.position});
        history.timestamps.push(now);
        
        let predictedX = 0, predictedY = 0;
        const count = history.positions.length;
        
        if (count > 1) {
            // Tính toán vận tốc
            const latestVelocity = {
                x: (history.positions[count-1].x - history.positions[count-2].x) / 
                   ((history.timestamps[count-1] - history.timestamps[count-2]) || 1),
                y: (history.positions[count-1].y - history.positions[count-2].y) / 
                   ((history.timestamps[count-1] - history.timestamps[count-2]) || 1)
            };
            history.velocities.push(latestVelocity);
            
            // Tính toán gia tốc nếu có đủ dữ liệu
            if (count > 2) {
                const latestAcceleration = {
                    x: (history.velocities[history.velocities.length-1].x - 
                         history.velocities[history.velocities.length-2].x) /
                       ((history.timestamps[count-1] - history.timestamps[count-2]) || 1),
                    y: (history.velocities[history.velocities.length-1].y - 
                         history.velocities[history.velocities.length-2].y) /
                       ((history.timestamps[count-1] - history.timestamps[count-2]) || 1)
                };
                history.accelerations.push(latestAcceleration);
                
                // Dự đoán sử dụng gia tốc (ngoại suy bậc 2)
                const timeDiff = (now - history.timestamps[count-1]) / 1000;
                predictedX = history.positions[count-1].x + 
                            (latestVelocity.x * timeDiff) + 
                            (0.5 * latestAcceleration.x * timeDiff * timeDiff);
                
                predictedY = history.positions[count-1].y + 
                            (latestVelocity.y * timeDiff) + 
                            (0.5 * latestAcceleration.y * timeDiff * timeDiff);
            } else {
                // Dự đoán sử dụng vận tốc (ngoại suy bậc 1)
                const timeDiff = (now - history.timestamps[count-1]) / 1000;
                predictedX = history.positions[count-1].x + (latestVelocity.x * timeDiff);
                predictedY = history.positions[count-1].y + (latestVelocity.y * timeDiff);
            }
        }
        
        return {x: predictedX, y: predictedY, z: 0};
    }

    // CÔNG NGHỆ ỔN ĐỊNH ĐƯỜNG ĐẠN - BULLET STABILIZATION
    calculateStabilizedTrajectory(startPos, aimPos, target, weaponType) {
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        const travelTime = target.distance / weaponProfile.bulletVelocity;
        
        // Dự đoán vị trí chính xác khi đạn tới mục tiêu
        const predictedPosition = {
            x: target.position.x + (target.movement.x * travelTime * 1.3),
            y: target.position.y + (target.movement.y * travelTime * 1.3),
            z: target.position.z + (target.movement.z * travelTime * 1.3)
        };
        
        // Tính toán hiệu chỉnh đạn đạo
        const gravity = this.ballisticSystem.getGravity(weaponType);
        const drop = this.ballisticSystem.calculateAdvancedDrop(
            target.distance, 
            weaponProfile.bulletVelocity, 
            gravity,
            target.movement
        );
        
        // Hiệu chỉnh cho chuyển động đầu
        const headMovement = this.calculateHeadMovement(target, travelTime);
        
        return {
            start: startPos,
            end: {
                x: predictedPosition.x + headMovement.x,
                y: predictedPosition.y + target.headHeight + drop + headMovement.y,
                z: predictedPosition.z + headMovement.z
            },
            correction: {
                x: headMovement.x,
                y: drop + headMovement.y,
                z: headMovement.z
            },
            travelTime: travelTime,
            isStabilized: true,
            guaranteedHit: true
        };
    }

    // TÍNH TOÁN CHUYỂN ĐỘNG ĐẦU CHÍNH XÁC
    calculateHeadMovement(target, travelTime) {
        const headMovement = {
            x: target.movement.x * travelTime * 1.25,
            y: target.movement.y * travelTime * 1.25,
            z: target.movement.z * travelTime * 1.25
        };
        
        // Hiệu chỉnh cho các hành động đặc biệt (nhảy, cúi, nằm)
        if (target.isJumping) {
            headMovement.y += target.jumpHeight * 0.7;
        } else if (target.isCrouching) {
            headMovement.y -= target.height * 0.15;
        } else if (target.isProne) {
            headMovement.y -= target.height * 0.25;
        }
        
        return headMovement;
    }

    // TÍNH TOÁN ĐIỂM BẮN CHÍNH XÁC
    calculatePrecisionAim(target, playerPosition, weaponType) {
        let aimPosition = {
            x: target.headHitbox.x,
            y: target.headHitbox.y,
            z: target.headHitbox.z
        };
        
        // Tính toán thời gian đạn bay
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        const travelTime = target.distance / weaponProfile.bulletVelocity;
        
        // Hiệu chỉnh cho vũ khí tầm xa
        if (['sniper', 'dmr', 'ar'].includes(weaponType)) {
            const gravity = this.ballisticSystem.getGravity(weaponType);
            const drop = this.ballisticSystem.calculateAdvancedDrop(
                target.distance, 
                weaponProfile.bulletVelocity, 
                gravity,
                target.movement
            );
            aimPosition.y += drop;
        }
        
        // Hiệu chỉnh chuyển động đầu
        const headMovement = this.calculateHeadMovement(target, travelTime);
        aimPosition.x += headMovement.x;
        aimPosition.y += headMovement.y;
        aimPosition.z += headMovement.z;
        
        // Cập nhật hệ số bảo vệ không vượt quá
        this.overshootProtection = this.calculateOvershootProtection(target);
        
        return aimPosition;
    }

    // BẢO VỆ KHÔNG VƯỢT QUÁ ĐẦU ĐỊCH
    calculateOvershootProtection(target) {
        const history = this.targetHistory.get(target.id);
        if (!history || history.positions.length < 3) return 1.0;
        
        let overshootCount = 0;
        let totalSamples = 0;
        
        for (let i = 2; i < history.positions.length; i++) {
            const dx = history.positions[i].x - history.positions[i-1].x;
            const dy = history.positions[i].y - history.positions[i-1].y;
            const prevDx = history.positions[i-1].x - history.positions[i-2].x;
            const prevDy = history.positions[i-1].y - history.positions[i-2].y;
            
            const directionChange = Math.abs(Math.atan2(dy, dx) - Math.atan2(prevDy, prevDx));
            if (directionChange > 0.5) {
                overshootCount++;
            }
            
            totalSamples++;
        }
        
        const overshootRatio = totalSamples > 0 ? overshootCount / totalSamples : 0;
        return Math.max(0.8, 1.0 - (overshootRatio * 0.4));
    }

    updateCombatState(gameState) {
        const timeSinceCombat = Date.now() - this.lastLockTime;
        
        if (gameState.isInCombat || timeSinceCombat < 3000) {
            this.lockStrength = Math.min(0.9999, 0.995 + (gameState.combatIntensity * 0.005));
        } else {
            this.lockStrength = Math.max(0.985, this.lockStrength - 0.001);
        }
        
        if (gameState.isAiming) this.lockStrength = 0.998;
        if (gameState.playerHealth < 25) {
            this.lockStrength = 0.99995;
            this.headshotAccuracy = 0.995;
            this.stickyHeadLock = true;
            this.bulletStabilization = true;
            this.headLockPro = true;
        }
        
        this.aimStabilizer = 0.985 + (this.lockStrength * 0.01);
    }

    // ... Các phương thức khác giữ nguyên với cải tiến ...

}

class AdvancedBallisticSystem {
    getGravity(weaponType) {
        const gravities = {
            sniper: 9.78, dmr: 9.79, ar: 9.80, smg: 9.82, 
            shotgun: 9.83, ak47: 9.80, m4a1: 9.80, scar: 9.80
        };
        return gravities[weaponType] || 9.81;
    }

    calculateAdvancedDrop(distance, velocity, gravity, movement) {
        const time = distance / velocity;
        // Tính độ rơi chính xác với hiệu chỉnh chuyển động
        const baseDrop = 0.5 * gravity * Math.pow(time, 2);
        const movementCompensation = movement.y * time * 0.85;
        return baseDrop + movementCompensation;
    }
}

const aimSystem = new PerfectLockHeadshotMaster();
$done({ body: aimSystem.process($response.body) });
