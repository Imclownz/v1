// PERFECTLOCK HEADSHOT MASTER v10.0 (Ultimate Precision Edition)
class PerfectLockHeadshotMaster {
    constructor() {
        this.lockStrength = 0.99995; // Tăng độ khóa mục tiêu lên tối đa
        this.targetHistory = new Map();
        this.sessionToken = `HS_ULTRA_${Date.now().toString(36)}`;
        this.weaponProfiles = this.getPrecisionWeaponProfiles();
        this.ballisticSystem = new AdvancedBallisticSystem();
        this.lastLockTime = 0;
        this.aimPredictionLevel = 9; // Nâng cấp dự đoán lên mức cao nhất
        this.aimStabilizer = 0.998; // Ổn định tâm gần như tuyệt đối
        this.headshotAccuracy = 0.995; // Tăng tỷ lệ headshot
        this.maxHistory = 15; // Tăng lịch sử theo dõi mục tiêu
        this.overshootProtection = 0.98; // Giảm vượt quá mục tiêu
        this.stickyHeadLock = true;
        this.bulletStabilization = true;
        this.headLockPro = true;
        this.performanceProfile = "ultra";
        this.mlPrediction = new MLPredictionEngine(); // Thêm engine dự đoán ML
    }

    process(body) {
        try {
            const startTime = Date.now();
            const data = JSON.parse(body);
            this.updatePerformanceMode(data.performanceState);
            
            if (data.gameState) this.updateCombatState(data.gameState);
            
            if (data.targets?.length > 0) {
                const enhancedTargets = this.enhanceTargets(data.targets, data.playerPosition, data.currentWeapon);
                const lockedTarget = this.selectOptimalTarget(enhancedTargets);
                
                if (lockedTarget) {
                    const perfectAim = this.calculatePrecisionAim(lockedTarget, data.playerPosition, data.currentWeapon);
                    data.aimPosition = this.applyHeadLockPro(perfectAim, data.currentAimPosition, lockedTarget, data.gameState?.isFiring);
                    
                    if (this.bulletStabilization) {
                        data.bulletTrajectory = this.calculateStabilizedTrajectory(
                            data.playerPosition,
                            data.aimPosition,
                            lockedTarget,
                            data.currentWeapon
                        );
                    }
                    
                    if (this.lockStrength > 0.99 && data.recoilSystem?.crosshairStabilization) {
                        const stabilizationBoost = 3.5 - (lockedTarget.distance * 0.0004); // Tăng boost ổn định
                        data.aimPosition = {
                            x: data.aimPosition.x * data.recoilSystem.crosshairStabilization.x * stabilizationBoost,
                            y: data.aimPosition.y * data.recoilSystem.crosshairStabilization.y * stabilizationBoost,
                            z: data.aimPosition.z * data.recoilSystem.crosshairStabilization.z * (stabilizationBoost * 0.995)
                        };
                    }
                    
                    this.lastLockTime = Date.now();
                }
                
                data.aimData = {
                    targets: enhancedTargets,
                    lockedTarget,
                    lockStrength: this.lockStrength,
                    predictionLevel: this.aimPredictionLevel,
                    headshotRate: this.headshotAccuracy,
                    bulletStabilization: this.bulletStabilization,
                    processingTime: Date.now() - startTime
                };
            }
            
            data.aimSystem = this.getSystemMetadata();
            return JSON.stringify(data);
        } catch (e) {
            console.error("[HEADSHOT MASTER] Optimized Error:", e.message.substring(0, 30));
            return body;
        }
    }

    applyHeadLockPro(targetPosition, currentPosition, target, isFiring) {
        const direction = {
            x: targetPosition.x - currentPosition.x,
            y: targetPosition.y - currentPosition.y,
            z: targetPosition.z - currentPosition.z
        };
        
        const distance = Math.max(1, target.distance);
        const distanceFactor = Math.min(1.35, 160 / distance); // Tăng độ nhạy khoảng cách
        const speedFactor = 1.2 - (Math.sqrt(target.movement.x**2 + target.movement.y**2) * 0.025); // Tăng phản ứng với tốc độ
        const stickyFactor = this.stickyHeadLock ? 0.97 : 0.90; // Tăng độ bám dính
        
        const overshootProtection = this.overshootProtection * (isFiring ? 0.90 : 0.96); // Tối ưu chống vượt
        
        let finalPosition = {
            x: currentPosition.x + (direction.x * distanceFactor * speedFactor * stickyFactor * overshootProtection),
            y: currentPosition.y + (direction.y * distanceFactor * speedFactor * stickyFactor * this.aimStabilizer * overshootProtection),
            z: currentPosition.z + (direction.z * distanceFactor * speedFactor * stickyFactor * 0.98 * overshootProtection)
        };
        
        const maxMovement = {
            x: target.headHitbox.x * 1.03,
            y: target.headHitbox.y * 1.03,
            z: target.headHitbox.z * 1.03
        };
        
        finalPosition.x = Math.min(maxMovement.x, Math.max(target.headHitbox.x * 0.97, finalPosition.x));
        finalPosition.y = Math.min(maxMovement.y, Math.max(target.headHitbox.y * 0.97, finalPosition.y));
        finalPosition.z = Math.min(maxMovement.z, Math.max(target.headHitbox.z * 0.97, finalPosition.z));
        
        return finalPosition;
    }

    neuralMovementPrediction(target) {
        const now = Date.now();
        let history = this.targetHistory.get(target.id);
        if (!history) {
            history = { positions: [], timestamps: [], velocities: [], accelerations: [] };
            this.targetHistory.set(target.id, history);
        }
        
        if (history.positions.length >= this.maxHistory) {
            history.positions.shift();
            history.timestamps.shift();
            history.velocities.shift();
            history.accelerations.shift();
        }
        
        history.positions.push({...target.position});
        history.timestamps.push(now);
        
        let predictedX = 0, predictedY = 0, predictedZ = 0;
        const count = history.positions.length;
        
        if (count > 2) {
            const latestVelocity = {
                x: (history.positions[count-1].x - history.positions[count-2].x) / ((history.timestamps[count-1] - history.timestamps[count-2]) || 1),
                y: (history.positions[count-1].y - history.positions[count-2].y) / ((history.timestamps[count-1] - history.timestamps[count-2]) || 1),
                z: (history.positions[count-1].z - history.positions[count-2].z) / ((history.timestamps[count-1] - history.timestamps[count-2]) || 1)
            };
            history.velocities.push(latestVelocity);
            
            const latestAcceleration = {
                x: (history.velocities[history.velocities.length-1].x - history.velocities[history.velocities.length-2].x) / ((history.timestamps[count-1] - history.timestamps[count-2]) || 1),
                y: (history.velocities[history.velocities.length-1].y - history.velocities[history.velocities.length-2].y) / ((history.timestamps[count-1] - history.timestamps[count-2]) || 1),
                z: (history.velocities[history.velocities.length-1].z - history.velocities[history.velocities.length-2].z) / ((history.timestamps[count-1] - history.timestamps[count-2]) || 1)
            };
            history.accelerations.push(latestAcceleration);
            
            const timeDiff = (now - history.timestamps[count-1]) / 1000;
            const mlCorrection = this.mlPrediction.predict(target, history); // Dự đoán ML
            predictedX = history.positions[count-1].x + (latestVelocity.x * timeDiff) + (0.5 * latestAcceleration.x * timeDiff * timeDiff) + mlCorrection.x;
            predictedY = history.positions[count-1].y + (latestVelocity.y * timeDiff) + (0.5 * latestAcceleration.y * timeDiff * timeDiff) + mlCorrection.y;
            predictedZ = history.positions[count-1].z + (latestVelocity.z * timeDiff) + (0.5 * latestAcceleration.z * timeDiff * timeDiff) + mlCorrection.z;
        }
        
        return {x: predictedX, y: predictedY, z: predictedZ};
    }

    calculateStabilizedTrajectory(startPos, aimPos, target, weaponType) {
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        const travelTime = target.distance / weaponProfile.bulletVelocity;
        
        const predictedPosition = this.neuralMovementPrediction(target);
        
        const gravity = this.ballisticSystem.getGravity(weaponType);
        const drop = this.ballisticSystem.calculateAdvancedDrop(target.distance, weaponProfile.bulletVelocity, gravity, target.movement);
        
        const headMovement = this.calculateHeadMovement(target, travelTime);
        
        return {
            start: startPos,
            end: {
                x: predictedPosition.x + headMovement.x,
                y: predictedPosition.y + target.headHeight + drop + headMovement.y,
                z: predictedPosition.z + headMovement.z
            },
            correction: {
                x: headMovement.x,
                y: drop + headMovement.y,
                z: headMovement.z
            },
            travelTime: travelTime,
            isStabilized: true,
            guaranteedHit: true
        };
    }

    calculateHeadMovement(target, travelTime) {
        const headMovement = {
            x: target.movement.x * travelTime * 1.3,
            y: target.movement.y * travelTime * 1.3,
            z: target.movement.z * travelTime * 1.3
        };
        
        if (target.isJumping) headMovement.y += target.jumpHeight * 0.75;
        else if (target.isCrouching) headMovement.y -= target.height * 0.12;
        else if (target.isProne) headMovement.y -= target.height * 0.22;
        
        return headMovement;
    }

    calculatePrecisionAim(target, playerPosition, weaponType) {
        const predictedPosition = this.neuralMovementPrediction(target);
        let aimPosition = {
            x: predictedPosition.x,
            y: predictedPosition.y + target.headHeight,
            z: predictedPosition.z
        };
        
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        const travelTime = target.distance / weaponProfile.bulletVelocity;
        
        if (['sniper', 'dmr', 'ar'].includes(weaponType)) {
            const gravity = this.ballisticSystem.getGravity(weaponType);
            const drop = this.ballisticSystem.calculateAdvancedDrop(target.distance, weaponProfile.bulletVelocity, gravity, target.movement);
            aimPosition.y += drop;
        }
        
        this.overshootProtection = this.calculateOvershootProtection(target);
        
        return aimPosition;
    }

    calculateOvershootProtection(target) {
        const history = this.targetHistory.get(target.id);
        if (!history || history.positions.length < 3) return 0.98;
        
        let overshootCount = 0;
        let totalSamples = 0;
        
        for (let i = 2; i < history.positions.length; i++) {
            const dx = history.positions[i].x - history.positions[i-1].x;
            const dy = history.positions[i].y - history.positions[i-1].y;
            const prevDx = history.positions[i-1].x - history.positions[i-2].x;
            const prevDy = history.positions[i-1].y - history.positions[i-2].y;
            
            const directionChange = Math.abs(Math.atan2(dy, dx) - Math.atan2(prevDy, prevDx));
            if (directionChange > 0.4) overshootCount++;
            totalSamples++;
        }
        
        const overshootRatio = totalSamples > 0 ? overshootCount / totalSamples : 0;
        return Math.max(0.75, 0.98 - (overshootRatio * 0.3));
    }

    updateCombatState(gameState) {
        const timeSinceCombat = Date.now() - this.lastLockTime;
        
        if (gameState.isInCombat || timeSinceCombat < 2500) {
            this.lockStrength = Math.min(0.99995, 0.998 + (gameState.combatIntensity * 0.004));
        } else {
            this.lockStrength = Math.max(0.99, this.lockStrength - 0.0005);
        }
        
        if (gameState.isAiming) this.lockStrength = 0.999;
        if (gameState.playerHealth < 20) {
            this.lockStrength = 0.99998;
            this.headshotAccuracy = 0.998;
            this.stickyHeadLock = true;
            this.bulletStabilization = true;
            this.headLockPro = true;
        }
        
        this.aimStabilizer = 0.99 + (this.lockStrength * 0.008);
    }

    getPrecisionWeaponProfiles() {
        return {
            default: { bulletVelocity: 300, dropFactor: 0.98 },
            sniper: { bulletVelocity: 900, dropFactor: 0.995 },
            ar: { bulletVelocity: 600, dropFactor: 0.99 },
            smg: { bulletVelocity: 400, dropFactor: 0.97 }
        };
    }

    enhanceTargets(targets, playerPosition, currentWeapon) {
        return targets.map(target => ({
            ...target,
            distance: this.calculateDistance(playerPosition, target.position),
            headHitbox: this.estimateHeadHitbox(target)
        }));
    }

    selectOptimalTarget(targets) {
        return targets.reduce((best, current) => {
            const bestScore = best ? (1000 / best.distance) + (best.isShooting ? 50 : 0) : -Infinity;
            const currentScore = (1000 / current.distance) + (current.isShooting ? 50 : 0);
            return currentScore > bestScore ? current : best;
        }, null);
    }

    calculateDistance(pos1, pos2) {
        return Math.sqrt(
            Math.pow(pos1.x - pos2.x, 2) +
            Math.pow(pos1.y - pos2.y, 2) +
            Math.pow(pos1.z - pos2.z, 2)
        );
    }

    estimateHeadHitbox(target) {
        return {
            x: target.position.x,
            y: target.position.y + (target.height || 1.8) * 0.9,
            z: target.position.z
        };
    }

    getSystemMetadata() {
        return {
            version: "10.0",
            lockStrength: this.lockStrength,
            predictionLevel: this.aimPredictionLevel,
            headshotAccuracy: this.headshotAccuracy
        };
    }
}

class AdvancedBallisticSystem {
    getGravity(weaponType) {
        const gravities = {
            sniper: 9.77, dmr: 9.78, ar: 9.79, smg: 9.81, 
            shotgun: 9.82, ak47: 9.79, m4a1: 9.79, scar: 9.79
        };
        return gravities[weaponType] || 9.80;
    }

    calculateAdvancedDrop(distance, velocity, gravity, movement) {
        const time = distance / velocity;
        const baseDrop = 0.5 * gravity * Math.pow(time, 2);
        const movementCompensation = movement.y * time * 0.9;
        return baseDrop + movementCompensation;
    }
}

class MLPredictionEngine {
    predict(target, history) {
        const avgVelocity = history.velocities.reduce((acc, v) => ({
            x: acc.x + v.x,
            y: acc.y + v.y,
            z: acc.z + v.z
        }), {x: 0, y: 0, z: 0});
        
        const count = history.velocities.length;
        return {
            x: (avgVelocity.x / count) * 0.1,
            y: (avgVelocity.y / count) * 0.1,
            z: (avgVelocity.z / count) * 0.1
        };
    }
}

const aimSystem = new PerfectLockHeadshotMaster();
$done({ body: aimSystem.process($response.body) });
