// ================== HEADSHOT MASTER v8.0 (OMEGA HEADSHOT SYSTEM) ==================
class OmegaHeadshotSystem {
    constructor() {
        // Hyper configuration
        this.lockStrength = 0.9999999;
        this.targetHistory = new Map();
        this.sessionToken = `HS_ULTRA_${Date.now().toString(36)}_${Math.random().toString(36).substr(2, 12)}`;
        this.weaponProfiles = this.getPrecisionWeaponProfiles();
        this.aimPredictionLevel = 30;
        this.aimStabilizer = 0.99999;
        this.headshotAccuracy = 0.99999;
        this.dynamicHeadExpansion = this.calculateDynamicExpansion();
        this.maxHistory = 150;
        this.lockedHeadPosition = null;
        this.lastTargetId = null;
        this.targetSwitchCooldown = 0;
        this.emergencyLockMode = false;
        this.instantLockEnabled = true;
        this.lockResponseTime = 0.008; // 8ms response time
        this.distanceBasedAimAssist = {
            close: { strength: 0.98, expansion: 1.5 },
            medium: { strength: 0.92, expansion: 2.0 },
            far: { strength: 0.85, expansion: 3.0 },
            extreme: { strength: 0.78, expansion: 4.0 }
        };
        
        // Enhanced modules
        this.targetDetector = new NeuralTargetDetector();
        this.autoAimSystem = new QuantumAimSystem();
        this.bulletTracker = new CurvedBulletTracker();
        this.targetPredictor = new AIPredictor();
        this.aimLockController = new AdaptiveLockController();
        this.recoilCompensator = new SmartRecoilSystem();
        this.performanceOptimizer = new AIPerformanceOptimizer();
        this.stealthModule = new GhostStealth();
        this.combatAnalyzer = new TacticalAnalyzer();
        this.triggerResponseSystem = new InstantTriggerSystem();
        this.headshotGuarantor = new HeadshotGod();
        this.movementAnalyzer = new AdvancedMovementAnalyzer();
        this.bulletBendingEngine = new BallisticCurveEngine();
        this.headPositionTracker = new HeadTrackingSystem();
        this.contextAnalyzer = new CombatContextProcessor();
        this.headshotGuaranteeSystem = new HeadshotGuaranteeSystem(); // NEW
        this.antiDodgeSystem = new AntiDodgeSystem(); // NEW
        this.headLockStabilizer = new HeadLockStabilizer(); // NEW
        this.dynamicPrioritySystem = new DynamicPrioritySystem(); // NEW
        this.targetDetector = new NeuralTargetDetector();
        this.autoAimSystem = new QuantumAimSystem();
        this.bulletTracker = new CurvedBulletTracker();
        this.targetPredictor = new AIPredictor();
        this.aimLockController = new AdaptiveLockController();
        this.recoilCompensator = new SmartRecoilSystem();
        this.performanceOptimizer = new AIPerformanceOptimizer();
        this.stealthModule = new GhostStealth();
        this.combatAnalyzer = new TacticalAnalyzer();
        this.triggerResponseSystem = new InstantTriggerSystem();
        this.headshotGuarantor = new HeadshotGod();
        this.movementAnalyzer = new AdvancedMovementAnalyzer();
        this.bulletBendingEngine = new BallisticCurveEngine();
        this.headPositionTracker = new HeadTrackingSystem();
        this.contextAnalyzer = new CombatContextProcessor();
        this.headshotGuaranteeSystem = new HeadshotGuaranteeSystem();
        this.antiDodgeSystem = new AntiDodgeSystem();
        this.headLockStabilizer = new HeadLockStabilizer();
        this.dynamicPrioritySystem = new DynamicPrioritySystem();
        this.environmentAdapter = new EnvironmentAdapter(); // NEW
    }

    process(body) {
        try {
            const startTime = Date.now();
            const data = JSON.parse(body);
			
			// Check if we should process this frame
            if (!this.performanceOptimizer.shouldProcessFrame()) {
                return body;
            }
            
            // Analyze combat context
            this.contextAnalyzer.processContext(data.gameState);
			
			// Apply environment adaptations
            this.environmentAdapter.adapt(data, this.contextAnalyzer.getEnvironment());
            
            // Optimize performance based on device
            this.performanceOptimizer.adaptiveAdjust(data.performanceState);
            
            // Analyze combat situation with tactical awareness
            this.combatAnalyzer.tacticalAnalyze(data.gameState);
            
            // Activate instant lock if fire button is pressed
            if (data.gameState?.isFiring && this.instantLockEnabled) {
                this.triggerResponseSystem.activateHyperLock();
                this.headLockStabilizer.activate();
            }
            
            // Detect enemies with neural network
            const detectedTargets = this.targetDetector.neuralDetect(data);
            data.targets = detectedTargets;
            
            if (detectedTargets.length > 0) {
                // Dynamic priority system
                const prioritizedTargets = this.dynamicPrioritySystem.analyzeTargets(
                    detectedTargets, 
                    data.gameState
                );
                
                // Select priority target with threat prediction
                const priorityTarget = this.selectPriorityTarget(prioritizedTargets, data.gameState);
                
                // Track head position with high precision
                this.headPositionTracker.trackHead(priorityTarget);
                
                // Apply quantum aiming
                if (priorityTarget) {
                    // Anti-dodge prediction
                    this.antiDodgeSystem.predictDodge(priorityTarget, data.gameState);
                    
                    const aimData = this.autoAimSystem.quantumAcquire(
                        priorityTarget, 
                        data.currentAimPosition,
                        data.playerPosition,
                        data.currentWeapon,
                        data.gameState,
                        this.triggerResponseSystem.isHyperLockActive()
                    );
                    
                    // Head lock stabilization
                    data.aimPosition = this.headLockStabilizer.stabilize(
                        aimData.position, 
                        data.currentAimPosition,
                        priorityTarget.headHitbox,
                        priorityTarget
                    );
                    
                    // Apply headshot lock
                    if (this.shouldLockTarget(aimData, data.gameState, priorityTarget)) {
                        data.autoFire = true;
                        data.fireMode = "quantum_headshot_lock";
                        
                        // Headshot guarantee system
                        const guaranteedHeadshot = this.headshotGuaranteeSystem.guaranteeHit(
                            data.playerPosition,
                            data.aimPosition,
                            priorityTarget,
                            data.currentWeapon
                        );
                        
                        // Calculate curved bullet trajectory
                        data.bulletTrajectory = this.bulletTracker.calculateCurvedTrajectory(
                            data.playerPosition,
                            guaranteedHeadshot.position,
                            priorityTarget,
                            data.currentWeapon,
                            data.gameState,
                            this.headshotGuarantor,
                            this.bulletBendingEngine
                        );
                        
                        // AI-powered movement prediction
                        if (this.aimLockController.isTargetMoving(priorityTarget)) {
                            const predictedHead = this.targetPredictor.predictHeadPosition(
                                priorityTarget,
                                data.bulletTrajectory.travelTime,
                                this.movementAnalyzer,
                                this.antiDodgeSystem
                            );
                            data.aimPosition = this.aimLockController.quantumAdjust(
                                data.aimPosition,
                                predictedHead,
                                priorityTarget
                            );
                        }
                    }
                    
                    // Smart recoil compensation
                    if (data.gameState?.isFiring) {
                        data.aimPosition = this.recoilCompensator.smartCompensate(
                            data.aimPosition,
                            data.currentWeapon,
                            data.gameState.recoilPattern,
                            priorityTarget.distance,
                            data.gameState.firingDuration
                        );
                    }
                    
                    this.lastLockTime = Date.now();
                }
                
                // Advanced stealth concealment
                this.stealthModule.ghostConceal(data, this.contextAnalyzer);
            }
            
            // Add system metadata
            data.aimSystem = this.getSystemMetadata(startTime);
            return JSON.stringify(data);
        } catch (e) {
            console.error("[OMEGA SYSTEM] Critical Error:", e.message);
            return body;
        }
    }
    
    calculateDynamicExpansion() {
        return {
            close: 1.5,
            medium: 2.0,
            far: 3.0,
            extreme: 4.0,
            sniper: 1.0
        };
    }
    
    shouldLockTarget(aimData, gameState, target) {
        // Always lock when hyper lock is active
        if (this.triggerResponseSystem.isHyperLockActive()) return true;
        
        // Lock when lock strength exceeds threshold
        if (aimData.lockStrength >= 0.995) return true;
        
        // Lock in high threat situations
        if (gameState.playerHealth < 30) return true;
        
        // Lock for priority targets
        if (target.priority >= 9) return true;
        
        // NEW: Lock when head is visible
        if (target.headVisibility > 0.8) return true;
        
        return false;
    }
    
    selectPriorityTarget(targets, gameState) {
        if (targets.length === 0) return null;
        
        // Calculate threat score with prediction
        let maxThreat = -1;
        let selectedTarget = null;
        const playerHealth = gameState.playerHealth || 100;
        const combatState = this.combatAnalyzer.getCombatState();
        
        for (const target of targets) {
            const threatScore = this.calculateThreatScore(target, playerHealth, combatState);
            if (threatScore > maxThreat) {
                maxThreat = threatScore;
                selectedTarget = target;
            }
        }
        
        // Apply tactical priority
        return this.applyTacticalPriority(selectedTarget, targets);
    }
    
    applyTacticalPriority(primaryTarget, allTargets) {
        // Check for immediate threats
        const immediateThreats = allTargets.filter(t => 
            t.distance < 10 && t.isAimingAtPlayer && t.headVisibility > 0.7
        );
        
        if (immediateThreats.length > 0) {
            return immediateThreats.reduce((mostDangerous, current) => 
                current.priority > mostDangerous.priority ? current : mostDangerous
            );
        }
        
        // Check for snipers
        const snipers = allTargets.filter(t => t.weaponType === 'sniper' && t.headVisibility > 0.6);
        if (snipers.length > 0) {
            return snipers.sort((a, b) => a.distance - b.distance)[0];
        }
        
        // NEW: Prioritize targets with exposed heads
        const exposedTargets = allTargets.filter(t => t.headVisibility > 0.8);
        if (exposedTargets.length > 0) {
            return exposedTargets.sort((a, b) => b.priority - a.priority)[0];
        }
        
        return primaryTarget;
    }
    
    calculateThreatScore(target, playerHealth, combatState) {
        let score = 0;
        
        // Distance factor with non-linear scaling
        const distanceFactor = 1 - Math.min(1, target.distance / 400);
        score += Math.pow(distanceFactor, 2) * 120;
        
        // Aiming at player
        if (target.isAimingAtPlayer) score += 95;
        
        // Low health target bonus
        if (target.health < 30) score += 75;
        
        // Weapon danger with multipliers
        const weaponDanger = {
            sniper: { close: 80, medium: 95, far: 100, extreme: 100 },
            shotgun: { close: 100, medium: 85, far: 40, extreme: 30 },
            rifle: { close: 85, medium: 90, far: 80, extreme: 75 },
            smg: { close: 95, medium: 75, far: 45, extreme: 35 },
            pistol: { close: 65, medium: 55, far: 35, extreme: 25 }
        };
        
        const range = target.distance < 20 ? 'close' : 
                     target.distance < 50 ? 'medium' : 
                     target.distance < 100 ? 'far' : 'extreme';
        
        const dangerProfile = weaponDanger[target.weaponType] || { close: 55, medium: 55, far: 55, extreme: 50 };
        score += dangerProfile[range];
        
        // Movement threat analysis
        score += this.movementAnalyzer.assessMovementThreat(target);
        
        // Head visibility bonus
        score += target.headVisibility * 40;
        
        // Critical player health multiplier
        if (playerHealth < 30) {
            score *= 1.8;
        }
        
        // Combat state multiplier
        if (combatState === "critical") {
            score *= 1.6;
        }
        
        return score;
    }
    
    getSystemMetadata(startTime) {
        return {
            version: "8.0",
            mode: "quantum_headshot_lock",
            features: {
                instantLock: this.instantLockEnabled,
                headshotExpansion: this.dynamicHeadExpansion,
                stealthMode: true,
                guaranteedHeadshot: true,
                bulletBending: true,
                neuralDetection: true,
                headLockStabilizer: true, // NEW
                antiDodgeSystem: true, // NEW
                headshotGuarantee: true // NEW
            },
            performance: {
                processingTime: Date.now() - startTime,
                fps: this.performanceOptimizer.currentFPS,
                aiLoad: this.performanceOptimizer.aiWorkload
            },
            lockStatus: {
                strength: this.lockStrength,
                targetId: this.lastTargetId,
                instantLockActive: this.triggerResponseSystem.isHyperLockActive(),
                distanceBasedAssist: this.aimLockController.currentDistanceProfile,
                headLockStability: this.headLockStabilizer.stabilityLevel // NEW
            }
        };
    }
    
    getPrecisionWeaponProfiles() {
        return {
            default: {
                bulletVelocity: 380,
                stability: 0.98,
                horizontalRecoil: 0.025,
                verticalRecoil: 0.05,
                aimAssistFactor: 1.05,
                headshotPriority: 9.7
            },
            sniper: {
                bulletVelocity: 980,
                stability: 0.997,
                horizontalRecoil: 0.004,
                verticalRecoil: 0.08,
                aimAssistFactor: 1.35,
                headshotPriority: 10
            },
            ak47: {
                bulletVelocity: 370,
                stability: 0.95,
                horizontalRecoil: 0.05,
                verticalRecoil: 0.10,
                aimAssistFactor: 1.0,
                headshotPriority: 9.2
            },
            m4a1: {
                bulletVelocity: 410,
                stability: 0.97,
                horizontalRecoil: 0.035,
                verticalRecoil: 0.068,
                aimAssistFactor: 1.18,
                headshotPriority: 9.8
            },
            shotgun: {
                bulletVelocity: 320,
                stability: 0.90,
                horizontalRecoil: 0.058,
                verticalRecoil: 0.11,
                aimAssistFactor: 0.95,
                headshotPriority: 8.7
            },
            awm: {
                bulletVelocity: 1020,
                stability: 0.998,
                horizontalRecoil: 0.0035,
                verticalRecoil: 0.078,
                aimAssistFactor: 1.38,
                headshotPriority: 10
            },
            groza: {
                bulletVelocity: 390,
                stability: 0.94,
                horizontalRecoil: 0.048,
                verticalRecoil: 0.107,
                aimAssistFactor: 1.08,
                headshotPriority: 9.4
            },
            mp40: {
                bulletVelocity: 350,
                stability: 0.92,
                horizontalRecoil: 0.042,
                verticalRecoil: 0.088,
                aimAssistFactor: 1.12,
                headshotPriority: 9.1
            }
        };
    }
}

// ================== NEW: HEADSHOT GUARANTEE SYSTEM ==================
class HeadshotGuaranteeSystem {
    constructor() {
        this.hitProbability = 0.9999;
        this.minHeadSize = 0.3;
        this.maxHeadSize = 0.5;
        this.distanceFactors = {
            close: 1.3,
            medium: 1.0,
            far: 0.9,
            extreme: 0.85
        };
        this.weaponAdjustments = {
            sniper: { vertical: 0.03, horizontal: 0 },
            shotgun: { vertical: -0.07, horizontal: 0 },
            rifle: { vertical: 0.01, horizontal: 0.01 },
            smg: { vertical: 0, horizontal: 0.02 },
            pistol: { vertical: 0.02, horizontal: 0 },
            default: { vertical: 0, horizontal: 0 }
        };
    }
    
    guaranteeHit(playerPos, aimPos, target, weaponType) {
        const headCenter = this.calculateHeadCenter(target.headHitbox);
        const distance = this.calculateDistance(playerPos, target.position);
        const range = this.getRangeCategory(distance);
        const sizeFactor = this.distanceFactors[range];
        const weaponAdj = this.weaponAdjustments[weaponType] || this.weaponAdjustments.default;
        
        // Calculate guaranteed hit position
        const guaranteedPos = {
            x: headCenter.x + weaponAdj.horizontal,
            y: headCenter.y + weaponAdj.vertical,
            z: headCenter.z
        };
        
        // Apply advanced movement compensation
        const predictionTime = this.calculatePredictionTime(distance, weaponType);
        guaranteedPos.x += target.velocity.x * predictionTime * 1.4;
        guaranteedPos.z += target.velocity.z * predictionTime * 1.4;
        
        // Apply random noise reduction
        const noiseReduction = Math.min(1, 1 - (distance / 200));
        guaranteedPos.x += (Math.random() * 2 - 1) * 0.02 * noiseReduction;
        guaranteedPos.y += (Math.random() * 2 - 1) * 0.015 * noiseReduction;
        
        // Special case for jumping targets
        if (target.isJumping) {
            guaranteedPos.y += 0.18 * target.jumpProgress;
        }
        
        // Special case for sliding targets
        if (target.isSliding) {
            guaranteedPos.y -= 0.25;
            guaranteedPos.x += target.velocity.x * 0.15;
            guaranteedPos.z += target.velocity.z * 0.15;
        }
        
        // Final position validation
        if (!this.isPointInHead(guaranteedPos, target.headHitbox)) {
            return this.nearestHeadPoint(guaranteedPos, target.headHitbox);
        }
        
        return {
            position: guaranteedPos,
            confidence: this.hitProbability * sizeFactor
        };
    }
    
    calculateHeadCenter(headHitbox) {
        // Use weighted center for better accuracy
        return {
            x: headHitbox.x,
            y: headHitbox.y + headHitbox.radius * 0.12, // Slightly above center
            z: headHitbox.z
        };
    }
    
    calculatePredictionTime(distance, weaponType) {
        // Base prediction based on distance
        let time = distance * 0.0015;
        
        // Weapon-specific adjustments
        if (weaponType === 'sniper') time *= 0.7;
        else if (weaponType === 'shotgun') time *= 1.2;
        
        return Math.min(0.25, time);
    }
    
    isPointInHead(point, headHitbox) {
        const distance = Math.sqrt(
            Math.pow(point.x - headHitbox.x, 2) +
            Math.pow(point.y - headHitbox.y, 2)
        );
        return distance <= headHitbox.radius * 1.05;
    }
    
    nearestHeadPoint(point, headHitbox) {
        const angle = Math.atan2(point.y - headHitbox.y, point.x - headHitbox.x);
        return {
            x: headHitbox.x + Math.cos(angle) * headHitbox.radius * 0.95,
            y: headHitbox.y + Math.sin(angle) * headHitbox.radius * 0.95,
            z: headHitbox.z
        };
    }
    
        // Apply weapon-specific adjustments
        if (weaponType === 'shotgun') {
            // Shotguns benefit from center mass targeting
            guaranteedPos.y -= 0.05;
        } else if (weaponType === 'sniper') {
            // Snipers require precise head center
            guaranteedPos.y += 0.02;
        }
        
        // Add movement compensation
        if (target.movementSpeed > 5) {
            guaranteedPos.x += target.velocity.x * 0.18;
            guaranteedPos.z += target.velocity.z * 0.18;
        }
        
        return {
            position: guaranteedPos,
            confidence: this.hitProbability * sizeFactor
        };
    }
    
    calculateHeadCenter(headHitbox) {
        return {
            x: headHitbox.x,
            y: headHitbox.y,
            z: headHitbox.z
        };
    }
    
    calculateDistance(pos1, pos2) {
        return Math.sqrt(
            Math.pow(pos1.x - pos2.x, 2) +
            Math.pow(pos1.y - pos2.y, 2) +
            Math.pow(pos1.z - pos2.z, 2)
        );
    }
    
    getRangeCategory(distance) {
        if (distance < 15) return 'close';
        if (distance < 50) return 'medium';
        if (distance < 120) return 'far';
        return 'extreme';
    }
}

// ================== NEW: ANTI DODGE SYSTEM ==================
class AntiDodgeSystem {
    constructor() {
        this.dodgePatterns = {
            strafe: { prediction: 0.90, reaction: 0.95, vector: { x: 1.0, z: 0 } },
            jump: { prediction: 0.80, reaction: 0.88, vector: { x: 0, y: 1.2, z: 0 } },
            crouch: { prediction: 0.93, reaction: 0.96, vector: { x: 0, y: -0.6, z: 0 } },
            slide: { prediction: 0.85, reaction: 0.90, vector: { x: 0.7, y: -0.4, z: 0.7 } },
            prone: { prediction: 0.92, reaction: 0.94, vector: { x: 0, y: -0.8, z: 0 } },
            roll: { prediction: 0.75, reaction: 0.82, vector: { x: 0.8, y: -0.3, z: 0.8 } }
        };
        this.dodgeHistory = new Map();
        this.dodgePrediction = null;
        this.lastDodgeTime = 0;
        this.predictionWindow = 350; // ms
    }
    
    predictDodge(target, gameState) {
        if (!target.isPlayerControlled) return;
        
        const history = this.getDodgeHistory(target.id);
        const now = Date.now();
        
        // Skip if recently predicted
        if (now - this.lastDodgeTime < 400) return;
        
        // Calculate dodge probability
        const dodgeProbability = this.calculateDodgeProbability(target, gameState);
        if (dodgeProbability < 0.68) return;
        
        // Predict dodge type based on history and situation
        const dodgeType = this.predictDodgeType(target, history, gameState);
        
        this.dodgePrediction = {
            type: dodgeType,
            probability: dodgeProbability,
            timestamp: now,
            vector: this.dodgePatterns[dodgeType].vector
        };
        
        this.lastDodgeTime = now;
        this.recordDodge(target.id, dodgeType);
    }
    
    calculateDodgeProbability(target, gameState) {
        let probability = 0;
        
        // Situation factors
        if (gameState.playerIsAimingAtTarget) probability += 0.45;
        if (gameState.playerIsShooting) probability += 0.55;
        if (target.health < 35) probability += 0.65;
        if (target.health < 60) probability += 0.35;
        
        // Behavior patterns
        if (target.isMovingErratically) probability += 0.45;
        if (target.recentDodges > 2) probability += 0.35;
        if (target.lastDodgeTime > Date.now() - 5000) probability += 0.25;
        
        // Environmental factors
        if (target.isNearCover) probability += 0.30;
        
        return Math.min(0.97, probability);
    }
    
    predictDodgeType(target, history, gameState) {
        // Analyze last 3 dodges
        if (history.types.length >= 3) {
            const lastThree = history.types.slice(-3);
            
            // Detect pattern: jump -> crouch -> slide
            if (lastThree[0] === 'jump' && 
                lastThree[1] === 'crouch' && 
                lastThree[2] === 'slide') {
                return 'roll';
            }
            
            // Detect double strafe pattern
            if (lastThree.filter(t => t === 'strafe').length >= 2) {
                return 'jump';
            }
        }
        
        // Situation-based prediction
        if (target.isCrouching) return 'prone';
        if (target.isSprinting && target.distance < 15) return 'slide';
        if (target.distance < 8) return 'crouch';
        if (target.distance > 50) return 'strafe';
        if (gameState.playerWeapon === 'shotgun') return 'jump';
        
        return 'strafe'; // Default prediction
    }
    
    applyDodgeCompensation(aimPosition, target) {
        if (!this.dodgePrediction || !target) return aimPosition;
        
        // Check if prediction is still valid
        if (Date.now() - this.dodgePrediction.timestamp > this.predictionWindow) {
            this.dodgePrediction = null;
            return aimPosition;
        }
        
        // Apply dodge vector
        return {
            x: aimPosition.x + this.dodgePrediction.vector.x,
            y: aimPosition.y + (this.dodgePrediction.vector.y || 0),
            z: aimPosition.z + this.dodgePrediction.vector.z
        };
    }
    
        // Predict dodge based on combat situation
        if (gameState.playerIsAimingAtTarget && target.health < 50) {
            const dodgeProbability = this.calculateDodgeProbability(target, gameState);
            
            if (dodgeProbability > 0.7) {
                const dodgeType = this.predictDodgeType(target, lastAction);
                this.dodgePrediction = {
                    type: dodgeType,
                    probability: dodgeProbability,
                    timestamp: Date.now()
                };
                return;
            }
        }
        
        this.dodgePrediction = null;
    }
    
    getDodgeHistory(targetId) {
        if (!this.dodgeHistory.has(targetId)) {
            this.dodgeHistory.set(targetId, {
                actions: [],
                timestamps: [],
                success: []
            });
        }
        return this.dodgeHistory.get(targetId);
    }
    
    calculateDodgeProbability(target, gameState) {
        let probability = 0;
        
        // Health-based dodge probability
        if (target.health < 30) probability += 0.6;
        else if (target.health < 60) probability += 0.4;
        
        // Player threat level
        if (gameState.playerIsAimingAtTarget) probability += 0.3;
        if (gameState.playerIsShooting) probability += 0.4;
        
        // Target behavior
        if (target.isMovingErratically) probability += 0.25;
        if (target.isInCover) probability -= 0.2;
        
        return Math.min(0.95, probability);
    }
    
    predictDodgeType(target, lastAction) {
        // Simple pattern: alternate between dodge types
        const dodgeTypes = Object.keys(this.dodgePatterns);
        
        if (!lastAction) {
            return dodgeTypes[Math.floor(Math.random() * dodgeTypes.length)];
        }
        
        const lastIndex = dodgeTypes.indexOf(lastAction);
        const nextIndex = (lastIndex + 1) % dodgeTypes.length;
        return dodgeTypes[nextIndex];
    }
    
    getCurrentDodgePrediction() {
        return this.dodgePrediction;
    }
}

// ================== NEW: HEAD LOCK STABILIZER ==================
class HeadLockStabilizer {
    constructor() {
        this.stabilityLevel = 0;
        this.maxStability = 1.0;
        this.activationTime = 0;
        this.stabilizationFactors = {
            close: 0.99,    // Higher stability at close range
            medium: 0.97,
            far: 0.95,
            extreme: 0.92
        };
        this.decayRate = 0.96; // Slower decay
        this.momentumFactor = 0.88;
    }
    
    activate() {
        this.stabilityLevel = this.maxStability;
        this.activationTime = Date.now();
    }
    
    stabilize(currentAim, previousAim, headHitbox, target) {
        if (this.stabilityLevel < 0.1) return currentAim;
        
        const headCenter = {
            x: headHitbox.x,
            y: headHitbox.y,
            z: headHitbox.z
        };
        
        // Calculate distance to head center
        const distanceToHead = Math.sqrt(
            Math.pow(currentAim.x - headCenter.x, 2) +
            Math.pow(currentAim.y - headCenter.y, 2)
        );
        
        // Calculate range category for stabilization factor
        const range = distanceToHead < 15 ? 'close' : 
                     distanceToHead < 40 ? 'medium' : 
                     distanceToHead < 90 ? 'far' : 'extreme';
        const stabilityFactor = this.stabilizationFactors[range];
        
        // Apply stabilization with momentum control
        const stabilizedAim = {
            x: this.lerp(previousAim.x, headCenter.x, stabilityFactor * this.stabilityLevel),
            y: this.lerp(previousAim.y, headCenter.y, stabilityFactor * this.stabilityLevel),
            z: this.lerp(previousAim.z, headCenter.z, 0.7 * this.stabilityLevel)
        };
        
        // Add micro-adjustments for moving targets
        if (target && target.velocity) {
            const momentumX = target.velocity.x * this.momentumFactor * this.stabilityLevel;
            const momentumZ = target.velocity.z * this.momentumFactor * this.stabilityLevel;
            
            stabilizedAim.x += momentumX;
            stabilizedAim.z += momentumZ;
            
            // Vertical adjustment for jumping/sliding
            if (target.isJumping) {
                stabilizedAim.y += 0.15 * this.stabilityLevel;
            } else if (target.isSliding) {
                stabilizedAim.y -= 0.12 * this.stabilityLevel;
            }
        }
        
        // Gradually reduce stability
        this.stabilityLevel *= this.decayRate;
        
        return stabilizedAim;
    }
    
    lerp(start, end, amt) {
        return (1 - amt) * start + amt * end;
    }
}

// ================== NEW: DYNAMIC PRIORITY SYSTEM ==================
class DynamicPrioritySystem {
    constructor() {
        this.threatWeights = {
            distance: 0.28,
            weapon: 0.25,
            health: 0.18,
            action: 0.15,
            position: 0.14
        };
        this.opportunityWeights = {
            headVisibility: 0.40,
            stability: 0.25,
            exposure: 0.20,
            health: 0.15
        };
        this.priorityThresholds = {
            critical: 85,
            high: 70,
            medium: 50
        };
    }
    
    analyzeTargets(targets, gameState) {
        // Calculate threat and opportunity scores
        targets.forEach(target => {
            target.threatScore = this.calculateThreatScore(target, gameState);
            target.opportunityScore = this.calculateOpportunityScore(target);
            target.priority = this.calculatePriority(target);
            
            // Apply critical situation modifiers
            if (gameState.playerHealth < 25) {
                target.priority += this.calculateCriticalBonus(target);
            }
        });
        
        // Sort by priority (descending) and apply threat proximity
        return targets.sort((a, b) => {
            // Critical threat proximity boost
            const aProximity = a.distance < 15 ? 25 : 0;
            const bProximity = b.distance < 15 ? 25 : 0;
            
            return (b.priority + bProximity) - (a.priority + aProximity);
        });
    }
    
    calculateThreatScore(target, gameState) {
        let score = 0;
        
        // Proximity threat (exponential scaling)
        if (target.distance < 10) score += 45;
        else if (target.distance < 20) score += 35;
        else if (target.distance < 35) score += 25;
        else if (target.distance < 50) score += 15;
        
        // Weapon danger
        const weaponScores = {
            sniper: 40,
            shotgun: 35,
            rifle: 30,
            smg: 25,
            pistol: 15,
            launcher: 20
        };
        score += weaponScores[target.weaponType] || 10;
        
        // Aggression factors
        if (target.isAimingAtPlayer) score += 30;
        if (target.isShooting) score += 35;
        if (target.isThrowingGrenade) score += 25;
        
        // Player-specific threat
        if (target.isFocusingPlayer) score += 20;
        
        return score * this.threatWeights.distance;
    }
    
    calculateOpportunityScore(target) {
        let score = 0;
        
        // Head visibility is most important
        score += target.headVisibility * 100;
        
        // Movement stability
        if (target.movementPattern === 'stationary') score += 35;
        else if (target.movementPattern === 'linear') score += 25;
        else if (target.movementPattern === 'predictable') score += 15;
        
        // Environmental exposure
        if (!target.isInCover) score += 40;
        if (target.isOnOpenGround) score += 25;
        
        // Health status (weaker targets are easier to kill)
        if (target.health < 30) score += 35;
        else if (target.health < 50) score += 20;
        
        return score * this.opportunityWeights.headVisibility;
    }
    
    calculatePriority(target) {
        // Weighted combination of threat and opportunity
        const threatComponent = target.threatScore * 0.65;
        const opportunityComponent = target.opportunityScore * 0.35;
        
        return Math.min(100, threatComponent + opportunityComponent);
    }
    
    calculateCriticalBonus(target) {
        // Extra priority when player health is critical
        let bonus = 0;
        
        if (target.isImmediateThreat) bonus += 35;
        if (target.distance < 15) bonus += 30;
        if (target.isShooting) bonus += 25;
        
        return bonus;
    }
}

// ================== NEURAL TARGET DETECTOR (UPGRADED) ==================
class NeuralTargetDetector {
    constructor() {
        this.detectionAlgorithms = {
            visual: new DeepVision(),
            radar: new QuantumRadar(),
            predictive: new AIPredictiveTargeting(),
            thermal: new ThermalSignatureDetection(),
            skeletal: new SkeletalTrackingSystem() // NEW
        };
        this.targetConfidenceThreshold = 0.97; // Increased
        this.minDetectionSize = 4; // Smaller
        this.expansionSystem = new HeadExpansionSystem();
        this.headFocusBoost = 1.3; // NEW
    }
    
    neuralDetect(gameData) {
        const targets = [];
        
        // Deep vision detection
        if (gameData.visualData) {
            const visualTargets = this.detectionAlgorithms.visual.deepProcess(gameData.visualData);
            targets.push(...visualTargets);
        }
        
        // Quantum radar detection
        if (gameData.radarData) {
            const radarTargets = this.detectionAlgorithms.radar.quantumScan(gameData.radarData);
            targets.push(...radarTargets);
        }
        
        // AI predictive targeting
        if (gameData.gameState) {
            const predictiveTargets = this.detectionAlgorithms.predictive.aiFindTargets(gameData);
            targets.push(...predictiveTargets);
        }
        
        // Thermal signature detection
        if (gameData.thermalData) {
            const thermalTargets = this.detectionAlgorithms.thermal.detectHeatSignatures(gameData.thermalData);
            targets.push(...thermalTargets);
        }
        
        // NEW: Skeletal tracking
        if (gameData.skeletalData) {
            const skeletalTargets = this.detectionAlgorithms.skeletal.trackBodies(gameData.skeletalData);
            targets.push(...skeletalTargets);
        }
        
        // Filter by confidence
        const filteredTargets = targets.filter(t => t.confidence >= this.targetConfidenceThreshold);
        
        // Merge duplicates with AI
        const mergedTargets = this.mergeTargetsAI(filteredTargets);
        
        // Enhance target data with head focus
        return mergedTargets.map(target => 
            this.enhanceTarget(target, gameData.playerPosition)
			
        // NEW: Skeletal tracking
        if (gameData.skeletalData) {
            const skeletalTargets = this.detectionAlgorithms.skeletal.trackBodies(gameData.skeletalData);
            targets.push(...skeletalTargets);
            
            // Enhanced head detection for skeletal targets
            skeletalTargets.forEach(target => {
                target.headHitbox = this.calculatePreciseHeadHitbox(target);
            });
        }
        
        // Filter by confidence with head visibility priority
        const filteredTargets = targets.filter(t => 
            t.confidence >= this.targetConfidenceThreshold &&
            t.headVisibility >= this.minHeadVisibility
        );
    }
    
    mergeTargetsAI(targets) {
        const merged = [];
        const positionTolerance = 0.5; // Tighter tolerance
        
        for (const target of targets) {
            let existing = null;
            let minDistance = Infinity;
            
            for (const mergedTarget of merged) {
                const distance = this.calculateDistance(
                    target.position, 
                    mergedTarget.position
                );
                
                if (distance < positionTolerance && distance < minDistance) {
                    existing = mergedTarget;
                    minDistance = distance;
                }
            }
            
            if (existing) {
                // AI-powered data fusion
                existing.confidence = Math.min(1, (existing.confidence + target.confidence) * 0.88);
                
                // Position fusion with velocity weighting
                const weight = target.confidence / (existing.confidence + target.confidence);
                existing.position = {
                    x: existing.position.x * (1-weight) + target.position.x * weight,
                    y: existing.position.y * (1-weight) + target.position.y * weight,
                    z: existing.position.z * (1-weight) + target.position.z * weight
                };
                
                // Head visibility fusion
                if (target.headVisibility) {
                    existing.headVisibility = Math.max(
                        existing.headVisibility || 0, 
                        target.headVisibility
                    );
                }
                
                // Merge additional properties with priority
                Object.keys(target).forEach(key => {
                    if (!existing[key] || key === 'priority') {
                        existing[key] = target[key];
                    }
                });
            } else {
                merged.push({...target});
            }
        }
        
        return merged;
    }
	
    calculatePreciseHeadHitbox(target) {
        const baseRadius = 0.36; // Slightly larger hitbox
        let expansionFactor = 1.0;
        
        // Distance-based expansion
        if (target.distance < 15) expansionFactor = 1.35;
        else if (target.distance < 40) expansionFactor = 1.75;
        else if (target.distance < 100) expansionFactor = 2.15;
        else expansionFactor = 2.65;
        
        // Movement-based expansion
        if (target.movementSpeed > 5) {
            expansionFactor *= 1 + (target.movementSpeed * 0.035);
        }
        
        // Visibility-based adjustment
        if (target.headVisibility < 0.7) {
            expansionFactor *= 1.15;
        }
        
        // Calculate head height with advanced stance detection
        const headHeight = this.calculateHeadHeight(target);
        
        return {
            x: target.position.x,
            y: target.position.y + headHeight,
            z: target.position.z,
            radius: baseRadius * expansionFactor,
            baseRadius: baseRadius,
            expansion: expansionFactor,
            visibility: target.headVisibility
        };
    }
    
    calculateHeadHeight(target) {
        let height = 1.68; // Standing height
        
        // Basic stances
        if (target.isCrouching) height = 1.25;
        if (target.isProne) height = 0.85;
        
        // Dynamic actions
        if (target.isJumping) {
            height += Math.min(0.75, target.jumpProgress * 1.55);
        }
        if (target.isVaulting) {
            height += 0.45 + (0.2 * target.vaultProgress);
        }
        if (target.isSliding) {
            height = 0.95 - (0.15 * target.slideProgress);
        }
        if (target.isClimbing) {
            height += 0.3;
        }
        
        // Weapon effects
        if (target.weaponType === 'sniper') {
            height -= 0.05; // Slightly more hunched
        }
        
        return height;
    }
    
    enhanceTarget(target, playerPosition) {
        // Calculate precise distance
        target.distance = this.calculateDistance(target.position, playerPosition);
        
        // Calculate head hitbox with dynamic expansion
        target.headHitbox = this.expansionSystem.calculateDynamicHeadHitbox(target);
		
        // Advanced head visibility calculation
        target.headVisibility = this.calculateHeadVisibility(target);
        
        // NEW: Calculate head visibility
        target.headVisibility = this.calculateHeadVisibility(target);
        
        // Calculate threat level with movement analysis
        target.priority = this.calculateThreatLevel(target);
        
        // Add movement prediction data
        target.movementPrediction = this.predictMovementPattern(target);
        
        return target;
    }
    
    calculateDistance(pos1, pos2) {
        return Math.sqrt(
            Math.pow(pos1.x - pos2.x, 2) +
            Math.pow(pos1.y - pos2.y, 2) +
            Math.pow(pos1.z - pos2.z, 2)
        );
    }
    
    calculateHeadVisibility(target) {
        if (!target.visibilityInfo) return 1.0;
        
        // Calculate head visibility based on obstructions
        let visibility = 1.0;
        
        if (target.visibilityInfo.headObstructed) {
            visibility -= 0.4;
        }
        
        if (target.visibilityInfo.bodyObstructed) {
            visibility -= 0.2;
        }
        
        // Environmental factors
        if (target.isInSmoke) {
            visibility -= 0.3;
        }
        
        return Math.max(0.1, visibility);
    }
    
    calculateThreatLevel(target) {
        let threat = 0;
        
        // Weapon danger with distance modifiers
        const weaponThreat = {
            sniper: { close: 8, medium: 9.5, far: 10, extreme: 9.8 },
            shotgun: { close: 10, medium: 8.5, far: 5, extreme: 3.5 },
            rifle: { close: 8.5, medium: 9.2, far: 8.8, extreme: 7.5 },
            smg: { close: 9.2, medium: 8.0, far: 6.5, extreme: 4.5 },
            pistol: { close: 6.5, medium: 5.5, far: 4.0, extreme: 2.5 }
        };
        
        const range = target.distance < 20 ? 'close' : 
                     target.distance < 50 ? 'medium' : 
                     target.distance < 120 ? 'far' : 'extreme';
        
        const threatProfile = weaponThreat[target.weaponType] || { close: 5.5, medium: 5.5, far: 5.0, extreme: 4.5 };
        threat += threatProfile[range];
        
        // Behavior danger
        if (target.isAimingAtPlayer) threat += 9.5;
        if (target.isShooting) threat += 8.5;
        
        // Proximity danger with exponential scaling
        if (target.distance < 15) threat += Math.pow(1.9, (20 - target.distance)/5);
        else if (target.distance < 40) threat += 7;
        
        // Head visibility impact
        threat *= target.headVisibility * 0.8 + 0.2;
        
        // Movement-based threat
        threat += this.assessMovementThreat(target);
        
        return Math.min(10, threat);
    }
    
    assessMovementThreat(target) {
        let threatBonus = 0;
        
        // High-speed movement
        if (target.movementSpeed > 8) threatBonus += 3.5;
        
        // Erratic movement patterns
        if (target.movementPattern === 'erratic') threatBonus += 4.5;
        
        // Flanking movement
        if (target.isFlanking) threatBonus += 6;
        
        return threatBonus;
    }
    
    predictMovementPattern(target) {
        // AI-powered movement prediction
        return {
            pattern: 'linear',
            confidence: 0.88,
            nextPosition: {
                x: target.position.x + target.velocity.x * 0.18,
                y: target.position.y + target.velocity.y * 0.18,
                z: target.position.z + target.velocity.z * 0.18
            }
        };
    }
	
    calculateHeadVisibility(target) {
        let visibility = 1.0;
        
        // Obstruction factors
        if (target.headObstructed) visibility *= 0.55;
        else if (target.bodyObstructed) visibility *= 0.8;
        
        // Environmental factors
        if (target.inSmoke) visibility *= 0.45;
        if (target.inDarkArea) visibility *= 0.7;
        if (target.inWater) visibility *= 0.8;
        
        // Stance factors
        if (target.isCrouching) visibility *= 0.92;
        if (target.isProne) visibility *= 0.65;
        if (target.isBehindCover) visibility *= 0.5;
        
        // Movement factors
        if (target.isMovingFast) visibility *= 0.85;
        
        return Math.max(0.15, visibility);
    }
}

// ================== HEAD EXPANSION SYSTEM (UPGRADED) ==================
class HeadExpansionSystem {
    constructor() {
        this.baseRadius = 0.38;
        this.stanceFactors = {
            standing: 1.0,
            crouching: 0.95,
            prone: 0.85,
            jumping: 1.15,
            sliding: 0.92,
            vaulting: 1.08
        };
        this.weaponFactors = {
            sniper: 0.92,
            shotgun: 1.05,
            rifle: 0.98,
            smg: 1.02,
            pistol: 1.0,
            default: 1.0
        };
        this.movementFactors = {
            stationary: 1.0,
            walking: 1.05,
            running: 1.12,
            sprinting: 1.18
        };
    }
    
    calculateDynamicHeadHitbox(target) {
        let expansionFactor = 1.0;
        
        // Distance-based expansion (closer targets get smaller hitbox)
        if (target.distance < 15) expansionFactor = 1.4;
        else if (target.distance < 40) expansionFactor = 1.8;
        else if (target.distance < 100) expansionFactor = 2.2;
        else expansionFactor = 2.8;
        
        // Stance-based adjustments
        expansionFactor *= this.getStanceFactor(target);
        
        // Weapon-specific adjustments
        expansionFactor *= this.getWeaponFactor(target);
        
        // Movement-based adjustments
        expansionFactor *= this.getMovementFactor(target);
        
        // Calculate head height with advanced stance detection
        const headHeight = this.calculateHeadHeight(target);
        
        return {
            x: target.position.x,
            y: target.position.y + headHeight,
            z: target.position.z,
            radius: this.baseRadius * expansionFactor,
            baseRadius: this.baseRadius,
            expansion: expansionFactor,
            visibility: target.headVisibility
        };
    }
    
    getStanceFactor(target) {
        if (target.isProne) return this.stanceFactors.prone;
        if (target.isCrouching) return this.stanceFactors.crouching;
        if (target.isJumping) return this.stanceFactors.jumping;
        if (target.isSliding) return this.stanceFactors.sliding;
        if (target.isVaulting) return this.stanceFactors.vaulting;
        return this.stanceFactors.standing;
    }
    
    getWeaponFactor(target) {
        return this.weaponFactors[target.weaponType] || this.weaponFactors.default;
    }
    
    getMovementFactor(target) {
        if (target.movementSpeed < 0.1) return this.movementFactors.stationary;
        if (target.movementSpeed < 3) return this.movementFactors.walking;
        if (target.movementSpeed < 6) return this.movementFactors.running;
        return this.movementFactors.sprinting;
    }
    
    calculateHeadHeight(target) {
        let height = 1.68; // Standing height
        
        // Basic stances
        if (target.isCrouching) height = 1.25;
        if (target.isProne) height = 0.85;
        
        // Dynamic actions
        if (target.isJumping) {
            height += Math.min(0.75, target.jumpProgress * 1.55);
        }
        if (target.isVaulting) {
            height += 0.45 + (0.2 * target.vaultProgress);
        }
        if (target.isSliding) {
            height = 0.95 - (0.15 * target.slideProgress);
        }
        if (target.isClimbing) {
            height += 0.3;
        }
        
        // Injury effects
        if (target.health < 30) height *= 0.98;
        
        return height;
    }
}

// ================== QUANTUM AIM SYSTEM (UPGRADED) ==================
class QuantumAimSystem {
    constructor() {
        this.lockSystem = new DistanceBasedLock();
        this.predictionEngine = new HeadPredictionEngine();
        this.aimSmoothing = 0.97;
        this.maxAimHeight = 1.88;
        this.hyperLockMode = false;
        this.headFocusFactor = 0.99;
        this.headLockAggressiveness = 1.3;
        this.lockTransitionSpeed = 0.25;
    }
    
    quantumAcquire(target, currentAimPos, playerPos, weaponType, gameState, hyperLock = false) {
        this.hyperLockMode = hyperLock;
        
        // Calculate perfect aim position with prediction
        const perfectAim = this.predictionEngine.calculatePerfectAim(
            target, 
            playerPos, 
            weaponType,
            gameState
        );
        
        // Move aim to target with distance-based parameters
        const newAimPos = this.lockSystem.moveToHead(
            currentAimPos, 
            perfectAim, 
            target,
            weaponType,
            this.hyperLockMode,
            this.headLockAggressiveness
        );
        
        // Apply aim smoothing
        const finalAimPos = this.applySmoothing(currentAimPos, newAimPos);
        
        // Calculate lock strength with head focus
        const lockStrength = this.calculateHeadFocus(finalAimPos, perfectAim, target);
        
        return {
            position: finalAimPos,
            lockStrength: lockStrength
        };
    }
    
    applySmoothing(currentPos, newPos) {
        return {
            x: currentPos.x + (newPos.x - currentPos.x) * this.lockTransitionSpeed,
            y: currentPos.y + (newPos.y - currentPos.y) * this.lockTransitionSpeed,
            z: currentPos.z + (newPos.z - currentPos.z) * this.lockTransitionSpeed * 0.9
        };
    }
    
    calculateHeadFocus(aimPos, targetPos, target) {
        const distance = Math.sqrt(
            Math.pow(aimPos.x - targetPos.x, 2) +
            Math.pow(aimPos.y - targetPos.y, 2)
        );
        
        const maxDistance = target.headHitbox.radius * 2.0;
        const focus = Math.max(0, 1 - (distance / maxDistance));
        
        // Apply head focus factor
        return Math.min(1, focus * this.headFocusFactor);
    }
}

// ================== DISTANCE BASED LOCK (UPGRADED) ==================
class DistanceBasedLock {
    constructor() {
        this.lockProfiles = {
            close: { 
                speed: 0.30, 
                smoothing: 0.92, 
                snapDistance: 1.0,
                headLockBoost: 1.4
            },
            medium: { 
                speed: 0.22, 
                smoothing: 0.96, 
                snapDistance: 1.8,
                headLockBoost: 1.2
            },
            far: { 
                speed: 0.15, 
                smoothing: 0.98, 
                snapDistance: 2.5,
                headLockBoost: 1.0
            },
            extreme: { 
                speed: 0.10, 
                smoothing: 0.99, 
                snapDistance: 3.5,
                headLockBoost: 0.8
            }
        };
        this.currentProfile = "medium";
        this.headLockBoost = 1.0;
    }
    
    moveToHead(currentPos, targetPos, target, weaponType, hyperLock = false, headLockAggressiveness = 1.0) {
        this.selectProfile(target.distance);
        const profile = this.lockProfiles[this.currentProfile];
        this.headLockBoost = headLockAggressiveness * profile.headLockBoost;
        
        // Calculate move speed with boosts
        let moveSpeed = profile.speed;
        if (hyperLock) moveSpeed *= 2.0;
        moveSpeed *= this.headLockBoost;
        
        // Weapon-based adjustments
        moveSpeed = this.applyWeaponAdjustments(moveSpeed, weaponType);
        
        // Direction vector
        const direction = {
            x: targetPos.x - currentPos.x,
            y: targetPos.y - currentPos.y,
            z: targetPos.z - currentPos.z
        };
        
        // Apply smoothing
        const newPos = {
            x: currentPos.x + direction.x * moveSpeed * profile.smoothing,
            y: currentPos.y + direction.y * moveSpeed * profile.smoothing,
            z: currentPos.z + direction.z * moveSpeed * profile.smoothing * 0.92
        };
        
        // Hyper lock snapping
        if (hyperLock) {
            const distance = Math.sqrt(
                Math.pow(newPos.x - targetPos.x, 2) +
                Math.pow(newPos.y - targetPos.y, 2)
            );
            
            if (distance < profile.snapDistance) {
                return {
                    x: target.headHitbox.x,
                    y: target.headHitbox.y,
                    z: target.headHitbox.z
                };
            }
        }
        
        return newPos;
    }
    
    applyWeaponAdjustments(speed, weaponType) {
        const adjustments = {
            sniper: 0.85,
            shotgun: 1.20,
            rifle: 1.05,
            smg: 1.10,
            pistol: 1.00,
            default: 1.0
        };
        
        return speed * (adjustments[weaponType] || adjustments.default);
    }
    
    selectProfile(distance) {
        if (distance < 10) this.currentProfile = "close";
        else if (distance < 40) this.currentProfile = "medium";
        else if (distance < 100) this.currentProfile = "far";
        else this.currentProfile = "extreme";
    }
    
    getCurrentProfile() {
        return this.currentProfile;
    }
}

// ================== HEAD PREDICTION ENGINE (UPGRADED) ==================
class HeadPredictionEngine {
    calculatePerfectAim(target, playerPos, weaponType, gameState) {
        const basePos = target.headHitbox;
        
        // Calculate bullet travel time
        const travelTime = this.calculateTravelTime(playerPos, basePos, weaponType);
        
        // Predict head movement
        const predictedMovement = this.predictHeadMovement(target, travelTime, gameState);
        
        return {
            x: basePos.x + predictedMovement.x,
            y: basePos.y + predictedMovement.y,
            z: basePos.z + predictedMovement.z
        };
    }
    
    calculateTravelTime(startPos, endPos, weaponType) {
        const distance = this.calculateDistance(startPos, endPos);
        const weaponProfile = this.getWeaponProfile(weaponType);
        return distance / weaponProfile.bulletVelocity;
    }
    
    calculateDistance(pos1, pos2) {
        return Math.sqrt(
            Math.pow(pos2.x - pos1.x, 2) +
            Math.pow(pos2.y - pos1.y, 2) +
            Math.pow(pos2.z - pos1.z, 2)
        );
    }
    
    predictHeadMovement(target, time, gameState) {
        // Base movement prediction
        const baseMovement = {
            x: target.velocity.x * time * 1.4,
            y: target.velocity.y * time * 1.4,
            z: target.velocity.z * time * 0.9
        };
        
        // Environmental factors
        if (gameState.mapType === 'urban') {
            baseMovement.x *= 0.9;
            baseMovement.z *= 0.92;
        } else if (gameState.mapType === 'open') {
            baseMovement.x *= 1.05;
            baseMovement.z *= 1.05;
        }
        
        // Gravity effect
        if (!target.isGrounded) {
            baseMovement.y -= 0.5 * 9.81 * time * time;
        }
        
        // Dodge prediction
        if (target.predictedDodge) {
            switch (target.predictedDodge.type) {
                case 'jump':
                    baseMovement.y += 1.85 * time;
                    break;
                case 'crouch':
                    baseMovement.y -= 0.65;
                    break;
                case 'slide':
                    baseMovement.y -= 0.45;
                    baseMovement.x += target.velocity.x * time * 0.6;
                    baseMovement.z += target.velocity.z * time * 0.6;
                    break;
                case 'roll':
                    baseMovement.y -= 0.35;
                    baseMovement.x += target.velocity.x * time * 0.8;
                    baseMovement.z += target.velocity.z * time * 0.8;
                    break;
            }
        }
        
        return baseMovement;
    }
    
    getWeaponProfile(weaponType) {
        const profiles = {
            default: { bulletVelocity: 380 },
            sniper: { bulletVelocity: 950 },
            ak47: { bulletVelocity: 360 },
            m4a1: { bulletVelocity: 400 },
            shotgun: { bulletVelocity: 300 },
            awm: { bulletVelocity: 1020 },
            groza: { bulletVelocity: 390 },
            mp40: { bulletVelocity: 340 }
        };
        return profiles[weaponType] || profiles.default;
    }
}

// ================== CURVED BULLET TRACKER (UPGRADED) ==================
class CurvedBulletTracker {
    calculateCurvedTrajectory(startPos, aimPos, target, weaponType, gameState, guarantor, bender) {
        // Calculate initial travel time
        const travelTime = this.calculateTravelTime(startPos, aimPos, weaponType);
        
        // Predict target position at impact
        const predictedPos = this.predictFuturePosition(target, travelTime);
        
        // Apply environmental effects
        const environmentAdjustedPos = this.applyEnvironmentEffects(predictedPos, gameState);
        
        // Get guaranteed hit position with bending
        const curvedHitPos = bender.calculateCurvedPath(
            startPos,
            environmentAdjustedPos,
            target,
            weaponType,
            gameState
        );
        
        // Final guarantee from Headshot God
        const finalHitPos = guarantor.guaranteeHeadshot(startPos, curvedHitPos, target, weaponType);
        
        return {
            start: startPos,
            end: finalHitPos,
            travelTime: travelTime,
            curved: true,
            bendAngle: bender.lastBendAngle,
            guaranteedHit: true
        };
    }
    
    calculateTravelTime(startPos, endPos, weaponType) {
        const distance = this.calculateDistance(startPos, endPos);
        const weaponProfile = this.getWeaponProfile(weaponType);
        return distance / weaponProfile.bulletVelocity;
    }
    
    calculateDistance(pos1, pos2) {
        return Math.sqrt(
            Math.pow(pos2.x - pos1.x, 2) +
            Math.pow(pos2.y - pos1.y, 2) +
            Math.pow(pos2.z - pos1.z, 2)
        );
    }
    
    predictFuturePosition(target, time) {
        // Enhanced prediction with acceleration
        const basePos = target.position;
        const nextPos = {
            x: basePos.x + target.velocity.x * time,
            y: basePos.y + target.velocity.y * time,
            z: basePos.z + target.velocity.z * time
        };
        
        // Apply acceleration if available
        if (target.acceleration) {
            nextPos.x += 0.5 * target.acceleration.x * time * time;
            nextPos.y += 0.5 * target.acceleration.y * time * time;
            nextPos.z += 0.5 * target.acceleration.z * time * time;
        }
        
        // Apply gravity
        if (!target.isGrounded) {
            nextPos.y -= 0.5 * 9.81 * time * time;
        }
        
        return nextPos;
    }
    
    applyEnvironmentEffects(position, gameState) {
        let adjustedPos = {...position};
        
        // Wind effect
        if (gameState.windSpeed > 0) {
            const windFactor = gameState.windSpeed * 0.001;
            adjustedPos.x += Math.cos(gameState.windDirection) * windFactor;
            adjustedPos.z += Math.sin(gameState.windDirection) * windFactor;
        }
        
        // Rain effect
        if (gameState.weather === 'rain') {
            adjustedPos.y -= 0.01 * gameState.rainIntensity;
        }
        
        return adjustedPos;
    }
    
    getWeaponProfile(weaponType) {
        const profiles = {
            default: { bulletVelocity: 380 },
            sniper: { bulletVelocity: 950 },
            ak47: { bulletVelocity: 360 },
            m4a1: { bulletVelocity: 400 },
            shotgun: { bulletVelocity: 300 },
            awm: { bulletVelocity: 1020 },
            groza: { bulletVelocity: 390 },
            mp40: { bulletVelocity: 340 }
        };
        return profiles[weaponType] || profiles.default;
    }
}

// ================== BALLISTIC CURVE ENGINE (UPGRADED) ==================
class BallisticCurveEngine {
    constructor() {
        this.maxBendAngle = 0.22; // radians
        this.bendFactor = 0.88;
        this.lastBendAngle = 0;
        this.distanceFactors = {
            close: 0.75,
            medium: 1.0,
            far: 1.3,
            extreme: 1.5
        };
        this.velocityCurve = {
            low: 0.8,
            medium: 1.0,
            high: 1.25
        };
    }
    
    calculateCurvedPath(startPos, targetPos, target, weaponType, gameState) {
        // Calculate necessary bend based on movement
        const velocityMagnitude = Math.sqrt(
            target.velocity.x * target.velocity.x +
            target.velocity.y * target.velocity.y +
            target.velocity.z * target.velocity.z
        );
        
        // Get velocity category
        const velocityCategory = velocityMagnitude < 5 ? 'low' : 
                                velocityMagnitude < 10 ? 'medium' : 'high';
        
        // Get distance factor
        const distFactor = this.distanceFactors[this.getRangeCategory(target.distance)];
        const velFactor = this.velocityCurve[velocityCategory];
        
        // Calculate bend angle based on velocity and distance
        const bendAngle = this.calculateBendAngle(velocityMagnitude, target.distance) * distFactor * velFactor;
        
        // Calculate direction vector
        const dx = targetPos.x - startPos.x;
        const dy = targetPos.y - startPos.y;
        const dz = targetPos.z - startPos.z;
        
        // Apply bending in movement direction with prediction
        const predictionTime = this.calculatePredictionTime(target.distance, weaponType);
        const predictedVelocity = {
            x: target.velocity.x * predictionTime,
            z: target.velocity.z * predictionTime
        };
        
        const bendX = bendAngle * predictedVelocity.x * this.bendFactor;
        const bendY = bendAngle * target.velocity.y * this.bendFactor * 0.6;
        
        // Apply environmental factors
        let environmentFactor = 1.0;
        if (gameState.mapType === 'windy') environmentFactor = 1.15;
        if (gameState.weather === 'rain') environmentFactor = 1.08;
        
        return {
            x: targetPos.x + bendX * environmentFactor,
            y: targetPos.y + bendY,
            z: targetPos.z + bendX * environmentFactor
        };
    }
    
    calculatePredictionTime(distance, weaponType) {
        // Base prediction based on distance
        let time = distance * 0.0018;
        
        // Weapon-specific adjustments
        const weaponSpeeds = {
            sniper: 0.6,
            awm: 0.55,
            shotgun: 1.3,
            rifle: 0.8,
            smg: 0.9,
            pistol: 1.1
        };
        
        time *= weaponSpeeds[weaponType] || 1.0;
        return Math.min(0.3, time);
    }
     
    calculateBendAngle(velocity, distance) {
        // Base angle based on velocity
        let angle = Math.min(this.maxBendAngle, velocity * 0.028); // Increased coefficient
        
        // Distance scaling
        if (distance > 100) angle *= 1.35;
        else if (distance > 50) angle *= 1.15;
        
        return angle;
    }
}

// ================== HEADSHOT GOD (UPGRADED) ==================
class HeadshotGod {
    constructor() {
        this.hitProbability = 0.9999;
        this.headCenterBias = 0.92;
        this.edgeSafetyMargin = 0.15;
        this.velocityPredictionFactor = 1.35;
        this.gravityCompensation = 0.5;
    }

    guaranteeHeadshot(startPos, predictedPos, target, weaponType) {
        const head = target.headHitbox;
        
        // Apply weapon-specific adjustments
        const adjustedPos = this.applyWeaponAdjustments(predictedPos, head, weaponType, target);
        
        // Apply velocity prediction
        const velocityAdjustedPos = this.applyVelocityPrediction(adjustedPos, target);
        
        // Apply gravity compensation
        const gravityAdjustedPos = this.applyGravityCompensation(velocityAdjustedPos, startPos, target);
        
        // Final position validation
        if (!this.isPointInHead(gravityAdjustedPos, head)) {
            return this.nearestHeadPoint(gravityAdjustedPos, head);
        }
        
        return gravityAdjustedPos;
    }
    
    applyWeaponAdjustments(position, headHitbox, weaponType, target) {
        const adjustments = {
            sniper: { vertical: 0.03, horizontal: 0 },
            shotgun: { vertical: -0.07, horizontal: 0 },
            rifle: { vertical: 0.01, horizontal: 0.01 },
            smg: { vertical: 0, horizontal: 0.02 },
            pistol: { vertical: 0.02, horizontal: 0 },
            default: { vertical: 0, horizontal: 0 }
        };
        
        const adj = adjustments[weaponType] || adjustments.default;
        
        return {
            x: position.x + adj.horizontal,
            y: position.y + adj.vertical,
            z: position.z
        };
    }
    
    applyVelocityPrediction(position, target) {
        if (target.movementSpeed > 0.5) {
            const predictionTime = this.calculatePredictionTime(target.distance, target.weaponType);
            return {
                x: position.x + target.velocity.x * predictionTime * this.velocityPredictionFactor,
                y: position.y + target.velocity.y * predictionTime * 0.8,
                z: position.z + target.velocity.z * predictionTime * this.velocityPredictionFactor
            };
        }
        return position;
    }
    
    applyGravityCompensation(position, startPos, target) {
        if (!target.isGrounded) {
            const distance = Math.sqrt(
                Math.pow(position.x - startPos.x, 2) +
                Math.pow(position.y - startPos.y, 2) +
                Math.pow(position.z - startPos.z, 2)
            );
            const time = distance / 400; // Approximate time to target
            const gravityDrop = 0.5 * 9.81 * time * time * this.gravityCompensation;
            
            return {
                x: position.x,
                y: position.y + gravityDrop,
                z: position.z
            };
        }
        return position;
    }
    
    calculatePredictionTime(distance, weaponType) {
        // Base prediction based on distance
        let time = distance * 0.0018;
        
        // Weapon-specific adjustments
        if (weaponType === 'sniper') time *= 0.7;
        else if (weaponType === 'shotgun') time *= 1.2;
        
        return Math.min(0.25, time);
    }
    
    isPointInHead(point, head) {
        const distance = Math.sqrt(
            Math.pow(point.x - head.x, 2) +
            Math.pow(point.y - head.y, 2)
        );
        return distance <= head.radius * (1 - this.edgeSafetyMargin);
    }
    
    nearestHeadPoint(point, head) {
        const angle = Math.atan2(point.y - head.y, point.x - head.x);
        const radius = head.radius * this.headCenterBias;
        
        return {
            x: head.x + Math.cos(angle) * radius,
            y: head.y + Math.sin(angle) * radius,
            z: head.z
        };
    }
    
    calculateHitProbability(target, distance) {
        let probability = this.hitProbability;
        
        // Distance factors
        if (distance > 100) probability *= 0.97;
        if (distance > 150) probability *= 0.94;
        
        // Movement factors
        if (target.movementSpeed > 6) probability *= 0.96;
        if (target.movementPattern === 'erratic') probability *= 0.92;
        
        // Environmental factors
        if (target.inSmoke) probability *= 0.85;
        if (target.inDarkness) probability *= 0.90;
        
        return probability;
    }
}

// ================== INSTANT TRIGGER SYSTEM (UPGRADED) ==================
class InstantTriggerSystem {
    constructor() {
        this.hyperLockActive = false;
        this.activationTime = 0;
        this.lockDuration = 0.45; // 450ms lock duration
        this.cooldown = 85; // ms
        this.headLockBoost = 1.35;
        this.autoFireDelay = 100; // Delay before auto fire
    }
    
    activateHyperLock() {
        const now = Date.now();
        if (now - this.activationTime > this.cooldown) {
            this.hyperLockActive = true;
            this.activationTime = now;
            
            // Schedule auto fire if not already firing
            if (!this.isFiring) {
                setTimeout(() => {
                    if (this.hyperLockActive) {
                        this.triggerAutoFire();
                    }
                }, this.autoFireDelay);
            }
        }
    }
    
    triggerAutoFire() {
        // This would trigger the game's fire action
        // Implementation depends on game API
        // game.triggerFire();
    }
    
    isHyperLockActive() {
        if (this.hyperLockActive) {
            // Auto disable after duration
            if (Date.now() - this.activationTime > this.lockDuration * 1000) {
                this.hyperLockActive = false;
            }
            return true;
        }
        return false;
    }
    
    getHeadLockBoost() {
        return this.headLockBoost;
    }
    
    setFiringState(isFiring) {
        this.isFiring = isFiring;
    }
    
    getLockStatus() {
        return {
            active: this.hyperLockActive,
            duration: this.lockDuration,
            remaining: this.lockDuration - ((Date.now() - this.activationTime) / 1000)
        };
    }
}

// ================== AI PREDICTOR (UPGRADED) ==================
class AIPredictor {
    constructor() {
        this.predictionModels = {
            linear: new LinearPredictionModel(),
            erratic: new ErraticPredictionModel(),
            jumping: new JumpPredictionModel(),
            tactical: new TacticalMovementModel(),
            dodging: new DodgePredictionModel() // NEW
        };
        this.movementHistory = new Map();
        this.maxHistorySize = 35; // Increased
        this.predictionAccuracy = 0.98; // Increased
        this.behaviorDatabase = new BehaviorDatabase();
        this.dodgePredictor = new DodgePredictor(); // NEW
    }
    
    predictHeadPosition(target, timeAhead, movementAnalyzer, antiDodgeSystem) {
        // Get movement history
        const history = this.getMovementHistory(target.id);
        
        // Update with current position
        this.updateHistory(target, history);
        
        // Analyze movement pattern
        const patternType = movementAnalyzer.determineMovementPattern(target, history);
        
        // NEW: Check dodge prediction
        const dodgePrediction = antiDodgeSystem.getCurrentDodgePrediction();
        if (dodgePrediction) {
            target.predictedDodge = dodgePrediction;
            return this.predictionModels.dodging.predictHead(target, history, timeAhead);
        }
        
        // Select prediction model
        const predictionModel = this.predictionModels[patternType];
        
        // Generate prediction
        return predictionModel.predictHead(target, history, timeAhead);
    }
    
    getMovementHistory(targetId) {
        if (!this.movementHistory.has(targetId)) {
            this.movementHistory.set(targetId, {
                positions: [],
                timestamps: [],
                velocities: [],
                actions: []
            });
        }
        return this.movementHistory.get(targetId);
    }
    
    updateHistory(target, history) {
        const currentTime = Date.now();
        
        // Add current position
        history.positions.push({...target.position});
        history.timestamps.push(currentTime);
        history.actions.push(target.currentAction);
        
        // Calculate velocity if possible
        if (history.positions.length > 1) {
            const lastPos = history.positions[history.positions.length - 2];
            const currentPos = history.positions[history.positions.length - 1];
            const timeDiff = (history.timestamps[history.timestamps.length - 1] - 
                             history.timestamps[history.timestamps.length - 2]) / 1000;
            
            if (timeDiff > 0) {
                const velocity = {
                    x: (currentPos.x - lastPos.x) / timeDiff,
                    y: (currentPos.y - lastPos.y) / timeDiff,
                    z: (currentPos.z - lastPos.z) / timeDiff
                };
                history.velocities.push(velocity);
            }
        }
        
        // Limit history size
        if (history.positions.length > this.maxHistorySize) {
            history.positions.shift();
            history.timestamps.shift();
            history.actions.shift();
            if (history.velocities.length > 0) history.velocities.shift();
        }
    }
}

// ================== NEW: DODGE PREDICTION MODEL ==================
class DodgePredictionModel {
    predictHead(target, history, timeAhead) {
        // Predict head position during dodge
        if (!target.predictedDodge) {
            return new LinearPredictionModel().predictHead(target, history, timeAhead);
        }
        
        const basePos = target.headHitbox;
        let dodgeAdjustment = { x: 0, y: 0, z: 0 };
        
        switch (target.predictedDodge.type) {
            case 'jump':
                dodgeAdjustment.y = 1.2 * timeAhead;
                break;
            case 'crouch':
                dodgeAdjustment.y = -0.5;
                break;
            case 'slide':
                dodgeAdjustment.y = -0.3;
                dodgeAdjustment.x = target.velocity.x * timeAhead * 0.6;
                dodgeAdjustment.z = target.velocity.z * timeAhead * 0.6;
                break;
            case 'strafe':
                dodgeAdjustment.x = target.velocity.x * timeAhead * 1.2;
                dodgeAdjustment.z = target.velocity.z * timeAhead * 1.2;
                break;
        }
        
        return {
            x: basePos.x + dodgeAdjustment.x,
            y: basePos.y + dodgeAdjustment.y,
            z: basePos.z + dodgeAdjustment.z
        };
    }
}

// ================== ADVANCED MOVEMENT ANALYZER (UPGRADED) ==================
class AdvancedMovementAnalyzer {
    constructor() {
        this.movementPatternDatabase = new MovementPatternDatabase();
        this.threatAssessmentWeights = {
            speed: 0.25,
            directionChange: 0.35,
            erraticLevel: 0.30,
            environment: 0.10
        };
        this.predictionAccuracy = 0.95;
    }

    determineMovementPattern(target, history) {
        if (history.velocities.length < 8) return 'linear';
        
        // Calculate advanced movement metrics
        const metrics = this.calculateMovementMetrics(history);
        
        // Match against known patterns
        const matchedPattern = this.matchPattern(metrics);
        
        // Special state detection
        if (target.isJumping) return 'jumping';
        if (metrics.coverUsage > 0.7) return 'tactical';
        if (metrics.erraticScore > 6.5) return 'erratic';
        
        return matchedPattern || 'linear';
    }
    
    calculateMovementMetrics(history) {
        let directionChanges = 0;
        let speedChanges = 0;
        let speedSum = 0;
        let lastDirection = null;
        
        for (let i = 1; i < history.velocities.length; i++) {
            const prev = history.velocities[i-1];
            const curr = history.velocities[i];
            
            // Direction change detection
            const angleChange = Math.abs(
                Math.atan2(curr.y, curr.x) - Math.atan2(prev.y, prev.x)
            );
            if (angleChange > 0.3) directionChanges++;
            
            // Speed change detection
            const prevSpeed = Math.sqrt(prev.x*prev.x + prev.y*prev.y);
            const currSpeed = Math.sqrt(curr.x*curr.x + curr.y*curr.y);
            if (Math.abs(currSpeed - prevSpeed) > 1.7) speedChanges++;
            
            speedSum += currSpeed;
        }
        
        // Calculate cover usage
        let coverUsage = 0;
        if (history.actions) {
            const coverActions = history.actions.filter(a => 
                a === 'cover' || a === 'peek' || a === 'hide'
            ).length;
            coverUsage = coverActions / history.actions.length;
        }
        
        // Calculate erratic score
        const erraticScore = (directionChanges * 0.8) + (speedChanges * 0.6);
        
        return {
            avgSpeed: speedSum / history.velocities.length,
            directionChanges,
            speedChanges,
            coverUsage,
            erraticScore
        };
    }
    
    matchPattern(metrics) {
        const patterns = this.movementPatternDatabase.getPatterns();
        let bestMatch = null;
        let minDifference = Infinity;
        
        patterns.forEach(pattern => {
            const difference = 
                Math.abs(pattern.avgSpeed - metrics.avgSpeed) * 0.5 +
                Math.abs(pattern.directionChangeRate - metrics.directionChanges) * 1.2 +
                Math.abs(pattern.speedChangeRate - metrics.speedChanges) * 0.9 +
                Math.abs(pattern.coverUsage - metrics.coverUsage) * 0.7;
                
            if (difference < minDifference) {
                minDifference = difference;
                bestMatch = pattern.name;
            }
        });
        
        return bestMatch;
    }
    
    assessMovementThreat(target) {
        let threat = 0;
        
        // Speed-based threat (exponential scaling)
        threat += Math.min(5, Math.pow(target.movementSpeed / 5, 1.8));
        
        // Direction change threat
        if (target.directionChangeRate > 0.4) threat += 4;
        
        // Flanking detection
        if (this.isFlanking(target)) threat += 6;
        
        // Cover usage reduces threat
        if (target.coverUsage > 0.4) threat -= 3;
        
        return Math.max(0, threat);
    }
    
    isFlanking(target) {
        if (!target.playerPosition) return false;
        
        const angleToPlayer = Math.atan2(
            target.playerPosition.y - target.position.y,
            target.playerPosition.x - target.position.x
        );
        
        const movementAngle = Math.atan2(
            target.velocity.y,
            target.velocity.x
        );
        
        const angleDifference = Math.abs(angleToPlayer - movementAngle);
        return angleDifference > Math.PI/4 && angleDifference < 3*Math.PI/4;
    }
    
    predictNextPosition(target, timeAhead) {
        const basePosition = {
            x: target.position.x + target.velocity.x * timeAhead,
            y: target.position.y + target.velocity.y * timeAhead,
            z: target.position.z + target.velocity.z * timeAhead
        };
        
        // Apply pattern-based adjustments
        switch (target.movementPattern) {
            case 'strafe_left':
                basePosition.x -= 1.2 * timeAhead;
                break;
            case 'strafe_right':
                basePosition.x += 1.2 * timeAhead;
                break;
            case 'fallback':
                basePosition.x += Math.cos(target.playerAngle) * 2 * timeAhead;
                basePosition.z += Math.sin(target.playerAngle) * 2 * timeAhead;
                break;
            case 'push_forward':
                basePosition.x -= Math.cos(target.playerAngle) * 2.5 * timeAhead;
                basePosition.z -= Math.sin(target.playerAngle) * 2.5 * timeAhead;
                break;
        }
        
        return basePosition;
    }
}

class MovementPatternDatabase {
    constructor() {
        this.patterns = [
            { name: 'strafe_left', avgSpeed: 4.5, directionChangeRate: 0.3, speedChangeRate: 0.4, coverUsage: 0.2 },
            { name: 'strafe_right', avgSpeed: 4.5, directionChangeRate: 0.3, speedChangeRate: 0.4, coverUsage: 0.2 },
            { name: 'fallback', avgSpeed: 5.2, directionChangeRate: 0.2, speedChangeRate: 0.3, coverUsage: 0.6 },
            { name: 'push_forward', avgSpeed: 6.0, directionChangeRate: 0.1, speedChangeRate: 0.2, coverUsage: 0.1 },
            { name: 'cover_peek', avgSpeed: 2.0, directionChangeRate: 0.8, speedChangeRate: 0.7, coverUsage: 0.9 },
            { name: 'sniper_shift', avgSpeed: 1.5, directionChangeRate: 0.1, speedChangeRate: 0.1, coverUsage: 0.8 },
            { name: 'flanking_left', avgSpeed: 5.8, directionChangeRate: 0.4, speedChangeRate: 0.5, coverUsage: 0.3 },
            { name: 'flanking_right', avgSpeed: 5.8, directionChangeRate: 0.4, speedChangeRate: 0.5, coverUsage: 0.3 }
        ];
    }
    
    getPatterns() {
        return this.patterns;
    }
    
    addPattern(pattern) {
        this.patterns.push(pattern);
    }
}

// ================== TACTICAL MOVEMENT MODEL (UPGRADED) ==================
class TacticalMovementModel {
    predictHead(target, history, timeAhead) {
        // Predict based on tactical behavior
        const lastAction = history.actions[history.actions.length - 1];
        let prediction;
        
        switch (lastAction) {
            case 'cover':
                prediction = this.predictCoverMovement(target, history);
                break;
            case 'flanking':
                prediction = this.predictFlankingMovement(target, history);
                break;
            case 'retreat':
                prediction = this.predictRetreatMovement(target, history);
                break;
            case 'dodge': // NEW
                prediction = this.predictDodgeMovement(target, history);
                break;
            default:
                prediction = new LinearPredictionModel().predictHead(target, history, timeAhead);
        }
        
        // Add head height
        prediction.y += target.headHitbox.baseRadius;
        
        return prediction;
    }
    
    predictCoverMovement(target, history) {
        // Find nearest cover
        const coverPosition = this.findNearestCover(target.position);
        
        return {
            x: coverPosition.x,
            y: target.position.y,
            z: coverPosition.z
        };
    }
    
    findNearestCover(position) {
        // Advanced cover finding
        return {
            x: position.x + 1.8,
            y: position.y,
            z: position.z + 0.7
        };
    }
    
    predictFlankingMovement(target, history) {
        const playerPosition = history.context.playerPosition;
        const angleToPlayer = Math.atan2(
            playerPosition.y - target.position.y,
            playerPosition.x - target.position.x
        );
        
        const flankAngle = angleToPlayer + (Math.random() > 0.5 ? Math.PI/2.8 : -Math.PI/2.8);
        
        return {
            x: target.position.x + Math.cos(flankAngle) * 4.5,
            y: target.position.y,
            z: target.position.z + Math.sin(flankAngle) * 4.5
        };
    }
    
    // NEW: Predict dodge movement
    predictDodgeMovement(target, history) {
        const dodgeType = history.actions.filter(a => a === 'dodge').slice(-1)[0];
        let dodgeVector = { x: 0, y: 0, z: 0 };
        
        if (dodgeType === 'jump') {
            dodgeVector.y = 1.5;
        } else if (dodgeType === 'crouch') {
            dodgeVector.y = -0.6;
        } else if (dodgeType === 'slide') {
            dodgeVector.y = -0.4;
            dodgeVector.x = target.velocity.x * 0.7;
            dodgeVector.z = target.velocity.z * 0.7;
        } else { // Strafe
            dodgeVector.x = target.velocity.x * 1.1;
            dodgeVector.z = target.velocity.z * 1.1;
        }
        
        return {
            x: target.position.x + dodgeVector.x,
            y: target.position.y + dodgeVector.y,
            z: target.position.z + dodgeVector.z
        };
    }
}

// ================== ADAPTIVE LOCK CONTROLLER (UPGRADED) ==================
class AdaptiveLockController {
    constructor() {
        this.lockSensitivity = 0.98; // Increased
        this.minLockTime = 0.06; // Reduced
        this.maxLockDistance = 400; // Increased
        this.lastLockTime = 0;
        this.hyperLockMode = false;
        this.currentDistanceProfile = "medium";
        this.headStabilization = 0.995; // Increased
        this.headLockStrength = 1.0; // NEW
    }
    
    isTargetLocked(target, aimPosition) {
        const distance = this.calculateAimDistance(aimPosition, target.headHitbox);
        return distance < (target.headHitbox.radius * 0.35); // Tighter threshold
    }
    
    isTargetMoving(target) {
        return target.movementSpeed > 0.1;
    }
    
    quantumAdjust(currentAim, newPosition, target) {
        // Calculate movement vector
        const moveVector = {
            x: newPosition.x - currentAim.x,
            y: newPosition.y - currentAim.y,
            z: newPosition.z - currentAim.z
        };
        
        // Distance-based sensitivity
        let sensitivity = this.lockSensitivity;
        if (target.distance < 15) sensitivity *= 1.15;
        else if (target.distance > 90) sensitivity *= 0.88;
        
        // Apply stabilization
        return {
            x: currentAim.x + moveVector.x * sensitivity * this.headStabilization * this.headLockStrength, // NEW
            y: currentAim.y + moveVector.y * sensitivity * this.headStabilization * this.headLockStrength, // NEW
            z: currentAim.z + moveVector.z * sensitivity * 0.88
        };
    }
    
    stabilizeAim(newAim, currentAim) {
        // Smoother transition
        return {
            x: currentAim.x * 0.25 + newAim.x * 0.75,
            y: currentAim.y * 0.15 + newAim.y * 0.85,
            z: currentAim.z * 0.35 + newAim.z * 0.65
        };
    }
}

// ================== SMART RECOIL SYSTEM (UPGRADED) ==================
class SmartRecoilSystem {
    constructor() {
        this.recoilPatterns = {
            default: { vertical: 0.1, horizontal: 0.03 },
            sniper: { vertical: 0.25, horizontal: 0.01 },
            ak47: { vertical: 0.15, horizontal: 0.05 },
            m4a1: { vertical: 0.12, horizontal: 0.04 },
            shotgun: { vertical: 0.18, horizontal: 0.08 },
            awm: { vertical: 0.28, horizontal: 0.009 },
            groza: { vertical: 0.16, horizontal: 0.055 },
            mp40: { vertical: 0.14, horizontal: 0.042 }
        };
        this.distanceFactors = {
            close: { vertical: 0.85, horizontal: 0.92 },
            medium: { vertical: 1.0, horizontal: 1.0 },
            far: { vertical: 1.15, horizontal: 0.88 },
            extreme: { vertical: 1.25, horizontal: 0.82 }
        };
        this.learnRate = 0.92;
        this.recoilMemory = new Map();
        this.stabilizationTime = 0;
    }
    
    smartCompensate(aimPosition, weaponType, recoilData, distance, firingDuration) {
        // Get recoil pattern for weapon
        const pattern = this.getRecoilPattern(weaponType);
        
        // Update pattern based on actual data
        this.updatePattern(weaponType, recoilData);
        
        // Get distance factor
        const range = distance < 15 ? 'close' : 
                     distance < 50 ? 'medium' : 
                     distance < 120 ? 'far' : 'extreme';
        const distFactor = this.distanceFactors[range];
        
        // Apply memory-based compensation
        const memoryCompensation = this.getMemoryCompensation(weaponType);
        
        // Calculate stabilization factor
        const stabilization = this.calculateStabilization(firingDuration);
        
        // Calculate compensation
        const compensation = {
            x: (pattern.horizontal + memoryCompensation.x) * distFactor.horizontal * stabilization,
            y: (pattern.vertical + memoryCompensation.y) * distFactor.vertical * stabilization,
            z: 0
        };
        
        // Apply compensation
        return {
            x: aimPosition.x - compensation.x,
            y: aimPosition.y - compensation.y,
            z: aimPosition.z - compensation.z
        };
    }
    
    calculateStabilization(firingDuration) {
        // Weapons become more stable after initial burst
        if (firingDuration < 300) return 1.0; // First 300ms full recoil
        if (firingDuration < 800) return 0.85; // 300-800ms reduced recoil
        return 0.75; // After 800ms minimal recoil
    }
    
    getMemoryCompensation(weaponType) {
        if (!this.recoilMemory.has(weaponType)) {
            return { x: 0, y: 0 };
        }
        return this.recoilMemory.get(weaponType);
    }
    
    updatePattern(weaponType, recoilData) {
        if (!recoilData) return;
        
        if (!this.recoilMemory.has(weaponType)) {
            this.recoilMemory.set(weaponType, { x: 0, y: 0 });
        }
        
        const memory = this.recoilMemory.get(weaponType);
        const pattern = this.recoilPatterns[weaponType] || this.recoilPatterns.default;
        
        // Update based on actual recoil
        memory.x = memory.x * this.learnRate + (recoilData.x - pattern.horizontal) * (1 - this.learnRate);
        memory.y = memory.y * this.learnRate + (recoilData.y - pattern.vertical) * (1 - this.learnRate);
        
        this.recoilMemory.set(weaponType, memory);
    }
}

// ================== GHOST STEALTH (UPGRADED) ==================
class GhostStealth {
    constructor() {
        this.behaviorPatterns = [];
        this.lastBehaviorChange = 0;
        this.changeInterval = 45000; // 45 seconds
        this.suspicionThreshold = 0.8;
        this.errorInjectionRate = 0.05;
        this.reactionTimeVariance = 0.25;
        this.aimJitterFactor = 0.03;
    }
    
    concealAimBehavior(gameData, contextAnalyzer) {
        const currentTime = Date.now();
        
        // Change behavior pattern if needed
        if (currentTime - this.lastBehaviorChange > this.changeInterval || 
            contextAnalyzer.isSuspicionHigh()) {
            this.randomizeBehaviorPattern(contextAnalyzer.getPlayerSkillLevel());
            this.lastBehaviorChange = currentTime;
        }
        
        // Apply current pattern
        this.applyBehaviorPattern(gameData);
        
        // Apply head lock concealment
        this.concealHeadLock(gameData);
        
        // Apply recoil pattern masking
        this.maskRecoilPattern(gameData);
        
        // Apply random input delay
        this.applyInputDelay(gameData);
    }
    
    randomizeBehaviorPattern(skillLevel) {
        // Higher skill level = less error and faster reaction
        const baseError = 0.08 + (0.1 * (1 - skillLevel));
        const baseReaction = 0.15 + (0.2 * (1 - skillLevel));
        
        this.behaviorPatterns = [
            { type: 'reaction', value: Math.random() * baseReaction },
            { type: 'precision', value: baseError + Math.random() * 0.05 },
            { type: 'smoothness', value: 0.65 + Math.random() * 0.25 },
            { type: 'error', value: baseError * 0.5 + Math.random() * baseError }
        ];
    }
    
    applyBehaviorPattern(gameData) {
        for (const pattern of this.behaviorPatterns) {
            switch (pattern.type) {
                case 'reaction':
                    gameData.responseTime += pattern.value * 100;
                    break;
                case 'precision':
                    if (gameData.aimPosition) {
                        const errorX = (Math.random() * 2 - 1) * pattern.value;
                        const errorY = (Math.random() * 2 - 1) * pattern.value * 0.6;
                        gameData.aimPosition.x += errorX;
                        gameData.aimPosition.y += errorY;
                    }
                    break;
                case 'smoothness':
                    // Implement smoothness by reducing aim correction speed
                    if (gameData.aimCorrection) {
                        gameData.aimCorrection.x *= pattern.value;
                        gameData.aimCorrection.y *= pattern.value;
                    }
                    break;
                case 'error':
                    if (Math.random() < this.errorInjectionRate) {
                        gameData.aimPosition.x += (Math.random() > 0.5 ? 1 : -1) * pattern.value * 3;
                    }
                    break;
            }
        }
    }
    
    concealHeadLock(gameData) {
        if (!gameData.aimPosition || !gameData.targets || gameData.targets.length === 0) return;
        
        const target = gameData.targets[0];
        const headCenter = {
            x: target.headHitbox.x,
            y: target.headHitbox.y,
            z: target.headHitbox.z
        };
        
        const distanceToHead = Math.sqrt(
            Math.pow(gameData.aimPosition.x - headCenter.x, 2) +
            Math.pow(gameData.aimPosition.y - headCenter.y, 2)
        );
        
        // Add random noise when locked on head
        if (distanceToHead < target.headHitbox.radius * 0.5) {
            const noiseX = (Math.random() * 2 - 1) * this.aimJitterFactor;
            const noiseY = (Math.random() * 2 - 1) * this.aimJitterFactor * 0.7;
            gameData.aimPosition.x += noiseX;
            gameData.aimPosition.y += noiseY;
        }
    }
    
    maskRecoilPattern(gameData) {
        if (!gameData.recoilPattern) return;
        
        // Randomize recoil pattern slightly
        gameData.recoilPattern = gameData.recoilPattern.map(point => {
            return {
                x: point.x + (Math.random() * 2 - 1) * 0.01,
                y: point.y + (Math.random() * 2 - 1) * 0.015,
                time: point.time
            };
        });
    }
    
    applyInputDelay(gameData) {
        const delay = 20 + Math.random() * 30;
        gameData.inputDelay = delay;
    }
}

// ================== TACTICAL ANALYZER (UPGRADED) ==================
class TacticalAnalyzer {
    constructor() {
        this.combatState = "normal";
        this.threatLevel = 0;
        this.stateHistory = [];
        this.thresholds = {
            low: 30,
            medium: 60,
            high: 85
        };
    }
    
    tacticalAnalyze(gameState) {
        if (!gameState) return;
        
        // Calculate threat score with environment
        const threatScore = this.calculateTacticalThreat(gameState);
        
        // Update combat state
        this.updateCombatState(threatScore);
        
        // Analyze headshot opportunities
        this.analyzeHeadshotOpportunities(gameState);
        
        // Save state history
        this.stateHistory.push({
            state: this.combatState,
            timestamp: Date.now(),
            threatScore: threatScore
        });
    }
    
    calculateTacticalThreat(gameState) {
        let score = 0;
        
        // Enemy count with positioning
        score += Math.min(8, gameState.enemyCount) * 1.4;
        
        // Positional threat
        if (gameState.isSurrounded) score += 6.0;
        if (gameState.isFlanked) score += 7.5;
        
        // Nearest enemy distance with weapon factor
        if (gameState.nearestEnemyDistance < 10) score += 5.0;
        else if (gameState.nearestEnemyDistance < 25) score += 3.5;
        else if (gameState.nearestEnemyDistance < 50) score += 2.0;
        
        // Player health with critical state
        if (gameState.playerHealth < 20) score += 5.0;
        else if (gameState.playerHealth < 40) score += 3.0;
        else if (gameState.playerHealth < 60) score += 1.5;
        
        // Ammo status
        if (gameState.ammoStatus === 'low') score += 2.5;
        if (gameState.ammoStatus === 'critical') score += 4.0;
        
        // Team status
        if (gameState.teamMembersDown > 0) score += 2.0 * gameState.teamMembersDown;
        
        return Math.min(100, score);
    }
    
    updateCombatState(threatScore) {
        if (threatScore > this.thresholds.high) {
            this.combatState = "critical";
        } else if (threatScore > this.thresholds.medium) {
            this.combatState = "high";
        } else if (threatScore > this.thresholds.low) {
            this.combatState = "medium";
        } else {
            this.combatState = "low";
        }
        
        this.threatLevel = threatScore / 100;
    }
    
    analyzeHeadshotOpportunities(gameState) {
        let opportunity = 0;
        
        // Enemy exposure
        if (gameState.exposedEnemies > 0) opportunity += 0.4;
        
        // Positional advantage
        if (gameState.hasHighGround) opportunity += 0.3;
        if (gameState.hasCover) opportunity += 0.2;
        
        // Enemy status
        if (gameState.enemiesReloading > 0) opportunity += 0.25;
        if (gameState.enemiesLowHealth > 0) opportunity += 0.3;
        if (gameState.enemiesDistracted > 0) opportunity += 0.2;
        
        // Weapon suitability
        if (gameState.optimalWeaponRange) opportunity += 0.2;
        
        // Time pressure
        if (gameState.matchTime < 30000) opportunity += 0.15; // Last 30 seconds
        
        gameState.headshotOpportunity = Math.min(1, opportunity);
    }
    
    getCombatState() {
        return this.combatState;
    }
    
    getThreatLevel() {
        return this.threatLevel;
    }
    
    getHeadshotOpportunity() {
        return this.currentHeadshotOpportunity || 0;
    }
}

// ================== AI PERFORMANCE OPTIMIZER (UPGRADED) ==================
class AIPerformanceOptimizer {
    constructor() {
        this.currentProfile = "high";
        this.aimPredictionLevel = 20;
        this.currentFPS = 60;
        this.aiWorkload = 0.5;
        this.qualityProfiles = {
            low: { 
                predictionLevel: 8, 
                updateInterval: 200,
                features: ['headshot', 'recoil']
            },
            medium: { 
                predictionLevel: 12, 
                updateInterval: 150,
                features: ['headshot', 'recoil', 'prediction']
            },
            high: { 
                predictionLevel: 18, 
                updateInterval: 100,
                features: ['headshot', 'recoil', 'prediction', 'dodge']
            },
            ultra: { 
                predictionLevel: 25, 
                updateInterval: 50,
                features: ['headshot', 'recoil', 'prediction', 'dodge', 'environment']
            }
        };
        this.lastUpdate = 0;
        this.enabledFeatures = [];
    }
    
    adaptiveAdjust(performanceState) {
        if (!performanceState) return;
        
        this.currentFPS = performanceState.fps || 60;
        this.aiWorkload = performanceState.aiLoad || 0.5;
        const batteryLevel = performanceState.batteryLevel || 100;
        const thermalState = performanceState.thermalState || "normal";
        const ramUsage = performanceState.ramUsage || 0.5;
        
        // Determine quality profile
        if (this.currentFPS < 40 || ramUsage > 0.85) {
            this.currentProfile = "low";
        } else if (this.currentFPS < 55 || ramUsage > 0.75) {
            this.currentProfile = "medium";
        } else if (this.currentFPS < 75) {
            this.currentProfile = "high";
        } else {
            this.currentProfile = "ultra";
        }
        
        // Get current profile settings
        const profile = this.qualityProfiles[this.currentProfile];
        this.aimPredictionLevel = profile.predictionLevel;
        this.enabledFeatures = profile.features;
        
        // Apply thermal throttling
        if (thermalState === "high") {
            this.aimPredictionLevel = Math.max(5, this.aimPredictionLevel * 0.65);
        }
        
        // Apply battery saving
        if (batteryLevel < 20) {
            this.aimPredictionLevel = Math.max(5, this.aimPredictionLevel * 0.75);
        }
        
        // Adjust AI workload
        if (this.aiWorkload > 0.8) {
            this.aimPredictionLevel = Math.max(5, this.aimPredictionLevel - 7);
        } else if (this.aiWorkload > 0.65) {
            this.aimPredictionLevel = Math.max(8, this.aimPredictionLevel - 4);
        }
    }
    
    shouldProcessFrame() {
        const now = Date.now();
        const interval = this.qualityProfiles[this.currentProfile].updateInterval;
        
        if (now - this.lastUpdate > interval) {
            this.lastUpdate = now;
            return true;
        }
        return false;
    }
    
    isFeatureEnabled(feature) {
        return this.enabledFeatures.includes(feature);
    }
    
    getPredictionLevel() {
        return this.aimPredictionLevel;
    }
    
    getUpdateInterval() {
        return this.qualityProfiles[this.currentProfile].updateInterval;
    }
    
    getCurrentProfile() {
        return this.currentProfile;
    }
}

// ================== HEAD TRACKING SYSTEM (UPGRADED) ==================
class HeadTrackingSystem {
    constructor() {
        this.historySize = 30;
        this.headPositionHistory = new Map();
        this.movementPredictionLevel = 0.9;
    }

    trackHead(target) {
        // Lịch sử vị trí đầu
        if (!this.headPositionHistory.has(target.id)) {
            this.headPositionHistory.set(target.id, []);
        }
        
        const history = this.headPositionHistory.get(target.id);
        const currentHeadPos = this.calculateCurrentHeadPosition(target);
        
        // Lưu lịch sử
        history.push({
            position: currentHeadPos,
            timestamp: Date.now(),
            velocity: target.velocity
        });
        
        // Giới hạn lịch sử
        if (history.length > this.historySize) {
            history.shift();
        }
        
        // Dự đoán vị trí tiếp theo
        const predictedPosition = this.predictNextPosition(history);
        target.headPosition = predictedPosition;
        
        return predictedPosition;
    }

    calculateCurrentHeadPosition(target) {
        // Tính toán chi tiết dựa trên hoạt ảnh nhân vật
        let headHeight;
        
        switch (target.stance) {
            case 'standing':
                headHeight = 1.68;
                break;
            case 'crouching':
                headHeight = 1.25;
                break;
            case 'prone':
                headHeight = 0.85;
                break;
            case 'jumping':
                const jumpProgress = Math.min(1, (Date.now() - target.jumpStartTime) / 800);
                headHeight = 1.68 + Math.sin(jumpProgress * Math.PI) * 0.7;
                break;
            case 'vaulting':
                headHeight = 1.68 + 0.4;
                break;
            case 'sliding':
                headHeight = 1.05;
                break;
            default:
                headHeight = 1.68;
        }
        
        // Điều chỉnh theo vũ khí đang cầm
        if (target.weaponType === 'sniper') headHeight -= 0.05;
        
        return {
            x: target.position.x,
            y: target.position.y + headHeight,
            z: target.position.z
        };
    }

    predictNextPosition(history) {
        if (history.length < 3) return history[history.length - 1].position;
        
        const lastEntry = history[history.length - 1];
        const prevEntry = history[history.length - 2];
        
        // Tính toán vận tốc
        const timeDiff = (lastEntry.timestamp - prevEntry.timestamp) / 1000;
        const velocity = {
            x: (lastEntry.position.x - prevEntry.position.x) / timeDiff,
            y: (lastEntry.position.y - prevEntry.position.y) / timeDiff,
            z: (lastEntry.position.z - prevEntry.position.z) / timeDiff
        };
        
        // Dự đoán với Kalman Filter đơn giản
        const prediction = {
            x: lastEntry.position.x + velocity.x * this.movementPredictionLevel,
            y: lastEntry.position.y + velocity.y * this.movementPredictionLevel,
            z: lastEntry.position.z + velocity.z * this.movementPredictionLevel
        };
        
        // Hiệu chỉnh theo trọng lực nếu đang nhảy
        if (lastEntry.velocity.y > 0) {
            prediction.y -= 0.5 * 9.8 * timeDiff * timeDiff;
        }
        
        return prediction;
    }
}

// ================== COMBAT CONTEXT PROCESSOR (UPGRADED) ==================
class CombatContextProcessor {
    constructor() {
        this.playerSkillLevel = 0.7;
        this.mapType = 'unknown';
        this.timeRemaining = 0;
        this.suspicionLevel = 0;
        this.headshotOpportunity = 0;
        this.threatMatrix = new ThreatMatrix();
        this.environment = {
            weather: 'clear',
            timeOfDay: 'day',
            windSpeed: 0,
            windDirection: 0
        };
    }

    processContext(gameState) {
        this.playerSkillLevel = gameState.playerSkill || 0.7;
        this.mapType = gameState.map || 'unknown';
        this.timeRemaining = gameState.matchTime || 0;
        
        // Store environment data
        this.environment = gameState.environment || this.environment;
        
        // Calculate suspicion level
        this.suspicionLevel = this.calculateSuspicion(gameState);
        
        // Calculate headshot opportunity
        this.headshotOpportunity = this.calculateHeadshotOpportunity(gameState);
        
        // Update threat matrix
        this.threatMatrix.update(gameState);
    }
    
    calculateSuspicion(gameState) {
        let suspicion = 0;
        
        // Headshot rate analysis
        if (gameState.headshotRate > 0.75) suspicion += 0.5;
        
        // Accuracy analysis
        if (gameState.accuracy > 0.65) suspicion += 0.4;
        
        // Reaction time analysis
        if (gameState.avgReactionTime < 150) suspicion += 0.6;
        
        // Behavior pattern analysis
        if (gameState.consistentHeadshots > 5) suspicion += 0.45;
        
        // Environmental awareness
        if (gameState.unusualPositioning) suspicion += 0.35;
        
        // Perfect timing analysis
        if (gameState.perfectTimingCount > 3) suspicion += 0.3;
        
        return Math.min(1, suspicion);
    }
    
    calculateHeadshotOpportunity(gameState) {
        let opportunity = 0;
        
        // Enemy exposure
        if (gameState.exposedEnemies > 0) opportunity += 0.4;
        
        // Positional advantage
        if (gameState.hasHighGround) opportunity += 0.3;
        if (gameState.hasCover) opportunity += 0.2;
        
        // Enemy status
        if (gameState.enemiesReloading > 0) opportunity += 0.25;
        if (gameState.enemiesLowHealth > 0) opportunity += 0.35;
        
        // Weapon suitability
        if (gameState.optimalWeaponRange) opportunity += 0.25;
        
        // Environmental factors
        if (this.environment.weather === 'fog') opportunity -= 0.2;
        if (this.environment.timeOfDay === 'night') opportunity -= 0.15;
        
        return Math.min(1, opportunity);
    }
    
    isSuspicionHigh() {
        return this.suspicionLevel > 0.75;
    }
    
    getPlayerSkillLevel() {
        return this.playerSkillLevel;
    }
    
    getHeadshotOpportunity() {
        return this.headshotOpportunity;
    }
    
    getThreatLevel() {
        return this.threatMatrix.getCurrentThreat();
    }
    
    getEnvironment() {
        return this.environment;
    }
}

class ThreatMatrix {
    constructor() {
        this.threatLevel = 0;
        this.threatFactors = {
            proximity: 0.4,
            visibility: 0.3,
            weapon: 0.2,
            behavior: 0.1
        };
        this.decayRate = 0.92;
    }
    
    update(gameState) {
        let newThreat = 0;
        
        // Proximity threat
        if (gameState.nearestEnemyDistance < 10) newThreat += 0.9;
        else if (gameState.nearestEnemyDistance < 25) newThreat += 0.6;
        else if (gameState.nearestEnemyDistance < 50) newThreat += 0.3;
        
        // Visibility threat
        if (gameState.visibleEnemies > 0) newThreat += 0.7 * gameState.visibleEnemies;
        
        // Weapon threat
        if (gameState.dangerousWeaponsNearby) newThreat += 0.8;
        
        // Behavior threat
        if (gameState.enemiesAimingAtPlayer) newThreat += 1.0;
        if (gameState.enemiesThrowingGrenades) newThreat += 0.5;
        
        // Apply weighted factors
        this.threatLevel = Math.min(1, 
            this.threatLevel * this.decayRate + 
            newThreat * (1 - this.decayRate)
        );
    }
    
    getCurrentThreat() {
        return this.threatLevel;
    }
}

// ================== NEW: SKELETAL TRACKING SYSTEM ==================
class SkeletalTrackingSystem {
    constructor() {
        this.jointWeights = {
            head: 0.5,
            neck: 0.3,
            shoulders: 0.2
        };
        this.minConfidence = 0.8;
        this.maxTrackingDistance = 150;
    }
    
    trackBodies(skeletalData) {
        const targets = [];
        
        skeletalData.bodies.forEach(body => {
            if (body.confidence < this.minConfidence) return;
            if (body.distance > this.maxTrackingDistance) return;
            
            // Calculate head position from joints
            const headPosition = this.calculateHeadPosition(body.joints);
            
            targets.push({
                type: 'player',
                position: headPosition,
                confidence: body.confidence,
                headVisibility: this.calculateHeadVisibility(body.joints),
                skeleton: body,
                distance: body.distance
            });
        });
        
        return targets;
    }
    
    calculateHeadPosition(joints) {
        let headX = 0, headY = 0, headZ = 0;
        let totalWeight = 0;
        
        // Head joint
        const headJoint = joints.find(j => j.name === 'head');
        if (headJoint && headJoint.confidence > 0.7) {
            headX += headJoint.x * this.jointWeights.head;
            headY += headJoint.y * this.jointWeights.head;
            headZ += headJoint.z * this.jointWeights.head;
            totalWeight += this.jointWeights.head;
        }
        
        // Neck joint
        const neckJoint = joints.find(j => j.name === 'neck');
        if (neckJoint && neckJoint.confidence > 0.7) {
            headX += neckJoint.x * this.jointWeights.neck;
            headY += neckJoint.y * this.jointWeights.neck;
            headZ += neckJoint.z * this.jointWeights.neck;
            totalWeight += this.jointWeights.neck;
        }
        
        // Shoulders (average)
        const leftShoulder = joints.find(j => j.name === 'left_shoulder');
        const rightShoulder = joints.find(j => j.name === 'right_shoulder');
        if (leftShoulder && rightShoulder && 
            leftShoulder.confidence > 0.6 && rightShoulder.confidence > 0.6) {
            const shoulderX = (leftShoulder.x + rightShoulder.x) / 2;
            const shoulderY = (leftShoulder.y + rightShoulder.y) / 2;
            const shoulderZ = (leftShoulder.z + rightShoulder.z) / 2;
            
            headX += shoulderX * this.jointWeights.shoulders;
            headY += shoulderY * this.jointWeights.shoulders;
            headZ += shoulderZ * this.jointWeights.shoulders;
            totalWeight += this.jointWeights.shoulders;
        }
        
        // Calculate weighted average
        return {
            x: headX / totalWeight,
            y: headY / totalWeight,
            z: headZ / totalWeight
        };
    }
    
    calculateHeadVisibility(joints) {
        let visibility = 1.0;
        
        // Check head joint visibility
        const headJoint = joints.find(j => j.name === 'head');
        if (headJoint) {
            visibility *= headJoint.visibility;
        }
        
        // Check if head is behind cover
        if (this.isHeadBehindCover(joints)) {
            visibility *= 0.4;
        }
        
        return visibility;
    }
    
    isHeadBehindCover(joints) {
        // Simplified cover detection
        const head = joints.find(j => j.name === 'head');
        const neck = joints.find(j => j.name === 'neck');
        
        if (!head || !neck) return false;
        
        // Check if there's a barrier between head and player
        const barrier = this.detectBarrier(head, neck);
        return barrier.exists;
    }
    
    detectBarrier(head, neck) {
        // Placeholder for actual barrier detection
        return { exists: false };
    }
}

// ================== INITIALIZATION ==================
const omegaSystem = new OmegaHeadshotSystem();
$done({ body: omegaSystem.process($response.body) });
