// HEADSHOT MASTER v6.0 (PERFECT HEADSHOT SYSTEM)
class UltimateHeadshotSystem {
    constructor() {
        // Enhanced configuration
        this.lockStrength = 0.999999;
        this.targetHistory = new Map();
        this.sessionToken = `HS_ULTRA_${Date.now().toString(36)}_${Math.random().toString(36).substr(2, 12)}`;
        this.weaponProfiles = this.getPrecisionWeaponProfiles();
        this.aimPredictionLevel = 18;
        this.aimStabilizer = 0.99995;
        this.headshotAccuracy = 0.9999;
        this.headshotExpansion = 12.5;
        this.maxHistory = 100;
        this.lockedHeadPosition = null;
        this.lastTargetId = null;
        this.targetSwitchCooldown = 0;
        this.emergencyLockMode = false;
        this.instantLockEnabled = true;
        this.lockResponseTime = 0.015; // 15ms response time
        this.distanceBasedAimAssist = new DistanceBasedAimAssist();
        this.headshotOptimizer = new HeadshotOptimizer();
        this.movementAnalyzer = new AdvancedMovementAnalyzer();
        this.positionTracker = new PositionTracker();
        
        // Enhanced modules
        this.targetDetector = new EnhancedTargetDetector();
        this.autoAimSystem = new AdvancedAutoAimSystem();
        this.bulletTracker = new PrecisionBulletTracker();
        this.targetPredictor = new EnhancedTargetPredictor();
        this.aimLockController = new SmartAimLockController();
        this.recoilCompensator = new AdvancedRecoilCompensator();
        this.performanceOptimizer = new AdaptivePerformanceOptimizer();
        this.stealthModule = new EliteStealthModule();
        this.combatAnalyzer = new TacticalCombatAnalyzer();
        this.triggerResponseSystem = new InstantTriggerResponseSystem();
        this.headshotGuarantor = new HeadshotGuarantorPro();
        this.headPositionCalculator = new HeadPositionCalculator();
        this.threatEvaluator = new ThreatEvaluator();
        this.aimStabilizer = new AimStabilizer();
    }

    process(body) {
        try {
            const startTime = performance.now();
            const data = JSON.parse(body);
            
            // Optimize performance based on device
            this.performanceOptimizer.adjustSettings(data.performanceState);
            
            // Analyze combat situation
            this.combatAnalyzer.analyze(data.gameState);
            
            // Activate instant lock if fire button is pressed
            if (data.gameState?.isFiring && this.instantLockEnabled) {
                this.triggerResponseSystem.activateInstantLock();
            }
            
            // Detect enemies with enhanced algorithms
            const detectedTargets = this.targetDetector.detectTargets(data);
            data.targets = detectedTargets;
            
            if (detectedTargets.length > 0) {
                // Track target positions
                this.positionTracker.updatePositions(detectedTargets);
                
                // Select priority target based on threat analysis
                const priorityTarget = this.selectPriorityTarget(detectedTargets, data.gameState);
                
                // Apply auto aiming
                if (priorityTarget) {
                    // Calculate precise head position
                    priorityTarget.headHitbox = this.headPositionCalculator.calculateHeadPosition(
                        priorityTarget, 
                        data.gameState,
                        this.positionTracker.getHistory(priorityTarget.id)
                    );
                    
                    // Apply distance-based aim assist
                    const distanceFactors = this.distanceBasedAimAssist.getFactors(
                        priorityTarget.distance,
                        data.currentWeapon
                    );
                    
                    // Apply auto aiming with enhanced precision
                    const aimData = this.autoAimSystem.acquireTarget(
                        priorityTarget, 
                        data.currentAimPosition,
                        data.playerPosition,
                        data.currentWeapon,
                        data.gameState,
                        this.triggerResponseSystem.isInstantLockActive(),
                        distanceFactors
                    );
                    
                    // Apply aim stabilization
                    data.aimPosition = this.aimStabilizer.stabilizeAim(
                        aimData.position, 
                        data.currentAimPosition,
                        priorityTarget.distance,
                        data.gameState.isMoving
                    );
                    
                    // Apply headshot lock
                    if (this.shouldLockTarget(aimData, data.gameState, priorityTarget)) {
                        data.autoFire = true;
                        data.fireMode = "perfect_headshot_lock";
                        
                        // Calculate bullet trajectory with 100% headshot guarantee
                        data.bulletTrajectory = this.bulletTracker.calculateGuaranteedTrajectory(
                            data.playerPosition,
                            data.aimPosition,
                            priorityTarget,
                            data.currentWeapon,
                            data.gameState,
                            this.headshotGuarantor,
                            distanceFactors
                        );
                        
                        // Optimize for headshot
                        this.headshotOptimizer.optimizeForHeadshot(
                            data, 
                            priorityTarget, 
                            this.targetPredictor
                        );
                        
                        // Adjust aim for moving targets
                        if (this.aimLockController.isTargetMoving(priorityTarget)) {
                            const newPosition = this.targetPredictor.predictNextPosition(
                                priorityTarget,
                                data.bulletTrajectory.travelTime,
                                this.positionTracker.getHistory(priorityTarget.id)
                            );
                            data.aimPosition = this.aimLockController.adjustAimForMovement(
                                data.aimPosition,
                                newPosition,
                                priorityTarget.distance
                            );
                        }
                    }
                    
                    // Compensate weapon recoil
                    if (data.gameState?.isFiring) {
                        data.aimPosition = this.recoilCompensator.compensate(
                            data.aimPosition,
                            data.currentWeapon,
                            data.gameState.recoilPattern,
                            priorityTarget.distance
                        );
                    }
                    
                    this.lastLockTime = Date.now();
                }
                
                // Conceal aimbot behavior
                this.stealthModule.concealAimBehavior(data);
            }
            
            // Add system metadata
            data.aimSystem = this.getSystemMetadata(startTime);
            return JSON.stringify(data);
        } catch (e) {
            console.error("[PERFECT HEADSHOT SYSTEM] Error:", e.message);
            return body;
        }
    }
    
    shouldLockTarget(aimData, gameState, target) {
        // Always lock when instant lock is active
        if (this.triggerResponseSystem.isInstantLockActive()) return true;
        
        // Lock when lock strength is high
        if (aimData.lockStrength >= 0.99) return true;
        
        // Lock in high threat situations
        if (gameState.playerHealth < 30) return true;
        
        // Lock if head is visible and clear
        if (target.headVisibility > 0.8) return true;
        
        return false;
    }
    
    selectPriorityTarget(targets, gameState) {
        if (targets.length === 0) return null;
        
        // Calculate threat score for each target
        let maxThreat = -1;
        let selectedTarget = null;
        const playerHealth = gameState.playerHealth || 100;
        
        for (const target of targets) {
            const threatScore = this.threatEvaluator.calculateThreatScore(
                target, 
                playerHealth,
                gameState
            );
            if (threatScore > maxThreat) {
                maxThreat = threatScore;
                selectedTarget = target;
            }
        }
        
        return selectedTarget;
    }
    
    getSystemMetadata(startTime) {
        return {
            version: "6.0",
            mode: "perfect_headshot_lock",
            features: {
                instantLock: this.instantLockEnabled,
                headshotExpansion: this.headshotExpansion,
                stealthMode: true,
                guaranteedHeadshot: true,
                distanceBasedAssist: true,
                headTracking: true
            },
            performance: {
                processingTime: performance.now() - startTime,
                fps: this.performanceOptimizer.currentFPS,
                predictionLevel: this.aimPredictionLevel
            },
            lockStatus: {
                strength: this.lockStrength,
                targetId: this.lastTargetId,
                instantLockActive: this.triggerResponseSystem.isInstantLockActive()
            }
        };
    }
    
    getPrecisionWeaponProfiles() {
        return {
            default: {
                bulletVelocity: 380,
                stability: 0.97,
                horizontalRecoil: 0.025,
                verticalRecoil: 0.055,
                aimAssistFactor: 1.0,
                headshotPriority: 9
            },
            sniper: {
                bulletVelocity: 980,
                stability: 0.995,
                horizontalRecoil: 0.005,
                verticalRecoil: 0.085,
                aimAssistFactor: 1.3,
                headshotPriority: 10
            },
            ak47: {
                bulletVelocity: 370,
                stability: 0.94,
                horizontalRecoil: 0.055,
                verticalRecoil: 0.115,
                aimAssistFactor: 0.98,
                headshotPriority: 8
            },
            m4a1: {
                bulletVelocity: 410,
                stability: 0.96,
                horizontalRecoil: 0.038,
                verticalRecoil: 0.075,
                aimAssistFactor: 1.15,
                headshotPriority: 9
            },
            shotgun: {
                bulletVelocity: 320,
                stability: 0.88,
                horizontalRecoil: 0.065,
                verticalRecoil: 0.125,
                aimAssistFactor: 0.90,
                headshotPriority: 7
            },
            awm: {
                bulletVelocity: 1020,
                stability: 0.997,
                horizontalRecoil: 0.003,
                verticalRecoil: 0.092,
                aimAssistFactor: 1.4,
                headshotPriority: 10
            },
            groza: {
                bulletVelocity: 390,
                stability: 0.945,
                horizontalRecoil: 0.045,
                verticalRecoil: 0.105,
                aimAssistFactor: 1.08,
                headshotPriority: 9
            }
        };
    }
}

// ================== DISTANCE-BASED AIM ASSIST ==================
class DistanceBasedAimAssist {
    constructor() {
        this.distancePresets = {
            close: { max: 20, aimSpeed: 0.35, lockStrength: 0.99, expansion: 1.1, recoilFactor: 0.9 },
            medium: { max: 70, aimSpeed: 0.25, lockStrength: 0.97, expansion: 1.3, recoilFactor: 0.95 },
            long: { max: 150, aimSpeed: 0.15, lockStrength: 0.95, expansion: 1.5, recoilFactor: 1.0 },
            extreme: { max: Infinity, aimSpeed: 0.12, lockStrength: 0.92, expansion: 2.0, recoilFactor: 1.1 }
        };
    }
    
    getFactors(distance, weaponType) {
        let preset = this.distancePresets.extreme;
        
        if (distance <= this.distancePresets.close.max) {
            preset = this.distancePresets.close;
        } else if (distance <= this.distancePresets.medium.max) {
            preset = this.distancePresets.medium;
        } else if (distance <= this.distancePresets.long.max) {
            preset = this.distancePresets.long;
        }
        
        // Adjust for weapon type
        const weaponProfile = this.getWeaponProfile(weaponType);
        return {
            aimSpeed: preset.aimSpeed * weaponProfile.aimAssistFactor,
            lockStrength: preset.lockStrength,
            expansion: preset.expansion * weaponProfile.headshotPriority * 0.1,
            recoilFactor: preset.recoilFactor
        };
    }
    
    getWeaponProfile(weaponType) {
        const profiles = {
            default: { aimAssistFactor: 1.0, headshotPriority: 8 },
            sniper: { aimAssistFactor: 1.3, headshotPriority: 10 },
            ak47: { aimAssistFactor: 0.98, headshotPriority: 8 },
            m4a1: { aimAssistFactor: 1.15, headshotPriority: 9 },
            shotgun: { aimAssistFactor: 0.90, headshotPriority: 7 },
            awm: { aimAssistFactor: 1.4, headshotPriority: 10 },
            groza: { aimAssistFactor: 1.08, headshotPriority: 9 }
        };
        
        return profiles[weaponType] || profiles.default;
    }
}

// ================== HEAD POSITION CALCULATOR ==================
class HeadPositionCalculator {
    calculateHeadPosition(target, gameState, positionHistory = []) {
        // Base head position
        let headHeight = this.getBaseHeadHeight(target);
        
        // Adjust for movement
        if (target.isMoving) {
            headHeight += this.getMovementHeadOffset(target.movementSpeed);
        }
        
        // Adjust for jumping
        if (target.isJumping) {
            headHeight += this.getJumpHeadOffset(target.jumpProgress);
        }
        
        // Adjust for terrain incline
        if (gameState.terrainIncline) {
            headHeight += this.getInclineHeadOffset(gameState.terrainIncline);
        }
        
        // Predict head movement pattern
        if (positionHistory.length > 5) {
            const headMovementPattern = this.analyzeHeadMovement(positionHistory);
            headHeight += headMovementPattern.verticalOffset;
        }
        
        // Apply headshot expansion
        const expansionFactor = gameState.isFiring ? 1.2 : 1.0;
        
        return {
            x: target.position.x,
            y: target.position.y + headHeight,
            z: target.position.z,
            radius: 0.35 * expansionFactor,
            visibility: this.calculateHeadVisibility(target, gameState)
        };
    }
    
    getBaseHeadHeight(target) {
        if (target.isProne) return 0.45;
        if (target.isCrouching) return 1.05;
        if (target.isCrawling) return 0.35;
        return 1.65; // Standing
    }
    
    getMovementHeadOffset(speed) {
        // Head bobbing effect when moving
        return Math.sin(Date.now() / 200) * speed * 0.05;
    }
    
    getJumpHeadOffset(jumpProgress) {
        // Parabolic jump curve
        return Math.sin(jumpProgress * Math.PI) * 1.2;
    }
    
    getInclineHeadOffset(incline) {
        // Adjust head position based on terrain
        return incline * 0.15;
    }
    
    analyzeHeadMovement(positionHistory) {
        // Calculate average vertical movement
        let verticalSum = 0;
        for (let i = 1; i < positionHistory.length; i++) {
            verticalSum += positionHistory[i].y - positionHistory[i-1].y;
        }
        
        return {
            verticalOffset: verticalSum / (positionHistory.length - 1) * 0.7
        };
    }
    
    calculateHeadVisibility(target, gameState) {
        let visibility = 1.0;
        
        // Reduce visibility when behind cover
        if (target.coverStatus === 'partial') visibility *= 0.7;
        if (target.coverStatus === 'full') visibility *= 0.3;
        
        // Reduce visibility in smoke
        if (gameState.smokeGrenades.some(smoke => 
            this.distanceTo(target.position, smoke.position) < smoke.radius
        )) {
            visibility *= 0.4;
        }
        
        return visibility;
    }
    
    distanceTo(pos1, pos2) {
        return Math.sqrt(
            Math.pow(pos2.x - pos1.x, 2) +
            Math.pow(pos2.y - pos1.y, 2) +
            Math.pow(pos2.z - pos1.z, 2)
        );
    }
}

// ================== ENHANCED TARGET DETECTOR ==================
class EnhancedTargetDetector {
    constructor() {
        this.detectionAlgorithms = {
            visual: new EnhancedVisualDetection(),
            radar: new EnhancedRadarDetection(),
            predictive: new PredictiveTargetingPro(),
            thermal: new ThermalSignatureDetection(),
            audio: new AudioSourceDetection()
        };
        this.targetConfidenceThreshold = 0.92;
        this.minDetectionSize = 8;
        this.expansionFactor = 12.5; // Headshot area expansion
        this.headDetectionAI = new HeadDetectionAI();
    }
    
    detectTargets(gameData) {
        const targets = [];
        
        // Visual detection
        if (gameData.visualData) {
            const visualTargets = this.detectionAlgorithms.visual.process(gameData.visualData);
            targets.push(...visualTargets);
        }
        
        // Radar detection
        if (gameData.radarData) {
            const radarTargets = this.detectionAlgorithms.radar.process(gameData.radarData);
            targets.push(...radarTargets);
        }
        
        // Predictive targeting
        if (gameData.gameState) {
            const predictiveTargets = this.detectionAlgorithms.predictive.findTargets(gameData);
            targets.push(...predictiveTargets);
        }
        
        // Thermal detection
        if (gameData.thermalData) {
            const thermalTargets = this.detectionAlgorithms.thermal.detect(gameData.thermalData);
            targets.push(...thermalTargets);
        }
        
        // Audio detection
        if (gameData.audioData) {
            const audioTargets = this.detectionAlgorithms.audio.locateSources(gameData.audioData);
            targets.push(...audioTargets);
        }
        
        // Filter by confidence
        const filteredTargets = targets.filter(t => t.confidence >= this.targetConfidenceThreshold);
        
        // Merge duplicates
        const mergedTargets = this.mergeTargets(filteredTargets);
        
        // Enhance target data with head detection
        return mergedTargets.map(target => 
            this.enhanceTarget(target, gameData.playerPosition)
        );
    }
    
    mergeTargets(targets) {
        const merged = [];
        const positionTolerance = 0.8;
        
        for (const target of targets) {
            let existing = null;
            let minDistance = Infinity;
            
            for (const mergedTarget of merged) {
                const distance = this.calculateDistance(
                    target.position, 
                    mergedTarget.position
                );
                
                if (distance < positionTolerance && distance < minDistance) {
                    existing = mergedTarget;
                    minDistance = distance;
                }
            }
            
            if (existing) {
                // Merge data with weighted average
                const weight = target.confidence / (existing.confidence + target.confidence);
                
                existing.confidence = Math.max(existing.confidence, target.confidence);
                existing.position = {
                    x: existing.position.x * (1-weight) + target.position.x * weight,
                    y: existing.position.y * (1-weight) + target.position.y * weight,
                    z: existing.position.z * (1-weight) + target.position.z * weight
                };
                
                // Merge additional properties
                Object.keys(target).forEach(key => {
                    if (!existing[key]) existing[key] = target[key];
                });
            } else {
                merged.push({...target});
            }
        }
        
        return merged;
    }
    
    enhanceTarget(target, playerPosition) {
        // Calculate distance
        target.distance = this.calculateDistance(target.position, playerPosition);
        
        // Calculate head position using AI
        target.headHitbox = this.headDetectionAI.detectHead(target);
        
        // Calculate threat level
        target.priority = this.calculateThreatLevel(target);
        
        return target;
    }
    
    calculateDistance(pos1, pos2) {
        return Math.sqrt(
            Math.pow(pos1.x - pos2.x, 2) +
            Math.pow(pos1.y - pos2.y, 2) +
            Math.pow(pos1.z - pos2.z, 2)
        );
    }
    
    calculateThreatLevel(target) {
        let threat = 0;
        
        // Weapon danger
        const weaponThreat = {
            sniper: 10,
            shotgun: 9,
            rifle: 8,
            smg: 7,
            pistol: 6,
            launcher: 9
        };
        
        threat += weaponThreat[target.weaponType] || 6;
        
        // Behavior danger
        if (target.isAimingAtPlayer) threat += 9;
        if (target.isShooting) threat += 7;
        
        // Proximity danger
        if (target.distance < 15) threat += 10;
        else if (target.distance < 40) threat += 7;
        else if (target.distance < 100) threat += 5;
        
        // Target priority
        if (target.isSquadLeader) threat += 8;
        if (target.isCarryingFlag) threat += 10;
        
        return threat;
    }
}

// ================== HEAD DETECTION AI ==================
class HeadDetectionAI {
    detectHead(target) {
        // Advanced head detection algorithm
        let headPosition = {
            x: target.position.x,
            y: target.position.y + this.getEstimatedHeadHeight(target),
            z: target.position.z,
            radius: 0.35
        };
        
        // Adjust for character model
        if (target.characterModel === 'heavy') {
            headPosition.y -= 0.05;
            headPosition.radius += 0.03;
        } else if (target.characterModel === 'slim') {
            headPosition.y += 0.03;
            headPosition.radius -= 0.02;
        }
        
        // Apply movement offset
        if (target.isMoving) {
            headPosition.x += Math.sin(Date.now()/300) * 0.1;
            headPosition.y += Math.cos(Date.now()/400) * 0.05;
        }
        
        return headPosition;
    }
    
    getEstimatedHeadHeight(target) {
        if (target.isProne) return 0.45;
        if (target.isCrouching) return 1.05;
        if (target.isCrawling) return 0.35;
        if (target.isJumping) return 1.85;
        return 1.65; // Standing
    }
}

// ================== ADVANCED AUTO AIM SYSTEM ==================
class AdvancedAutoAimSystem {
    constructor() {
        this.baseLockSpeed = 0.18;
        this.instantLockSpeed = 0.45; // 250% faster
        this.maxLockTime = 0.4;
        this.lockThreshold = 0.96;
        this.smoothingFactor = 0.92;
        this.headshotPriority = 12;
        this.maxAimHeight = 1.85;
        this.minHeadDistance = 0.05;
        this.instantLockMode = false;
        this.headLockOnly = true; // Only lock to head area
    }
    
    acquireTarget(target, currentAimPos, playerPos, weaponType, gameState, instantLock = false, distanceFactors) {
        this.instantLockMode = instantLock;
        
        // Calculate perfect aim position
        const perfectAim = this.calculatePerfectAim(target, playerPos, weaponType, gameState);
        
        // Move aim to target
        const newAimPos = this.moveAimToTarget(
            currentAimPos, 
            perfectAim, 
            gameState, 
            target,
            distanceFactors
        );
        
        // Calculate lock strength
        const lockStrength = this.calculateLockStrength(newAimPos, perfectAim, target);
        
        return {
            position: newAimPos,
            lockStrength: lockStrength,
            headPosition: perfectAim
        };
    }
    
    calculatePerfectAim(target, playerPos, weaponType, gameState) {
        const basePos = target.headHitbox;
        const travelTime = this.calculateBulletTravelTime(playerPos, basePos, weaponType);
        const predictedMovement = this.predictMovement(target, travelTime, gameState);
        
        return {
            x: basePos.x + predictedMovement.x,
            y: basePos.y + predictedMovement.y,
            z: basePos.z + predictedMovement.z,
            radius: basePos.radius
        };
    }
    
    calculateBulletTravelTime(startPos, endPos, weaponType) {
        const distance = Math.sqrt(
            Math.pow(endPos.x - startPos.x, 2) +
            Math.pow(endPos.y - startPos.y, 2) +
            Math.pow(endPos.z - startPos.z, 2)
        );
        
        const weaponProfile = this.getWeaponProfile(weaponType);
        return distance / weaponProfile.bulletVelocity;
    }
    
    predictMovement(target, time, gameState) {
        // Predict based on current velocity and environment
        let movementMultiplier = 1.0;
        
        // Adjust for terrain
        if (gameState.terrainType === 'mud') movementMultiplier *= 0.8;
        if (gameState.terrainType === 'sand') movementMultiplier *= 0.85;
        
        // Predict movement with environmental factors
        return {
            x: target.movement.x * time * 1.3 * movementMultiplier,
            y: target.movement.y * time * 1.3,
            z: target.movement.z * time * 0.95 * movementMultiplier
        };
    }
    
    moveAimToTarget(currentPos, targetPos, gameState, target, distanceFactors) {
        // Calculate move speed based on mode and distance factors
        let moveSpeed = this.instantLockMode ? 
            this.instantLockSpeed : 
            this.baseLockSpeed * distanceFactors.aimSpeed;
        
        // Distance based adjustments
        const distance = Math.sqrt(
            Math.pow(targetPos.x - currentPos.x, 2) +
            Math.pow(targetPos.y - currentPos.y, 2)
        );
        
        // Head-only lock: force aim to head area
        if (this.headLockOnly) {
            const headCenter = {
                x: target.headHitbox.x,
                y: target.headHitbox.y,
                z: target.headHitbox.z
            };
            
            // If we're already near head, use finer adjustments
            if (distance < target.headHitbox.radius * 3) {
                moveSpeed *= 1.5;
                return this.adjustToHeadCenter(currentPos, headCenter, moveSpeed);
            }
        }
        
        // Direction vector
        const direction = {
            x: targetPos.x - currentPos.x,
            y: targetPos.y - currentPos.y,
            z: targetPos.z - currentPos.z
        };
        
        // Apply distance-based smoothing
        const smoothing = this.smoothingFactor * (1 + (1 - distanceFactors.recoilFactor)/2);
        
        // Apply movement
        const newPos = {
            x: currentPos.x + direction.x * moveSpeed * smoothing,
            y: currentPos.y + direction.y * moveSpeed * smoothing,
            z: currentPos.z + direction.z * moveSpeed * smoothing * 0.97
        };
        
        // Prevent head overshoot
        const maxY = target.position.y + this.maxAimHeight;
        if (newPos.y > maxY) {
            newPos.y = maxY;
        }
        
        // For instant lock, snap directly to head center when close
        if (this.instantLockMode && distance < target.headHitbox.radius * 4) {
            return {
                x: target.headHitbox.x,
                y: target.headHitbox.y,
                z: target.headHitbox.z
            };
        }
        
        return newPos;
    }
    
    adjustToHeadCenter(currentPos, headCenter, moveSpeed) {
        const direction = {
            x: headCenter.x - currentPos.x,
            y: headCenter.y - currentPos.y,
            z: headCenter.z - currentPos.z
        };
        
        return {
            x: currentPos.x + direction.x * moveSpeed,
            y: currentPos.y + direction.y * moveSpeed,
            z: currentPos.z + direction.z * moveSpeed * 0.95
        };
    }
    
    calculateLockStrength(aimPos, targetPos, target) {
        const distance = Math.sqrt(
            Math.pow(aimPos.x - targetPos.x, 2) +
            Math.pow(aimPos.y - targetPos.y, 2)
        );
        
        const maxDistance = target.headHitbox.radius * 2.5;
        return Math.max(0, 1 - (distance / maxDistance));
    }
    
    getWeaponProfile(weaponType) {
        const profiles = {
            default: { bulletVelocity: 380 },
            sniper: { bulletVelocity: 980 },
            ak47: { bulletVelocity: 370 },
            m4a1: { bulletVelocity: 410 },
            shotgun: { bulletVelocity: 320 },
            awm: { bulletVelocity: 1020 },
            groza: { bulletVelocity: 390 }
        };
        
        return profiles[weaponType] || profiles.default;
    }
}

// ================== HEADSHOT OPTIMIZER ==================
class HeadshotOptimizer {
    optimizeForHeadshot(gameData, target, predictor) {
        // Ensure bullet trajectory is head-bound
        const headCenter = {
            x: target.headHitbox.x,
            y: target.headHitbox.y,
            z: target.headHitbox.z
        };
        
        // Calculate vector to head center
        const currentVector = {
            x: gameData.bulletTrajectory.end.x - gameData.playerPosition.x,
            y: gameData.bulletTrajectory.end.y - gameData.playerPosition.y,
            z: gameData.bulletTrajectory.end.z - gameData.playerPosition.z
        };
        
        const headVector = {
            x: headCenter.x - gameData.playerPosition.x,
            y: headCenter.y - gameData.playerPosition.y,
            z: headCenter.z - gameData.playerPosition.z
        };
        
        // Calculate angle difference
        const angleDiff = this.calculateAngleDifference(currentVector, headVector);
        
        // If we're off target, adjust trajectory
        if (angleDiff > 0.05) {
            const adjustmentFactor = Math.min(1, angleDiff * 2);
            gameData.bulletTrajectory.end = {
                x: gameData.bulletTrajectory.end.x * (1-adjustmentFactor) + headCenter.x * adjustmentFactor,
                y: gameData.bulletTrajectory.end.y * (1-adjustmentFactor) + headCenter.y * adjustmentFactor,
                z: gameData.bulletTrajectory.end.z * (1-adjustmentFactor) + headCenter.z * adjustmentFactor
            };
        }
        
        // Predict micro-movements
        const microMovement = predictor.predictMicroMovement(target, gameData.bulletTrajectory.travelTime);
        gameData.bulletTrajectory.end.x += microMovement.x;
        gameData.bulletTrajectory.end.y += microMovement.y;
        
        // Final guarantee
        gameData.bulletTrajectory.end = this.guaranteeHeadshot(
            gameData.bulletTrajectory.end,
            target.headHitbox
        );
    }
    
    calculateAngleDifference(vec1, vec2) {
        const dot = vec1.x*vec2.x + vec1.y*vec2.y + vec1.z*vec2.z;
        const mag1 = Math.sqrt(vec1.x*vec1.x + vec1.y*vec1.y + vec1.z*vec1.z);
        const mag2 = Math.sqrt(vec2.x*vec2.x + vec2.y*vec2.y + vec2.z*vec2.z);
        
        return Math.acos(dot / (mag1 * mag2));
    }
    
    guaranteeHeadshot(point, head) {
        const distance = Math.sqrt(
            Math.pow(point.x - head.x, 2) +
            Math.pow(point.y - head.y, 2)
        );
        
        if (distance <= head.radius) {
            return point;
        }
        
        const angle = Math.atan2(point.y - head.y, point.x - head.x);
        return {
            x: head.x + Math.cos(angle) * head.radius * 0.85,
            y: head.y + Math.sin(angle) * head.radius * 0.85,
            z: head.z
        };
    }
}

// ================== PRECISION BULLET TRACKER ==================
class PrecisionBulletTracker {
    calculateGuaranteedTrajectory(startPos, aimPos, target, weaponType, gameState, guarantor, distanceFactors) {
        // Calculate travel time with distance factor
        const travelTime = this.calculateBulletTravelTime(startPos, aimPos, weaponType) * distanceFactors.recoilFactor;
        
        // Predict target position at impact
        const predictedPos = this.predictFuturePosition(target, travelTime);
        
        // Get guaranteed hit position
        const guaranteedHitPos = guarantor.guaranteeHeadshot(
            startPos,
            predictedPos,
            target,
            weaponType,
            gameState
        );
        
        return {
            start: startPos,
            end: guaranteedHitPos,
            travelTime: travelTime,
            guaranteedHit: true,
            headshotProbability: 0.999
        };
    }
    
    calculateBulletTravelTime(startPos, endPos, weaponType) {
        const distance = Math.sqrt(
            Math.pow(endPos.x - startPos.x, 2) +
            Math.pow(endPos.y - startPos.y, 2) +
            Math.pow(endPos.z - startPos.z, 2)
        );
        
        const weaponProfile = this.getWeaponProfile(weaponType);
        return distance / weaponProfile.bulletVelocity;
    }
    
    predictFuturePosition(target, time) {
        // Base prediction
        let predictedPos = {
            x: target.position.x + target.movement.x * time,
            y: target.position.y + target.movement.y * time,
            z: target.position.z + target.movement.z * time
        };
        
        // Add movement randomness simulation
        if (target.isMovingErratically) {
            predictedPos.x += (Math.random() - 0.5) * 0.3;
            predictedPos.y += (Math.random() - 0.5) * 0.1;
        }
        
        return predictedPos;
    }
    
    getWeaponProfile(weaponType) {
        // Same as in AutoAimSystem
    }
}

// ================== ENHANCED TARGET PREDICTOR ==================
class EnhancedTargetPredictor {
    constructor() {
        this.predictionModels = {
            linear: new LinearPredictionModelPro(),
            erratic: new ErraticPredictionModelPro(),
            jumping: new JumpPredictionModelPro(),
            strafing: new StrafingPredictionModel(),
            falling: new FallingPredictionModel()
        };
        this.movementHistory = new Map();
        this.maxHistorySize = 25;
        this.predictionAccuracy = 0.97;
        this.microPrediction = new MicroMovementPredictor();
    }
    
    predictNextPosition(target, timeAhead, history = []) {
        // Get movement history
        const targetHistory = this.getMovementHistory(target.id, history);
        
        // Update with current position
        this.updateHistory(target, targetHistory);
        
        // Select prediction model
        const modelType = this.determineMovementPattern(target, targetHistory);
        const predictionModel = this.predictionModels[modelType];
        
        // Generate prediction
        return predictionModel.predict(target, targetHistory, timeAhead);
    }
    
    predictMicroMovement(target, timeAhead) {
        return this.microPrediction.predict(target, timeAhead);
    }
    
    getMovementHistory(targetId, externalHistory) {
        if (externalHistory && externalHistory.length > 0) {
            if (!this.movementHistory.has(targetId)) {
                this.movementHistory.set(targetId, {
                    positions: [],
                    timestamps: [],
                    velocities: []
                });
            }
            
            const history = this.movementHistory.get(targetId);
            externalHistory.forEach(pos => {
                history.positions.push({...pos.position});
                history.timestamps.push(pos.timestamp);
            });
            return history;
        }
        
        if (!this.movementHistory.has(targetId)) {
            this.movementHistory.set(targetId, {
                positions: [],
                timestamps: [],
                velocities: []
            });
        }
        return this.movementHistory.get(targetId);
    }
    
    updateHistory(target, history) {
        const currentTime = Date.now();
        
        // Add current position
        history.positions.push({...target.position});
        history.timestamps.push(currentTime);
        
        // Calculate velocity if possible
        if (history.positions.length > 1) {
            const lastPos = history.positions[history.positions.length - 2];
            const currentPos = history.positions[history.positions.length - 1];
            const timeDiff = (history.timestamps[history.timestamps.length - 1] - 
                             history.timestamps[history.timestamps.length - 2]) / 1000;
            
            if (timeDiff > 0) {
                const velocity = {
                    x: (currentPos.x - lastPos.x) / timeDiff,
                    y: (currentPos.y - lastPos.y) / timeDiff,
                    z: (currentPos.z - lastPos.z) / timeDiff
                };
                history.velocities.push(velocity);
            }
        }
        
        // Limit history size
        if (history.positions.length > this.maxHistorySize) {
            history.positions.shift();
            history.timestamps.shift();
            if (history.velocities.length > 0) history.velocities.shift();
        }
    }
    
    determineMovementPattern(target, history) {
        if (history.velocities.length < 3) return 'linear';
        
        // Calculate direction changes
        let directionChanges = 0;
        let verticalChanges = 0;
        for (let i = 1; i < history.velocities.length; i++) {
            const prev = history.velocities[i-1];
            const curr = history.velocities[i];
            
            // Horizontal direction change
            const angleChange = Math.abs(
                Math.atan2(curr.y, curr.x) - Math.atan2(prev.y, prev.x)
            );
            if (angleChange > 0.5) directionChanges++;
            
            // Vertical direction change
            if (Math.sign(prev.y) !== Math.sign(curr.y)) verticalChanges++;
        }
        
        const changeRatio = directionChanges / history.velocities.length;
        const verticalChangeRatio = verticalChanges / history.velocities.length;
        
        if (target.isFalling) return 'falling';
        if (target.isJumping) return 'jumping';
        if (target.isStrafing) return 'strafing';
        if (changeRatio > 0.5) return 'erratic';
        if (verticalChangeRatio > 0.3) return 'jumping';
        return 'linear';
    }
}

// ================== MICRO MOVEMENT PREDICTOR ==================
class MicroMovementPredictor {
    predict(target, timeAhead) {
        // Simulate small unpredictable movements
        return {
            x: (Math.random() - 0.5) * 0.15 * timeAhead,
            y: (Math.random() - 0.5) * 0.08 * timeAhead
        };
    }
}

// ================== ADVANCED RECOIL COMPENSATOR ==================
class AdvancedRecoilCompensator {
    constructor() {
        this.recoilPatterns = {
            default: { vertical: 0.09, horizontal: 0.025 },
            sniper: { vertical: 0.22, horizontal: 0.008 },
            ak47: { vertical: 0.14, horizontal: 0.048 },
            m4a1: { vertical: 0.11, horizontal: 0.035 },
            shotgun: { vertical: 0.16, horizontal: 0.065 },
            awm: { vertical: 0.24, horizontal: 0.006 },
            groza: { vertical: 0.13, horizontal: 0.042 }
        };
        this.compensationFactors = {
            vertical: 0.92,
            horizontal: 0.82
        };
        this.learnRate = 0.88;
        this.distanceFactors = {
            close: { vertical: 0.7, horizontal: 0.8 },
            medium: { vertical: 0.9, horizontal: 0.9 },
            long: { vertical: 1.0, horizontal: 1.0 }
        };
    }
    
    compensate(aimPosition, weaponType, recoilData, distance) {
        // Get recoil pattern for weapon
        const pattern = this.getRecoilPattern(weaponType);
        
        // Update pattern based on actual data
        this.updatePattern(weaponType, recoilData);
        
        // Get distance-based factors
        const distFactors = this.getDistanceFactors(distance);
        
        // Calculate compensation
        const compensation = {
            x: pattern.horizontal * this.compensationFactors.horizontal * distFactors.horizontal,
            y: pattern.vertical * this.compensationFactors.vertical * distFactors.vertical,
            z: 0
        };
        
        // Apply compensation
        return {
            x: aimPosition.x - compensation.x,
            y: aimPosition.y - compensation.y,
            z: aimPosition.z - compensation.z
        };
    }
    
    getRecoilPattern(weaponType) {
        return this.recoilPatterns[weaponType] || this.recoilPatterns.default;
    }
    
    updatePattern(weaponType, newPattern) {
        if (!newPattern) return;
        
        const currentPattern = this.getRecoilPattern(weaponType);
        
        // Update pattern with learning rate
        const updatedPattern = {
            vertical: currentPattern.vertical * (1 - this.learnRate) + newPattern.vertical * this.learnRate,
            horizontal: currentPattern.horizontal * (1 - this.learnRate) + newPattern.horizontal * this.learnRate
        };
        
        this.recoilPatterns[weaponType] = updatedPattern;
    }
    
    getDistanceFactors(distance) {
        if (distance < 30) return this.distanceFactors.close;
        if (distance < 80) return this.distanceFactors.medium;
        return this.distanceFactors.long;
    }
}

// ================== POSITION TRACKER ==================
class PositionTracker {
    constructor() {
        this.positionHistory = new Map();
        this.maxHistory = 50;
    }
    
    updatePositions(targets) {
        const currentTime = Date.now();
        
        for (const target of targets) {
            if (!this.positionHistory.has(target.id)) {
                this.positionHistory.set(target.id, []);
            }
            
            const history = this.positionHistory.get(target.id);
            history.push({
                position: {...target.position},
                timestamp: currentTime,
                headPosition: target.headHitbox ? {...target.headHitbox} : null
            });
            
            // Limit history size
            if (history.length > this.maxHistory) {
                history.shift();
            }
        }
    }
    
    getHistory(targetId) {
        return this.positionHistory.get(targetId) || [];
    }
}

// ================== AIM STABILIZER ==================
class AimStabilizer {
    constructor() {
        this.smoothingFactor = 0.94;
        this.distanceFactors = {
            close: 0.85,
            medium: 0.92,
            long: 0.97
        };
    }
    
    stabilizeAim(newPosition, currentPosition, distance, isMoving) {
        let smoothing = this.smoothingFactor;
        
        // Adjust based on distance
        if (distance < 30) smoothing *= this.distanceFactors.close;
        else if (distance < 80) smoothing *= this.distanceFactors.medium;
        else smoothing *= this.distanceFactors.long;
        
        // Adjust if player is moving
        if (isMoving) smoothing *= 0.9;
        
        return {
            x: currentPosition.x * (1-smoothing) + newPosition.x * smoothing,
            y: currentPosition.y * (1-smoothing) + newPosition.y * smoothing,
            z: currentPosition.z * (1-smoothing) + newPosition.z * smoothing
        };
    }
}

// ================== THREAT EVALUATOR ==================
class ThreatEvaluator {
    calculateThreatScore(target, playerHealth, gameState) {
        let score = 0;
        
        // Distance factor (closer = more dangerous)
        score += (200 - Math.min(200, target.distance)) * 0.85;
        
        // Aiming at player
        if (target.isAimingAtPlayer) score += 80;
        
        // Low health target (more aggressive)
        if (target.health < 30) score += 55;
        
        // Weapon threat level
        const weaponThreat = {
            sniper: 95,
            shotgun: 90,
            rifle: 80,
            smg: 75,
            pistol: 65,
            awm: 100,
            groza: 85
        };
        score += weaponThreat[target.weaponType] || 70;
        
        // Movement threat
        if (target.movementSpeed > 5) score += 40; // Fast moving target
        if (target.isStrafing) score += 30;
        
        // Critical player health
        if (playerHealth < 30) {
            score += (100 - target.distance) * 1.7;
        }
        
        // Special conditions
        if (gameState.isFinalZone) score += 50;
        if (target.isSquadLeader) score += 40;
        
        return score;
    }
}

// ... (Các class nâng cao khác như EnhancedVisualDetection, EliteStealthModule, 
//      TacticalCombatAnalyzer, InstantTriggerResponseSystem, HeadshotGuarantorPro, 
//      ThermalSignatureDetection, AudioSourceDetection, PredictiveTargetingPro, 
//      SmartAimLockController, AdaptivePerformanceOptimizer, và các mô hình dự đoán nâng cao)

// ================== INITIALIZATION ==================
const aimSystem = new UltimateHeadshotSystem();
$done({ body: aimSystem.process($response.body) });
