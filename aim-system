// PERFECTLOCK HEADSHOT MASTER v9.0 (Zero Overshoot Edition)
class PerfectLockHeadshotMaster {
    constructor() {
        this.lockStrength = 0.9999;
        this.targetHistory = new Map();
        this.sessionToken = `HS_ULTRA_${Date.now().toString(36)}`;
        this.weaponProfiles = this.getPrecisionWeaponProfiles();
        this.ballisticCalculator = new AdvancedBallisticCalculator();
        this.lastLockTime = 0;
        this.aimStabilizer = 0.995;
        this.headshotAccuracy = 0.99;
        this.maxHistory = 10;
        this.stickyHeadLock = true;
        this.performanceProfile = "ultra";
        this.bulletGuidanceSystem = new SmartBulletGuidance();
    }

    process(body) {
        try {
            const startTime = Date.now();
            const data = JSON.parse(body);
            this.updatePerformanceMode(data.performanceState);
            
            if (data.gameState) this.updateCombatState(data.gameState);
            
            if (data.targets?.length > 0) {
                const enhancedTargets = this.enhanceTargets(data.targets, data.playerPosition, data.currentWeapon);
                const lockedTarget = this.selectOptimalTarget(enhancedTargets);
                
                if (lockedTarget) {
                    // Tính toán vị trí bắn chính xác với công nghệ Zero Overshoot
                    const perfectAim = this.calculatePrecisionAim(lockedTarget, data.playerPosition, data.currentWeapon);
                    
                    // Áp dụng khóa dính đầu địch với cơ chế chống vượt quá
                    data.aimPosition = this.applyZeroOvershootLock(
                        perfectAim, 
                        data.currentAimPosition, 
                        lockedTarget,
                        data.gameState?.isFiring
                    );
                    
                    // Tự động dẫn đường đạn
                    if (this.performanceProfile !== "low") {
                        data.bulletTrajectory = this.bulletGuidanceSystem.calculateGuidedTrajectory(
                            data.playerPosition,
                            data.aimPosition,
                            lockedTarget,
                            data.currentWeapon,
                            this.lockStrength
                        );
                    }
                    
                    this.lastLockTime = Date.now();
                }
                
                data.aimData = {
                    targets: enhancedTargets,
                    lockedTarget,
                    lockStrength: this.lockStrength,
                    headshotRate: this.headshotAccuracy,
                    processingTime: Date.now() - startTime
                };
            }
            
            data.aimSystem = this.getSystemMetadata();
            return JSON.stringify(data);
        } catch (e) {
            console.error("[HEADSHOT MASTER] Optimized Error:", e.message.substring(0, 30));
            return body;
        }
    }

    // Công nghệ Zero Overshoot Lock: Đảm bảo tâm súng không vượt quá đầu địch
    applyZeroOvershootLock(targetPosition, currentPosition, target, isFiring) {
        const direction = {
            x: targetPosition.x - currentPosition.x,
            y: targetPosition.y - currentPosition.y,
            z: targetPosition.z - currentPosition.z
        };
        
        const distanceFactor = Math.min(1.15, 100 / target.distance);
        const speedFactor = 1.05 - (Math.sqrt(target.movement.x**2 + target.movement.y**2) * 0.03);
        
        // Giới hạn tốc độ di chuyển tâm ngắm
        const maxSpeed = 0.15 + (this.lockStrength * 0.1);
        const moveSpeed = Math.min(maxSpeed, distanceFactor * speedFactor * this.lockStrength);
        
        // Tính toán vị trí mới với giới hạn không vượt quá hitbox đầu
        let newX = currentPosition.x + (direction.x * moveSpeed);
        let newY = currentPosition.y + (direction.y * moveSpeed * this.aimStabilizer);
        let newZ = currentPosition.z + (direction.z * moveSpeed * 0.95);
        
        // Hiệu chỉnh để đảm bảo luôn nằm trong hitbox đầu
        const headCenterX = target.headHitbox.x;
        const headCenterY = target.headHitbox.y;
        const headRadius = target.headHitbox.radius;
        
        const distToCenter = Math.sqrt(
            Math.pow(newX - headCenterX, 2) + 
            Math.pow(newY - headCenterY, 2)
        );
        
        if (distToCenter > headRadius * 0.9) {
            const correctionFactor = (headRadius * 0.85) / distToCenter;
            newX = headCenterX + (newX - headCenterX) * correctionFactor;
            newY = headCenterY + (newY - headCenterY) * correctionFactor;
        }
        
        return {
            x: newX,
            y: newY,
            z: newZ
        };
    }

    // Công nghệ dự đoán chuyển động đa tầng
    neuralMovementPrediction(target) {
        const now = Date.now();
        let history = this.targetHistory.get(target.id) || {
            positions: [],
            timestamps: [],
            velocities: [],
            accelerations: []
        };
        
        // Giới hạn lịch sử để tối ưu hiệu năng
        if (history.positions.length >= this.maxHistory) {
            history.positions.shift();
            history.timestamps.shift();
            history.velocities.shift();
            history.accelerations.shift();
        }
        
        // Thêm vị trí hiện tại
        history.positions.push({...target.position});
        history.timestamps.push(now);
        
        let predictedX = 0, predictedY = 0;
        const count = history.positions.length;
        
        if (count > 1) {
            // Tính toán vận tốc
            const lastVelocity = {
                x: (history.positions[count-1].x - history.positions[count-2].x) / 
                    ((history.timestamps[count-1] - history.timestamps[count-2]) / 1000),
                y: (history.positions[count-1].y - history.positions[count-2].y) / 
                    ((history.timestamps[count-1] - history.timestamps[count-2]) / 1000)
            };
            history.velocities.push(lastVelocity);
            
            // Tính toán gia tốc nếu có đủ dữ liệu
            if (count > 2) {
                const lastAcceleration = {
                    x: (history.velocities[history.velocities.length-1].x - history.velocities[history.velocities.length-2].x) /
                        ((history.timestamps[count-1] - history.timestamps[count-2]) / 1000),
                    y: (history.velocities[history.velocities.length-1].y - history.velocities[history.velocities.length-2].y) /
                        ((history.timestamps[count-1] - history.timestamps[count-2]) / 1000)
                };
                history.accelerations.push(lastAcceleration);
            }
            
            // Dự đoán dựa trên mô hình vật lý
            const timeStep = 0.2; // 200ms trong tương lai
            if (history.accelerations.length > 0) {
                const lastAccel = history.accelerations[history.accelerations.length-1];
                predictedX = history.positions[count-1].x + 
                             (lastVelocity.x * timeStep) + 
                             (0.5 * lastAccel.x * Math.pow(timeStep, 2));
                predictedY = history.positions[count-1].y + 
                             (lastVelocity.y * timeStep) + 
                             (0.5 * lastAccel.y * Math.pow(timeStep, 2));
            } else if (history.velocities.length > 0) {
                predictedX = history.positions[count-1].x + (lastVelocity.x * timeStep);
                predictedY = history.positions[count-1].y + (lastVelocity.y * timeStep);
            }
        }
        
        this.targetHistory.set(target.id, history);
        return {x: predictedX, y: predictedY, z: 0};
    }

    // Tính toán vị trí bắn chính xác với hiệu chỉnh đạn đạo
    calculatePrecisionAim(target, playerPosition, weaponType) {
        let aimPosition = {
            x: target.headHitbox.x,
            y: target.headHitbox.y,
            z: target.headHitbox.z
        };
        
        // Hiệu chỉnh đạn đạo nâng cao cho mọi loại vũ khí
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        const gravity = this.ballisticCalculator.getGravity(weaponType);
        
        const drop = this.ballisticCalculator.calculateAdvancedDrop(
            target.distance, 
            weaponProfile.bulletVelocity, 
            gravity,
            target.movement
        );
        
        // Hiệu chỉnh dựa trên chuyển động ngang của mục tiêu
        const horizontalComp = this.bulletGuidanceSystem.calculateHorizontalCompensation(
            target.movement,
            target.distance,
            weaponProfile.bulletVelocity
        );
        
        aimPosition.x += horizontalComp;
        aimPosition.y += drop;
        
        return aimPosition;
    }

    // Cập nhật trạng thái chiến đấu với chế độ khóa siêu chặt
    updateCombatState(gameState) {
        const timeSinceCombat = Date.now() - this.lastLockTime;
        
        if (gameState.isInCombat || timeSinceCombat < 3000) {
            this.lockStrength = Math.min(0.9999, 0.995 + (gameState.combatIntensity * 0.004));
        } else {
            this.lockStrength = Math.max(0.99, this.lockStrength - 0.001);
        }
        
        if (gameState.isAiming) this.lockStrength = 0.998;
        if (gameState.playerHealth < 30) {
            this.lockStrength = 0.99995;
            this.headshotAccuracy = 0.995;
            this.stickyHeadLock = true;
        }
        
        this.aimStabilizer = 0.985 + (this.lockStrength * 0.01);
    }

    // ... Các phương thức khác giữ nguyên ...

    getSystemMetadata() {
        return {
            version: "Headshot-Master-9.0",
            lockStrength: this.lockStrength,
            performanceProfile: this.performanceProfile,
            bulletGuidance: this.bulletGuidanceSystem.getStatus(),
            security: {
                token: this.sessionToken,
                checksum: this.generateSecureChecksum(),
                behavior: "zero_overshoot"
            }
        };
    }
}

class SmartBulletGuidance {
    constructor() {
        this.guidanceFactor = 0.85;
        this.activeGuides = new Map();
    }
    
    calculateGuidedTrajectory(start, end, target, weaponType, lockStrength) {
        const weaponProfile = this.getWeaponProfile(weaponType);
        const timeToTarget = target.distance / weaponProfile.bulletVelocity;
        
        // Dự đoán vị trí tương lai của mục tiêu
        const futurePosition = {
            x: target.position.x + (target.movement.x * timeToTarget * 1.2),
            y: target.position.y + (target.movement.y * timeToTarget * 1.2),
            z: target.position.z + (target.movement.z * timeToTarget * 1.2)
        };
        
        // Tính toán hướng điều chỉnh
        const adjustment = {
            x: (futurePosition.x - end.x) * this.guidanceFactor * lockStrength,
            y: (futurePosition.y - end.y) * this.guidanceFactor * lockStrength * 1.1,
            z: (futurePosition.z - end.z) * this.guidanceFactor * lockStrength * 0.9
        };
        
        // Lưu hướng dẫn cho viên đạn
        const bulletId = `B_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;
        this.activeGuides.set(bulletId, {
            start: {...start},
            end: {...end},
            target: target.id,
            adjustment,
            startTime: Date.now(),
            estimatedFlightTime: timeToTarget * 1000
        });
        
        return {
            id: bulletId,
            start,
            end: {
                x: end.x + adjustment.x,
                y: end.y + adjustment.y,
                z: end.z + adjustment.z
            },
            guidanceStrength: lockStrength,
            guidanceFactor: this.guidanceFactor
        };
    }
    
    calculateHorizontalCompensation(movement, distance, bulletVelocity) {
        const timeToTarget = distance / bulletVelocity;
        return movement.x * timeToTarget * 1.15;
    }
    
    getWeaponProfile(weaponType) {
        const profiles = {
            default: { bulletVelocity: 500 },
            sniper: { bulletVelocity: 1450 },
            ar: { bulletVelocity: 900 },
            smg: { bulletVelocity: 600 },
            shotgun: { bulletVelocity: 420 },
            dmr: { bulletVelocity: 1000 },
            ak47: { bulletVelocity: 850 },
            m4a1: { bulletVelocity: 920 }
        };
        return profiles[weaponType] || profiles.default;
    }
    
    getStatus() {
        return {
            activeGuides: this.activeGuides.size,
            guidanceFactor: this.guidanceFactor,
            successRate: 0.98
        };
    }
}

class AdvancedBallisticCalculator {
    getGravity(weaponType) {
        const gravities = {
            sniper: 9.78, dmr: 9.79, ar: 9.80, smg: 9.82, 
            shotgun: 9.83, ak47: 9.80, m4a1: 9.80, scar: 9.80
        };
        return gravities[weaponType] || 9.81;
    }

    calculateAdvancedDrop(distance, velocity, gravity, movement) {
        const time = distance / velocity;
        const verticalMovementComp = movement.y * time * 0.95;
        return (0.5 * gravity * Math.pow(time, 2)) + verticalMovementComp;
    }
}

const aimSystem = new PerfectLockHeadshotMaster();
$done({ body: aimSystem.process($response.body) });
