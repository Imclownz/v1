// PERFECT BALLISTIC HEADSHOT MASTER v9.0
class PerfectBallisticHeadshotMaster {
    constructor() {
        this.lockStrength = 0.9999;
        this.targetHistory = new Map();
        this.sessionToken = `PBHS_ULTRA_${Date.now().toString(36)}`;
        this.weaponProfiles = this.getPrecisionWeaponProfiles();
        this.ballisticCalculator = new AdvancedBallisticCalculator();
        this.lastLockTime = 0;
        this.aimPredictionLevel = 7;
        this.aimStabilizer = 0.995;
        this.headshotAccuracy = 0.99;
        this.maxHistory = 10;
        this.softLockZone = 0.3;
        this.stickyHeadLock = true;
        this.bulletStabilization = true;
        this.neuralPrediction = new NeuralMovementPredictor();
    }

    process(body) {
        try {
            const startTime = Date.now();
            const data = JSON.parse(body);
            this.updatePerformanceMode(data.performanceState);
            
            if (data.gameState) this.updateCombatState(data.gameState);
            
            if (data.targets?.length > 0) {
                const enhancedTargets = this.enhanceTargets(data.targets, data.playerPosition, data.currentWeapon);
                const lockedTarget = this.selectOptimalTarget(enhancedTargets);
                
                if (lockedTarget) {
                    // Tính toán vị trí bắn chính xác với hiệu chỉnh đường đạn
                    const perfectAim = this.calculatePrecisionAim(lockedTarget, data.playerPosition, data.currentWeapon);
                    
                    // Áp dụng khóa mềm và khóa dính
                    data.aimPosition = this.applySoftStickyLock(
                        perfectAim, 
                        data.currentAimPosition, 
                        lockedTarget,
                        data.gameState?.isFiring
                    );
                    
                    // Ổn định đường đạn
                    if (this.bulletStabilization) {
                        data.bulletTrajectory = this.calculateStabilizedTrajectory(
                            data.playerPosition,
                            data.aimPosition,
                            lockedTarget,
                            data.currentWeapon
                        );
                    }
                    
                    this.lastLockTime = Date.now();
                }
                
                data.aimData = {
                    targets: enhancedTargets,
                    lockedTarget,
                    lockStrength: this.lockStrength,
                    predictionLevel: this.aimPredictionLevel,
                    headshotRate: this.headshotAccuracy,
                    processingTime: Date.now() - startTime,
                    bulletStabilized: this.bulletStabilization
                };
            }
            
            data.aimSystem = this.getSystemMetadata();
            return JSON.stringify(data);
        } catch (e) {
            console.error("[BALLISTIC MASTER] Error:", e.message.substring(0, 30));
            return body;
        }
    }

    applySoftStickyLock(targetPosition, currentPosition, target, isFiring) {
        const direction = {
            x: targetPosition.x - currentPosition.x,
            y: targetPosition.y - currentPosition.y,
            z: targetPosition.z - currentPosition.z
        };
        
        const distance = target.distance;
        const distanceFactor = Math.min(1.25, 150 / distance);
        
        // Tính toán vùng khóa mềm (làm chậm tốc độ khi gần đầu địch)
        const softLockFactor = this.calculateSoftLockFactor(distance, direction);
        
        // Tính toán hệ số khóa dính
        const speedFactor = 1.05 - (Math.sqrt(target.movement.x**2 + target.movement.y**2) * 0.04);
        const stickyFactor = this.stickyHeadLock ? 0.94 : 0.85;
        
        return {
            x: currentPosition.x + (direction.x * distanceFactor * speedFactor * stickyFactor * softLockFactor),
            y: currentPosition.y + (direction.y * distanceFactor * speedFactor * stickyFactor * this.aimStabilizer * softLockFactor),
            z: currentPosition.z + (direction.z * distanceFactor * speedFactor * stickyFactor * 0.97 * softLockFactor)
        };
    }

    calculateSoftLockFactor(distance, direction) {
        // Tính khoảng cách đến mục tiêu
        const distToTarget = Math.sqrt(direction.x**2 + direction.y**2 + direction.z**2);
        
        // Vùng khóa mềm: 20% khoảng cách cuối cùng
        const softLockDistance = distToTarget * this.softLockZone;
        const currentDistance = Math.min(distToTarget, softLockDistance);
        
        // Hệ số giảm tốc khi đến gần mục tiêu (càng gần càng chậm)
        return 0.3 + (0.7 * (currentDistance / softLockDistance));
    }

    calculatePrecisionAim(target, playerPosition, weaponType) {
        // Tính toán vị trí đầu chính xác với dự đoán neural
        const predictedHeadPosition = this.neuralPrediction.predictHeadPosition(
            target, 
            this.weaponProfiles[weaponType]?.bulletVelocity || 500
        );
        
        let aimPosition = {
            x: predictedHeadPosition.x,
            y: predictedHeadPosition.y,
            z: predictedHeadPosition.z
        };
        
        // Hiệu chỉnh đạn đạo cho mọi loại súng
        if (this.weaponProfiles[weaponType]) {
            const gravity = this.ballisticCalculator.getGravity(weaponType);
            const drop = this.ballisticCalculator.calculateAdvancedDrop(
                target.distance, 
                this.weaponProfiles[weaponType].bulletVelocity, 
                gravity,
                target.movement
            );
            aimPosition.y += drop;
        }
        
        // Hiệu chỉnh cuối cùng để đạn luôn đi thẳng vào đầu
        aimPosition = this.finalHeadPositionAdjustment(aimPosition, target);
        
        return aimPosition;
    }

    finalHeadPositionAdjustment(aimPosition, target) {
        // Đảm bảo không vượt quá đầu địch
        const headRadius = target.headHitbox.radius;
        const maxAdjustment = headRadius * 0.8;
        
        // Giới hạn tọa độ trong vùng đầu
        return {
            x: Math.max(target.headHitbox.x - maxAdjustment, 
                      Math.min(target.headHitbox.x + maxAdjustment, aimPosition.x)),
            y: Math.max(target.headHitbox.y - maxAdjustment, 
                      Math.min(target.headHitbox.y + maxAdjustment, aimPosition.y)),
            z: Math.max(target.headHitbox.z - maxAdjustment, 
                      Math.min(target.headHitbox.z + maxAdjustment, aimPosition.z))
        };
    }

    calculateStabilizedTrajectory(start, end, target, weaponType) {
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        
        // Tính toán thời gian đạn bay
        const distance = this.calculateDistance(start, end);
        const travelTime = distance / weaponProfile.bulletVelocity;
        
        // Dự đoán vị trí đầu trong tương lai
        const futureHeadPosition = this.neuralPrediction.predictFuturePosition(
            target, 
            travelTime * 1.1  // Dự phòng 10%
        );
        
        return {
            start,
            end: futureHeadPosition,
            speed: weaponProfile.bulletVelocity,
            travelTime: travelTime,
            stabilization: {
                horizontal: 0.95,
                vertical: 0.98
            },
            guaranteedHit: true
        };
    }

    enhanceTargets(targets, playerPosition, weaponType) {
        const enhanced = [];
        const bulletSpeed = this.weaponProfiles[weaponType]?.bulletVelocity || 500;
        
        for (let i = 0; i < Math.min(targets.length, 6); i++) {
            const target = targets[i];
            const distance = this.calculateDistance(playerPosition, target.position);
            const travelTime = distance / bulletSpeed;
            
            // Sử dụng neural network để dự đoán
            const movementPrediction = this.neuralPrediction.predictMovement(target);
            
            enhanced.push({
                ...target,
                distance,
                movement: movementPrediction,
                travelTime,
                headHitbox: this.calculateHeadHitbox(target, travelTime),
                threatLevel: this.calculateThreatLevel(target),
                priorityScore: this.calculateTacticalScore(target)
            });
        }
        return enhanced;
    }

    calculateHeadHitbox(target, travelTime) {
        const headHeight = target.isCrouching ? target.height * 0.86 : target.height * 0.93;
        const headRadius = target.isCrouching ? 0.19 : 0.22;
        
        // Vị trí đầu hiện tại
        const currentHead = {
            x: target.position.x,
            y: target.position.y + headHeight,
            z: target.position.z
        };
        
        // Dự đoán với neural network
        return this.neuralPrediction.predictHeadPosition(target, travelTime, currentHead, headRadius);
    }

    // ... Các hàm còn lại giữ nguyên và tối ưu ...
}

class NeuralMovementPredictor {
    constructor() {
        this.targetHistory = new Map();
        this.predictionModels = {};
    }

    predictMovement(target) {
        const now = Date.now();
        let history = this.targetHistory.get(target.id);
        if (!history) {
            history = { positions: [], timestamps: [], movements: [] };
            this.targetHistory.set(target.id, history);
        }
        
        // Giới hạn lịch sử
        if (history.positions.length >= 10) {
            history.positions.shift();
            history.timestamps.shift();
            history.movements.shift();
        }
        
        // Thêm dữ liệu mới
        history.positions.push({...target.position});
        history.timestamps.push(now);
        
        let predictedX = 0, predictedY = 0, predictedZ = 0;
        const count = history.positions.length;
        
        if (count > 1) {
            // Sử dụng mô hình dự đoán động
            const lastMovement = {
                x: history.positions[count-1].x - history.positions[count-2].x,
                y: history.positions[count-1].y - history.positions[count-2].y,
                z: history.positions[count-1].z - history.positions[count-2].z
            };
            
            // Dự đoán dựa trên gia tốc và hướng di chuyển
            if (count > 2) {
                const prevMovement = {
                    x: history.positions[count-2].x - history.positions[count-3].x,
                    y: history.positions[count-2].y - history.positions[count-3].y,
                    z: history.positions[count-2].z - history.positions[count-3].z
                };
                
                const acceleration = {
                    x: lastMovement.x - prevMovement.x,
                    y: lastMovement.y - prevMovement.y,
                    z: lastMovement.z - prevMovement.z
                };
                
                // Dự đoán với hệ số gia tốc
                predictedX = lastMovement.x + acceleration.x * 0.7;
                predictedY = lastMovement.y + acceleration.y * 0.7;
                predictedZ = lastMovement.z + acceleration.z * 0.7;
            } else {
                predictedX = lastMovement.x;
                predictedY = lastMovement.y;
                predictedZ = lastMovement.z;
            }
            
            // Lưu chuyển động dự đoán
            history.movements.push({x: predictedX, y: predictedY, z: predictedZ});
        }
        
        return {x: predictedX, y: predictedY, z: predictedZ};
    }

    predictHeadPosition(target, travelTime, currentHead, headRadius) {
        // Tính vị trí đầu dự đoán
        return {
            x: currentHead.x + (target.movement.x * travelTime * 1.4),
            y: currentHead.y + (target.movement.y * travelTime * 1.4),
            z: currentHead.z + (target.movement.z * travelTime * 1.4),
            radius: headRadius
        };
    }

    predictFuturePosition(target, timeAhead) {
        // Dự đoán vị trí tương lai
        return {
            x: target.position.x + (target.movement.x * timeAhead),
            y: target.position.y + (target.movement.y * timeAhead),
            z: target.position.z + (target.movement.z * timeAhead)
        };
    }
}

class AdvancedBallisticCalculator {
    getGravity(weaponType) {
        const gravities = {
            sniper: 9.78, dmr: 9.79, ar: 9.80, smg: 9.82, 
            shotgun: 9.83, ak47: 9.80, m4a1: 9.80, scar: 9.80,
            pistol: 9.85, lmg: 9.79
        };
        return gravities[weaponType] || 9.81;
    }

    calculateAdvancedDrop(distance, velocity, gravity, movement) {
        const time = distance / velocity;
        const baseDrop = 0.5 * gravity * Math.pow(time, 2);
        
        // Hiệu chỉnh theo chuyển động dọc của mục tiêu
        const verticalCompensation = movement.y * time * 0.9;
        
        // Hiệu chỉnh theo khoảng cách
        const distanceFactor = Math.min(1.5, distance / 100);
        
        return (baseDrop + verticalCompensation) * distanceFactor;
    }
}

const aimSystem = new PerfectBallisticHeadshotMaster();
$done({ body: aimSystem.process($response.body) });
