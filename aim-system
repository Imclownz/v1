// ================== HEADSHOT MASTER v8.0 (OMEGA HEADSHOT SYSTEM) ==================
class OmegaHeadshotSystem {
    constructor() {
        // Hyper configuration
        this.lockStrength = 0.9999999;
        this.targetHistory = new Map();
        this.sessionToken = `HS_ULTRA_${Date.now().toString(36)}_${Math.random().toString(36).substr(2, 12)}`;
        this.weaponProfiles = this.getPrecisionWeaponProfiles();
        this.aimPredictionLevel = 30;
        this.aimStabilizer = 0.99999;
        this.headshotAccuracy = 0.99999;
        this.dynamicHeadExpansion = this.calculateDynamicExpansion();
        this.maxHistory = 150;
        this.lockedHeadPosition = null;
        this.lastTargetId = null;
        this.targetSwitchCooldown = 0;
        this.emergencyLockMode = false;
        this.instantLockEnabled = true;
        this.lockResponseTime = 0.008; // 8ms response time
        this.distanceBasedAimAssist = {
            close: { strength: 0.98, expansion: 1.5 },
            medium: { strength: 0.92, expansion: 2.0 },
            far: { strength: 0.85, expansion: 3.0 },
            extreme: { strength: 0.78, expansion: 4.0 }
        };
        
        // Enhanced modules
        this.targetDetector = new NeuralTargetDetector();
        this.autoAimSystem = new QuantumAimSystem();
        this.bulletTracker = new CurvedBulletTracker();
        this.targetPredictor = new AIPredictor();
        this.aimLockController = new AdaptiveLockController();
        this.recoilCompensator = new SmartRecoilSystem();
        this.performanceOptimizer = new AIPerformanceOptimizer();
        this.stealthModule = new GhostStealth();
        this.combatAnalyzer = new TacticalAnalyzer();
        this.triggerResponseSystem = new InstantTriggerSystem();
        this.headshotGuarantor = new HeadshotGod();
        this.movementAnalyzer = new AdvancedMovementAnalyzer();
        this.bulletBendingEngine = new BallisticCurveEngine();
        this.headPositionTracker = new HeadTrackingSystem();
        this.contextAnalyzer = new CombatContextProcessor();
        this.headshotGuaranteeSystem = new HeadshotGuaranteeSystem(); // NEW
        this.antiDodgeSystem = new AntiDodgeSystem(); // NEW
        this.headLockStabilizer = new HeadLockStabilizer(); // NEW
        this.dynamicPrioritySystem = new DynamicPrioritySystem(); // NEW
    }

    process(body) {
        try {
            const startTime = Date.now();
            const data = JSON.parse(body);
            
            // Analyze combat context
            this.contextAnalyzer.processContext(data.gameState);
            
            // Optimize performance based on device
            this.performanceOptimizer.adaptiveAdjust(data.performanceState);
            
            // Analyze combat situation with tactical awareness
            this.combatAnalyzer.tacticalAnalyze(data.gameState);
            
            // Activate instant lock if fire button is pressed
            if (data.gameState?.isFiring && this.instantLockEnabled) {
                this.triggerResponseSystem.activateHyperLock();
                this.headLockStabilizer.activate(); // NEW: Stabilize head lock on fire
            }
            
            // Detect enemies with neural network
            const detectedTargets = this.targetDetector.neuralDetect(data);
            data.targets = detectedTargets;
            
            if (detectedTargets.length > 0) {
                // NEW: Dynamic priority system
                const prioritizedTargets = this.dynamicPrioritySystem.analyzeTargets(
                    detectedTargets, 
                    data.gameState
                );
                
                // Select priority target with threat prediction
                const priorityTarget = this.selectPriorityTarget(prioritizedTargets, data.gameState);
                
                // Track head position with high precision
                this.headPositionTracker.trackHead(priorityTarget);
                
                // Apply quantum aiming
                if (priorityTarget) {
                    // NEW: Anti-dodge prediction
                    this.antiDodgeSystem.predictDodge(priorityTarget, data.gameState);
                    
                    const aimData = this.autoAimSystem.quantumAcquire(
                        priorityTarget, 
                        data.currentAimPosition,
                        data.playerPosition,
                        data.currentWeapon,
                        data.gameState,
                        this.triggerResponseSystem.isHyperLockActive()
                    );
                    
                    // NEW: Head lock stabilization
                    data.aimPosition = this.headLockStabilizer.stabilize(
                        aimData.position, 
                        data.currentAimPosition,
                        priorityTarget.headHitbox
                    );
                    
                    // Apply headshot lock with distance-based adjustments
                    if (this.shouldLockTarget(aimData, data.gameState, priorityTarget)) {
                        data.autoFire = true;
                        data.fireMode = "quantum_headshot_lock";
                        
                        // NEW: Headshot guarantee system
                        const guaranteedHeadshot = this.headshotGuaranteeSystem.guaranteeHit(
                            data.playerPosition,
                            data.aimPosition,
                            priorityTarget,
                            data.currentWeapon
                        );
                        
                        // Calculate curved bullet trajectory
                        data.bulletTrajectory = this.bulletTracker.calculateCurvedTrajectory(
                            data.playerPosition,
                            guaranteedHeadshot.position,
                            priorityTarget,
                            data.currentWeapon,
                            data.gameState,
                            this.headshotGuarantor,
                            this.bulletBendingEngine
                        );
                        
                        // AI-powered movement prediction
                        if (this.aimLockController.isTargetMoving(priorityTarget)) {
                            const predictedHead = this.targetPredictor.predictHeadPosition(
                                priorityTarget,
                                data.bulletTrajectory.travelTime,
                                this.movementAnalyzer,
                                this.antiDodgeSystem // NEW: Include dodge prediction
                            );
                            data.aimPosition = this.aimLockController.quantumAdjust(
                                data.aimPosition,
                                predictedHead,
                                priorityTarget
                            );
                        }
                    }
                    
                    // Smart recoil compensation
                    if (data.gameState?.isFiring) {
                        data.aimPosition = this.recoilCompensator.smartCompensate(
                            data.aimPosition,
                            data.currentWeapon,
                            data.gameState.recoilPattern,
                            priorityTarget.distance
                        );
                    }
                    
                    this.lastLockTime = Date.now();
                }
                
                // Advanced stealth concealment
                this.stealthModule.ghostConceal(data, this.contextAnalyzer);
            }
            
            // Add system metadata
            data.aimSystem = this.getSystemMetadata(startTime);
            return JSON.stringify(data);
        } catch (e) {
            console.error("[OMEGA SYSTEM] Critical Error:", e.message);
            return body;
        }
    }
    
    calculateDynamicExpansion() {
        return {
            close: 1.5,
            medium: 2.0,
            far: 3.0,
            extreme: 4.0,
            sniper: 1.0
        };
    }
    
    shouldLockTarget(aimData, gameState, target) {
        // Always lock when hyper lock is active
        if (this.triggerResponseSystem.isHyperLockActive()) return true;
        
        // Lock when lock strength exceeds threshold
        if (aimData.lockStrength >= 0.995) return true;
        
        // Lock in high threat situations
        if (gameState.playerHealth < 30) return true;
        
        // Lock for priority targets
        if (target.priority >= 9) return true;
        
        // NEW: Lock when head is visible
        if (target.headVisibility > 0.8) return true;
        
        return false;
    }
    
    selectPriorityTarget(targets, gameState) {
        if (targets.length === 0) return null;
        
        // Calculate threat score with prediction
        let maxThreat = -1;
        let selectedTarget = null;
        const playerHealth = gameState.playerHealth || 100;
        const combatState = this.combatAnalyzer.getCombatState();
        
        for (const target of targets) {
            const threatScore = this.calculateThreatScore(target, playerHealth, combatState);
            if (threatScore > maxThreat) {
                maxThreat = threatScore;
                selectedTarget = target;
            }
        }
        
        // Apply tactical priority
        return this.applyTacticalPriority(selectedTarget, targets);
    }
    
    applyTacticalPriority(primaryTarget, allTargets) {
        // Check for immediate threats
        const immediateThreats = allTargets.filter(t => 
            t.distance < 10 && t.isAimingAtPlayer && t.headVisibility > 0.7
        );
        
        if (immediateThreats.length > 0) {
            return immediateThreats.reduce((mostDangerous, current) => 
                current.priority > mostDangerous.priority ? current : mostDangerous
            );
        }
        
        // Check for snipers
        const snipers = allTargets.filter(t => t.weaponType === 'sniper' && t.headVisibility > 0.6);
        if (snipers.length > 0) {
            return snipers.sort((a, b) => a.distance - b.distance)[0];
        }
        
        // NEW: Prioritize targets with exposed heads
        const exposedTargets = allTargets.filter(t => t.headVisibility > 0.8);
        if (exposedTargets.length > 0) {
            return exposedTargets.sort((a, b) => b.priority - a.priority)[0];
        }
        
        return primaryTarget;
    }
    
    calculateThreatScore(target, playerHealth, combatState) {
        let score = 0;
        
        // Distance factor with non-linear scaling
        const distanceFactor = 1 - Math.min(1, target.distance / 400);
        score += Math.pow(distanceFactor, 2) * 120;
        
        // Aiming at player
        if (target.isAimingAtPlayer) score += 95;
        
        // Low health target bonus
        if (target.health < 30) score += 75;
        
        // Weapon danger with multipliers
        const weaponDanger = {
            sniper: { close: 80, medium: 95, far: 100, extreme: 100 },
            shotgun: { close: 100, medium: 85, far: 40, extreme: 30 },
            rifle: { close: 85, medium: 90, far: 80, extreme: 75 },
            smg: { close: 95, medium: 75, far: 45, extreme: 35 },
            pistol: { close: 65, medium: 55, far: 35, extreme: 25 }
        };
        
        const range = target.distance < 20 ? 'close' : 
                     target.distance < 50 ? 'medium' : 
                     target.distance < 100 ? 'far' : 'extreme';
        
        const dangerProfile = weaponDanger[target.weaponType] || { close: 55, medium: 55, far: 55, extreme: 50 };
        score += dangerProfile[range];
        
        // Movement threat analysis
        score += this.movementAnalyzer.assessMovementThreat(target);
        
        // Head visibility bonus
        score += target.headVisibility * 40;
        
        // Critical player health multiplier
        if (playerHealth < 30) {
            score *= 1.8;
        }
        
        // Combat state multiplier
        if (combatState === "critical") {
            score *= 1.6;
        }
        
        return score;
    }
    
    getSystemMetadata(startTime) {
        return {
            version: "8.0",
            mode: "quantum_headshot_lock",
            features: {
                instantLock: this.instantLockEnabled,
                headshotExpansion: this.dynamicHeadExpansion,
                stealthMode: true,
                guaranteedHeadshot: true,
                bulletBending: true,
                neuralDetection: true,
                headLockStabilizer: true, // NEW
                antiDodgeSystem: true, // NEW
                headshotGuarantee: true // NEW
            },
            performance: {
                processingTime: Date.now() - startTime,
                fps: this.performanceOptimizer.currentFPS,
                aiLoad: this.performanceOptimizer.aiWorkload
            },
            lockStatus: {
                strength: this.lockStrength,
                targetId: this.lastTargetId,
                instantLockActive: this.triggerResponseSystem.isHyperLockActive(),
                distanceBasedAssist: this.aimLockController.currentDistanceProfile,
                headLockStability: this.headLockStabilizer.stabilityLevel // NEW
            }
        };
    }
    
    getPrecisionWeaponProfiles() {
        return {
            default: {
                bulletVelocity: 380,
                stability: 0.98,
                horizontalRecoil: 0.025,
                verticalRecoil: 0.05,
                aimAssistFactor: 1.05,
                headshotPriority: 9.7
            },
            sniper: {
                bulletVelocity: 980,
                stability: 0.997,
                horizontalRecoil: 0.004,
                verticalRecoil: 0.08,
                aimAssistFactor: 1.35,
                headshotPriority: 10
            },
            ak47: {
                bulletVelocity: 370,
                stability: 0.95,
                horizontalRecoil: 0.05,
                verticalRecoil: 0.10,
                aimAssistFactor: 1.0,
                headshotPriority: 9.2
            },
            m4a1: {
                bulletVelocity: 410,
                stability: 0.97,
                horizontalRecoil: 0.035,
                verticalRecoil: 0.068,
                aimAssistFactor: 1.18,
                headshotPriority: 9.8
            },
            shotgun: {
                bulletVelocity: 320,
                stability: 0.90,
                horizontalRecoil: 0.058,
                verticalRecoil: 0.11,
                aimAssistFactor: 0.95,
                headshotPriority: 8.7
            },
            awm: {
                bulletVelocity: 1020,
                stability: 0.998,
                horizontalRecoil: 0.0035,
                verticalRecoil: 0.078,
                aimAssistFactor: 1.38,
                headshotPriority: 10
            },
            groza: {
                bulletVelocity: 390,
                stability: 0.94,
                horizontalRecoil: 0.048,
                verticalRecoil: 0.107,
                aimAssistFactor: 1.08,
                headshotPriority: 9.4
            },
            mp40: {
                bulletVelocity: 350,
                stability: 0.92,
                horizontalRecoil: 0.042,
                verticalRecoil: 0.088,
                aimAssistFactor: 1.12,
                headshotPriority: 9.1
            }
        };
    }
}

// ================== NEW: HEADSHOT GUARANTEE SYSTEM ==================
class HeadshotGuaranteeSystem {
    constructor() {
        this.hitProbability = 0.9999;
        this.minHeadSize = 0.3;
        this.maxHeadSize = 0.5;
        this.distanceFactors = {
            close: 1.3,
            medium: 1.0,
            far: 0.9,
            extreme: 0.85
        };
        this.weaponAdjustments = {
            sniper: { vertical: 0.03, horizontal: 0 },
            shotgun: { vertical: -0.07, horizontal: 0 },
            rifle: { vertical: 0.01, horizontal: 0.01 },
            smg: { vertical: 0, horizontal: 0.02 },
            pistol: { vertical: 0.02, horizontal: 0 },
            default: { vertical: 0, horizontal: 0 }
        };
    }
    
    guaranteeHit(playerPos, aimPos, target, weaponType) {
        const headCenter = this.calculateHeadCenter(target.headHitbox);
        const distance = this.calculateDistance(playerPos, target.position);
        const range = this.getRangeCategory(distance);
        const sizeFactor = this.distanceFactors[range];
        const weaponAdj = this.weaponAdjustments[weaponType] || this.weaponAdjustments.default;
        
        // Calculate guaranteed hit position
        const guaranteedPos = {
            x: headCenter.x + weaponAdj.horizontal,
            y: headCenter.y + weaponAdj.vertical,
            z: headCenter.z
        };
        
        // Apply advanced movement compensation
        const predictionTime = this.calculatePredictionTime(distance, weaponType);
        guaranteedPos.x += target.velocity.x * predictionTime * 1.4;
        guaranteedPos.z += target.velocity.z * predictionTime * 1.4;
        
        // Apply random noise reduction
        const noiseReduction = Math.min(1, 1 - (distance / 200));
        guaranteedPos.x += (Math.random() * 2 - 1) * 0.02 * noiseReduction;
        guaranteedPos.y += (Math.random() * 2 - 1) * 0.015 * noiseReduction;
        
        // Special case for jumping targets
        if (target.isJumping) {
            guaranteedPos.y += 0.18 * target.jumpProgress;
        }
        
        // Special case for sliding targets
        if (target.isSliding) {
            guaranteedPos.y -= 0.25;
            guaranteedPos.x += target.velocity.x * 0.15;
            guaranteedPos.z += target.velocity.z * 0.15;
        }
        
        // Final position validation
        if (!this.isPointInHead(guaranteedPos, target.headHitbox)) {
            return this.nearestHeadPoint(guaranteedPos, target.headHitbox);
        }
        
        return {
            position: guaranteedPos,
            confidence: this.hitProbability * sizeFactor
        };
    }
    
    calculateHeadCenter(headHitbox) {
        // Use weighted center for better accuracy
        return {
            x: headHitbox.x,
            y: headHitbox.y + headHitbox.radius * 0.12, // Slightly above center
            z: headHitbox.z
        };
    }
    
    calculatePredictionTime(distance, weaponType) {
        // Base prediction based on distance
        let time = distance * 0.0015;
        
        // Weapon-specific adjustments
        if (weaponType === 'sniper') time *= 0.7;
        else if (weaponType === 'shotgun') time *= 1.2;
        
        return Math.min(0.25, time);
    }
    
    isPointInHead(point, headHitbox) {
        const distance = Math.sqrt(
            Math.pow(point.x - headHitbox.x, 2) +
            Math.pow(point.y - headHitbox.y, 2)
        );
        return distance <= headHitbox.radius * 1.05;
    }
    
    nearestHeadPoint(point, headHitbox) {
        const angle = Math.atan2(point.y - headHitbox.y, point.x - headHitbox.x);
        return {
            x: headHitbox.x + Math.cos(angle) * headHitbox.radius * 0.95,
            y: headHitbox.y + Math.sin(angle) * headHitbox.radius * 0.95,
            z: headHitbox.z
        };
    }
    
        // Apply weapon-specific adjustments
        if (weaponType === 'shotgun') {
            // Shotguns benefit from center mass targeting
            guaranteedPos.y -= 0.05;
        } else if (weaponType === 'sniper') {
            // Snipers require precise head center
            guaranteedPos.y += 0.02;
        }
        
        // Add movement compensation
        if (target.movementSpeed > 5) {
            guaranteedPos.x += target.velocity.x * 0.18;
            guaranteedPos.z += target.velocity.z * 0.18;
        }
        
        return {
            position: guaranteedPos,
            confidence: this.hitProbability * sizeFactor
        };
    }
    
    calculateHeadCenter(headHitbox) {
        return {
            x: headHitbox.x,
            y: headHitbox.y,
            z: headHitbox.z
        };
    }
    
    calculateDistance(pos1, pos2) {
        return Math.sqrt(
            Math.pow(pos1.x - pos2.x, 2) +
            Math.pow(pos1.y - pos2.y, 2) +
            Math.pow(pos1.z - pos2.z, 2)
        );
    }
    
    getRangeCategory(distance) {
        if (distance < 15) return 'close';
        if (distance < 50) return 'medium';
        if (distance < 120) return 'far';
        return 'extreme';
    }
}

// ================== NEW: ANTI DODGE SYSTEM ==================
class AntiDodgeSystem {
    constructor() {
        this.dodgePatterns = {
            strafe: { prediction: 0.90, reaction: 0.95, vector: { x: 1.0, z: 0 } },
            jump: { prediction: 0.80, reaction: 0.88, vector: { x: 0, y: 1.2, z: 0 } },
            crouch: { prediction: 0.93, reaction: 0.96, vector: { x: 0, y: -0.6, z: 0 } },
            slide: { prediction: 0.85, reaction: 0.90, vector: { x: 0.7, y: -0.4, z: 0.7 } },
            prone: { prediction: 0.92, reaction: 0.94, vector: { x: 0, y: -0.8, z: 0 } },
            roll: { prediction: 0.75, reaction: 0.82, vector: { x: 0.8, y: -0.3, z: 0.8 } }
        };
        this.dodgeHistory = new Map();
        this.dodgePrediction = null;
        this.lastDodgeTime = 0;
        this.predictionWindow = 350; // ms
    }
    
    predictDodge(target, gameState) {
        if (!target.isPlayerControlled) return;
        
        const history = this.getDodgeHistory(target.id);
        const now = Date.now();
        
        // Skip if recently predicted
        if (now - this.lastDodgeTime < 400) return;
        
        // Calculate dodge probability
        const dodgeProbability = this.calculateDodgeProbability(target, gameState);
        if (dodgeProbability < 0.68) return;
        
        // Predict dodge type based on history and situation
        const dodgeType = this.predictDodgeType(target, history, gameState);
        
        this.dodgePrediction = {
            type: dodgeType,
            probability: dodgeProbability,
            timestamp: now,
            vector: this.dodgePatterns[dodgeType].vector
        };
        
        this.lastDodgeTime = now;
        this.recordDodge(target.id, dodgeType);
    }
    
    calculateDodgeProbability(target, gameState) {
        let probability = 0;
        
        // Situation factors
        if (gameState.playerIsAimingAtTarget) probability += 0.45;
        if (gameState.playerIsShooting) probability += 0.55;
        if (target.health < 35) probability += 0.65;
        if (target.health < 60) probability += 0.35;
        
        // Behavior patterns
        if (target.isMovingErratically) probability += 0.45;
        if (target.recentDodges > 2) probability += 0.35;
        if (target.lastDodgeTime > Date.now() - 5000) probability += 0.25;
        
        // Environmental factors
        if (target.isNearCover) probability += 0.30;
        
        return Math.min(0.97, probability);
    }
    
    predictDodgeType(target, history, gameState) {
        // Analyze last 3 dodges
        if (history.types.length >= 3) {
            const lastThree = history.types.slice(-3);
            
            // Detect pattern: jump -> crouch -> slide
            if (lastThree[0] === 'jump' && 
                lastThree[1] === 'crouch' && 
                lastThree[2] === 'slide') {
                return 'roll';
            }
            
            // Detect double strafe pattern
            if (lastThree.filter(t => t === 'strafe').length >= 2) {
                return 'jump';
            }
        }
        
        // Situation-based prediction
        if (target.isCrouching) return 'prone';
        if (target.isSprinting && target.distance < 15) return 'slide';
        if (target.distance < 8) return 'crouch';
        if (target.distance > 50) return 'strafe';
        if (gameState.playerWeapon === 'shotgun') return 'jump';
        
        return 'strafe'; // Default prediction
    }
    
    applyDodgeCompensation(aimPosition, target) {
        if (!this.dodgePrediction || !target) return aimPosition;
        
        // Check if prediction is still valid
        if (Date.now() - this.dodgePrediction.timestamp > this.predictionWindow) {
            this.dodgePrediction = null;
            return aimPosition;
        }
        
        // Apply dodge vector
        return {
            x: aimPosition.x + this.dodgePrediction.vector.x,
            y: aimPosition.y + (this.dodgePrediction.vector.y || 0),
            z: aimPosition.z + this.dodgePrediction.vector.z
        };
    }
    
        // Predict dodge based on combat situation
        if (gameState.playerIsAimingAtTarget && target.health < 50) {
            const dodgeProbability = this.calculateDodgeProbability(target, gameState);
            
            if (dodgeProbability > 0.7) {
                const dodgeType = this.predictDodgeType(target, lastAction);
                this.dodgePrediction = {
                    type: dodgeType,
                    probability: dodgeProbability,
                    timestamp: Date.now()
                };
                return;
            }
        }
        
        this.dodgePrediction = null;
    }
    
    getDodgeHistory(targetId) {
        if (!this.dodgeHistory.has(targetId)) {
            this.dodgeHistory.set(targetId, {
                actions: [],
                timestamps: [],
                success: []
            });
        }
        return this.dodgeHistory.get(targetId);
    }
    
    calculateDodgeProbability(target, gameState) {
        let probability = 0;
        
        // Health-based dodge probability
        if (target.health < 30) probability += 0.6;
        else if (target.health < 60) probability += 0.4;
        
        // Player threat level
        if (gameState.playerIsAimingAtTarget) probability += 0.3;
        if (gameState.playerIsShooting) probability += 0.4;
        
        // Target behavior
        if (target.isMovingErratically) probability += 0.25;
        if (target.isInCover) probability -= 0.2;
        
        return Math.min(0.95, probability);
    }
    
    predictDodgeType(target, lastAction) {
        // Simple pattern: alternate between dodge types
        const dodgeTypes = Object.keys(this.dodgePatterns);
        
        if (!lastAction) {
            return dodgeTypes[Math.floor(Math.random() * dodgeTypes.length)];
        }
        
        const lastIndex = dodgeTypes.indexOf(lastAction);
        const nextIndex = (lastIndex + 1) % dodgeTypes.length;
        return dodgeTypes[nextIndex];
    }
    
    getCurrentDodgePrediction() {
        return this.dodgePrediction;
    }
}

// ================== NEW: HEAD LOCK STABILIZER ==================
class HeadLockStabilizer {
    constructor() {
        this.stabilityLevel = 0;
        this.maxStability = 1.0;
        this.activationTime = 0;
        this.stabilizationFactors = {
            close: 0.99,    // Higher stability at close range
            medium: 0.97,
            far: 0.95,
            extreme: 0.92
        };
        this.decayRate = 0.96; // Slower decay
        this.momentumFactor = 0.88;
    }
    
    activate() {
        this.stabilityLevel = this.maxStability;
        this.activationTime = Date.now();
    }
    
    stabilize(currentAim, previousAim, headHitbox, target) {
        if (this.stabilityLevel < 0.1) return currentAim;
        
        const headCenter = {
            x: headHitbox.x,
            y: headHitbox.y,
            z: headHitbox.z
        };
        
        // Calculate distance to head center
        const distanceToHead = Math.sqrt(
            Math.pow(currentAim.x - headCenter.x, 2) +
            Math.pow(currentAim.y - headCenter.y, 2)
        );
        
        // Calculate range category for stabilization factor
        const range = distanceToHead < 15 ? 'close' : 
                     distanceToHead < 40 ? 'medium' : 
                     distanceToHead < 90 ? 'far' : 'extreme';
        const stabilityFactor = this.stabilizationFactors[range];
        
        // Apply stabilization with momentum control
        const stabilizedAim = {
            x: this.lerp(previousAim.x, headCenter.x, stabilityFactor * this.stabilityLevel),
            y: this.lerp(previousAim.y, headCenter.y, stabilityFactor * this.stabilityLevel),
            z: this.lerp(previousAim.z, headCenter.z, 0.7 * this.stabilityLevel)
        };
        
        // Add micro-adjustments for moving targets
        if (target && target.velocity) {
            const momentumX = target.velocity.x * this.momentumFactor * this.stabilityLevel;
            const momentumZ = target.velocity.z * this.momentumFactor * this.stabilityLevel;
            
            stabilizedAim.x += momentumX;
            stabilizedAim.z += momentumZ;
            
            // Vertical adjustment for jumping/sliding
            if (target.isJumping) {
                stabilizedAim.y += 0.15 * this.stabilityLevel;
            } else if (target.isSliding) {
                stabilizedAim.y -= 0.12 * this.stabilityLevel;
            }
        }
        
        // Gradually reduce stability
        this.stabilityLevel *= this.decayRate;
        
        return stabilizedAim;
    }
    
    lerp(start, end, amt) {
        return (1 - amt) * start + amt * end;
    }
}

// ================== NEW: DYNAMIC PRIORITY SYSTEM ==================
class DynamicPrioritySystem {
    constructor() {
        this.threatWeights = {
            distance: 0.28,
            weapon: 0.25,
            health: 0.18,
            action: 0.15,
            position: 0.14
        };
        this.opportunityWeights = {
            headVisibility: 0.40,
            stability: 0.25,
            exposure: 0.20,
            health: 0.15
        };
        this.priorityThresholds = {
            critical: 85,
            high: 70,
            medium: 50
        };
    }
    
    analyzeTargets(targets, gameState) {
        // Calculate threat and opportunity scores
        targets.forEach(target => {
            target.threatScore = this.calculateThreatScore(target, gameState);
            target.opportunityScore = this.calculateOpportunityScore(target);
            target.priority = this.calculatePriority(target);
            
            // Apply critical situation modifiers
            if (gameState.playerHealth < 25) {
                target.priority += this.calculateCriticalBonus(target);
            }
        });
        
        // Sort by priority (descending) and apply threat proximity
        return targets.sort((a, b) => {
            // Critical threat proximity boost
            const aProximity = a.distance < 15 ? 25 : 0;
            const bProximity = b.distance < 15 ? 25 : 0;
            
            return (b.priority + bProximity) - (a.priority + aProximity);
        });
    }
    
    calculateThreatScore(target, gameState) {
        let score = 0;
        
        // Proximity threat (exponential scaling)
        if (target.distance < 10) score += 45;
        else if (target.distance < 20) score += 35;
        else if (target.distance < 35) score += 25;
        else if (target.distance < 50) score += 15;
        
        // Weapon danger
        const weaponScores = {
            sniper: 40,
            shotgun: 35,
            rifle: 30,
            smg: 25,
            pistol: 15,
            launcher: 20
        };
        score += weaponScores[target.weaponType] || 10;
        
        // Aggression factors
        if (target.isAimingAtPlayer) score += 30;
        if (target.isShooting) score += 35;
        if (target.isThrowingGrenade) score += 25;
        
        // Player-specific threat
        if (target.isFocusingPlayer) score += 20;
        
        return score * this.threatWeights.distance;
    }
    
    calculateOpportunityScore(target) {
        let score = 0;
        
        // Head visibility is most important
        score += target.headVisibility * 100;
        
        // Movement stability
        if (target.movementPattern === 'stationary') score += 35;
        else if (target.movementPattern === 'linear') score += 25;
        else if (target.movementPattern === 'predictable') score += 15;
        
        // Environmental exposure
        if (!target.isInCover) score += 40;
        if (target.isOnOpenGround) score += 25;
        
        // Health status (weaker targets are easier to kill)
        if (target.health < 30) score += 35;
        else if (target.health < 50) score += 20;
        
        return score * this.opportunityWeights.headVisibility;
    }
    
    calculatePriority(target) {
        // Weighted combination of threat and opportunity
        const threatComponent = target.threatScore * 0.65;
        const opportunityComponent = target.opportunityScore * 0.35;
        
        return Math.min(100, threatComponent + opportunityComponent);
    }
    
    calculateCriticalBonus(target) {
        // Extra priority when player health is critical
        let bonus = 0;
        
        if (target.isImmediateThreat) bonus += 35;
        if (target.distance < 15) bonus += 30;
        if (target.isShooting) bonus += 25;
        
        return bonus;
    }
}

// ================== NEURAL TARGET DETECTOR (UPGRADED) ==================
class NeuralTargetDetector {
    constructor() {
        this.detectionAlgorithms = {
            visual: new DeepVision(),
            radar: new QuantumRadar(),
            predictive: new AIPredictiveTargeting(),
            thermal: new ThermalSignatureDetection(),
            skeletal: new SkeletalTrackingSystem() // NEW
        };
        this.targetConfidenceThreshold = 0.97; // Increased
        this.minDetectionSize = 4; // Smaller
        this.expansionSystem = new HeadExpansionSystem();
        this.headFocusBoost = 1.3; // NEW
    }
    
    neuralDetect(gameData) {
        const targets = [];
        
        // Deep vision detection
        if (gameData.visualData) {
            const visualTargets = this.detectionAlgorithms.visual.deepProcess(gameData.visualData);
            targets.push(...visualTargets);
        }
        
        // Quantum radar detection
        if (gameData.radarData) {
            const radarTargets = this.detectionAlgorithms.radar.quantumScan(gameData.radarData);
            targets.push(...radarTargets);
        }
        
        // AI predictive targeting
        if (gameData.gameState) {
            const predictiveTargets = this.detectionAlgorithms.predictive.aiFindTargets(gameData);
            targets.push(...predictiveTargets);
        }
        
        // Thermal signature detection
        if (gameData.thermalData) {
            const thermalTargets = this.detectionAlgorithms.thermal.detectHeatSignatures(gameData.thermalData);
            targets.push(...thermalTargets);
        }
        
        // NEW: Skeletal tracking
        if (gameData.skeletalData) {
            const skeletalTargets = this.detectionAlgorithms.skeletal.trackBodies(gameData.skeletalData);
            targets.push(...skeletalTargets);
        }
        
        // Filter by confidence
        const filteredTargets = targets.filter(t => t.confidence >= this.targetConfidenceThreshold);
        
        // Merge duplicates with AI
        const mergedTargets = this.mergeTargetsAI(filteredTargets);
        
        // Enhance target data with head focus
        return mergedTargets.map(target => 
            this.enhanceTarget(target, gameData.playerPosition)
			
        // NEW: Skeletal tracking
        if (gameData.skeletalData) {
            const skeletalTargets = this.detectionAlgorithms.skeletal.trackBodies(gameData.skeletalData);
            targets.push(...skeletalTargets);
            
            // Enhanced head detection for skeletal targets
            skeletalTargets.forEach(target => {
                target.headHitbox = this.calculatePreciseHeadHitbox(target);
            });
        }
        
        // Filter by confidence with head visibility priority
        const filteredTargets = targets.filter(t => 
            t.confidence >= this.targetConfidenceThreshold &&
            t.headVisibility >= this.minHeadVisibility
        );
    }
    
    mergeTargetsAI(targets) {
        const merged = [];
        const positionTolerance = 0.5; // Tighter tolerance
        
        for (const target of targets) {
            let existing = null;
            let minDistance = Infinity;
            
            for (const mergedTarget of merged) {
                const distance = this.calculateDistance(
                    target.position, 
                    mergedTarget.position
                );
                
                if (distance < positionTolerance && distance < minDistance) {
                    existing = mergedTarget;
                    minDistance = distance;
                }
            }
            
            if (existing) {
                // AI-powered data fusion
                existing.confidence = Math.min(1, (existing.confidence + target.confidence) * 0.88);
                
                // Position fusion with velocity weighting
                const weight = target.confidence / (existing.confidence + target.confidence);
                existing.position = {
                    x: existing.position.x * (1-weight) + target.position.x * weight,
                    y: existing.position.y * (1-weight) + target.position.y * weight,
                    z: existing.position.z * (1-weight) + target.position.z * weight
                };
                
                // Head visibility fusion
                if (target.headVisibility) {
                    existing.headVisibility = Math.max(
                        existing.headVisibility || 0, 
                        target.headVisibility
                    );
                }
                
                // Merge additional properties with priority
                Object.keys(target).forEach(key => {
                    if (!existing[key] || key === 'priority') {
                        existing[key] = target[key];
                    }
                });
            } else {
                merged.push({...target});
            }
        }
        
        return merged;
    }
	
    calculatePreciseHeadHitbox(target) {
        const baseRadius = 0.36; // Slightly larger hitbox
        let expansionFactor = 1.0;
        
        // Distance-based expansion
        if (target.distance < 15) expansionFactor = 1.35;
        else if (target.distance < 40) expansionFactor = 1.75;
        else if (target.distance < 100) expansionFactor = 2.15;
        else expansionFactor = 2.65;
        
        // Movement-based expansion
        if (target.movementSpeed > 5) {
            expansionFactor *= 1 + (target.movementSpeed * 0.035);
        }
        
        // Visibility-based adjustment
        if (target.headVisibility < 0.7) {
            expansionFactor *= 1.15;
        }
        
        // Calculate head height with advanced stance detection
        const headHeight = this.calculateHeadHeight(target);
        
        return {
            x: target.position.x,
            y: target.position.y + headHeight,
            z: target.position.z,
            radius: baseRadius * expansionFactor,
            baseRadius: baseRadius,
            expansion: expansionFactor,
            visibility: target.headVisibility
        };
    }
    
    calculateHeadHeight(target) {
        let height = 1.68; // Standing height
        
        // Basic stances
        if (target.isCrouching) height = 1.25;
        if (target.isProne) height = 0.85;
        
        // Dynamic actions
        if (target.isJumping) {
            height += Math.min(0.75, target.jumpProgress * 1.55);
        }
        if (target.isVaulting) {
            height += 0.45 + (0.2 * target.vaultProgress);
        }
        if (target.isSliding) {
            height = 0.95 - (0.15 * target.slideProgress);
        }
        if (target.isClimbing) {
            height += 0.3;
        }
        
        // Weapon effects
        if (target.weaponType === 'sniper') {
            height -= 0.05; // Slightly more hunched
        }
        
        return height;
    }
    
    enhanceTarget(target, playerPosition) {
        // Calculate precise distance
        target.distance = this.calculateDistance(target.position, playerPosition);
        
        // Calculate head hitbox with dynamic expansion
        target.headHitbox = this.expansionSystem.calculateDynamicHeadHitbox(target);
		
        // Advanced head visibility calculation
        target.headVisibility = this.calculateHeadVisibility(target);
        
        // NEW: Calculate head visibility
        target.headVisibility = this.calculateHeadVisibility(target);
        
        // Calculate threat level with movement analysis
        target.priority = this.calculateThreatLevel(target);
        
        // Add movement prediction data
        target.movementPrediction = this.predictMovementPattern(target);
        
        return target;
    }
    
    calculateDistance(pos1, pos2) {
        return Math.sqrt(
            Math.pow(pos1.x - pos2.x, 2) +
            Math.pow(pos1.y - pos2.y, 2) +
            Math.pow(pos1.z - pos2.z, 2)
        );
    }
    
    calculateHeadVisibility(target) {
        if (!target.visibilityInfo) return 1.0;
        
        // Calculate head visibility based on obstructions
        let visibility = 1.0;
        
        if (target.visibilityInfo.headObstructed) {
            visibility -= 0.4;
        }
        
        if (target.visibilityInfo.bodyObstructed) {
            visibility -= 0.2;
        }
        
        // Environmental factors
        if (target.isInSmoke) {
            visibility -= 0.3;
        }
        
        return Math.max(0.1, visibility);
    }
    
    calculateThreatLevel(target) {
        let threat = 0;
        
        // Weapon danger with distance modifiers
        const weaponThreat = {
            sniper: { close: 8, medium: 9.5, far: 10, extreme: 9.8 },
            shotgun: { close: 10, medium: 8.5, far: 5, extreme: 3.5 },
            rifle: { close: 8.5, medium: 9.2, far: 8.8, extreme: 7.5 },
            smg: { close: 9.2, medium: 8.0, far: 6.5, extreme: 4.5 },
            pistol: { close: 6.5, medium: 5.5, far: 4.0, extreme: 2.5 }
        };
        
        const range = target.distance < 20 ? 'close' : 
                     target.distance < 50 ? 'medium' : 
                     target.distance < 120 ? 'far' : 'extreme';
        
        const threatProfile = weaponThreat[target.weaponType] || { close: 5.5, medium: 5.5, far: 5.0, extreme: 4.5 };
        threat += threatProfile[range];
        
        // Behavior danger
        if (target.isAimingAtPlayer) threat += 9.5;
        if (target.isShooting) threat += 8.5;
        
        // Proximity danger with exponential scaling
        if (target.distance < 15) threat += Math.pow(1.9, (20 - target.distance)/5);
        else if (target.distance < 40) threat += 7;
        
        // Head visibility impact
        threat *= target.headVisibility * 0.8 + 0.2;
        
        // Movement-based threat
        threat += this.assessMovementThreat(target);
        
        return Math.min(10, threat);
    }
    
    assessMovementThreat(target) {
        let threatBonus = 0;
        
        // High-speed movement
        if (target.movementSpeed > 8) threatBonus += 3.5;
        
        // Erratic movement patterns
        if (target.movementPattern === 'erratic') threatBonus += 4.5;
        
        // Flanking movement
        if (target.isFlanking) threatBonus += 6;
        
        return threatBonus;
    }
    
    predictMovementPattern(target) {
        // AI-powered movement prediction
        return {
            pattern: 'linear',
            confidence: 0.88,
            nextPosition: {
                x: target.position.x + target.velocity.x * 0.18,
                y: target.position.y + target.velocity.y * 0.18,
                z: target.position.z + target.velocity.z * 0.18
            }
        };
    }
	
    calculateHeadVisibility(target) {
        let visibility = 1.0;
        
        // Obstruction factors
        if (target.headObstructed) visibility *= 0.55;
        else if (target.bodyObstructed) visibility *= 0.8;
        
        // Environmental factors
        if (target.inSmoke) visibility *= 0.45;
        if (target.inDarkArea) visibility *= 0.7;
        if (target.inWater) visibility *= 0.8;
        
        // Stance factors
        if (target.isCrouching) visibility *= 0.92;
        if (target.isProne) visibility *= 0.65;
        if (target.isBehindCover) visibility *= 0.5;
        
        // Movement factors
        if (target.isMovingFast) visibility *= 0.85;
        
        return Math.max(0.15, visibility);
    }
}

// ================== HEAD EXPANSION SYSTEM (UPGRADED) ==================
class HeadExpansionSystem {
    calculateDynamicHeadHitbox(target) {
        const baseRadius = 0.38;
        let expansionFactor = 1.0;
        
        // Distance-based expansion
        if (target.distance < 15) expansionFactor = 1.4;
        else if (target.distance < 40) expansionFactor = 1.8;
        else if (target.distance < 100) expansionFactor = 2.2;
        else expansionFactor = 2.8;
        
        // Weapon-specific adjustments
        if (target.weaponType === 'sniper') expansionFactor *= 0.92;
        
        // Movement-based adjustments
        if (target.movementSpeed > 5) expansionFactor *= 1.25;
        
        // Head visibility adjustments
        if (target.headVisibility < 0.6) expansionFactor *= 1.15;
        
        // Calculate head height based on stance
        let headHeight = this.calculateHeadHeight(target);
        
        return {
            x: target.position.x,
            y: target.position.y + headHeight,
            z: target.position.z,
            radius: baseRadius * expansionFactor,
            baseRadius: baseRadius,
            expansion: expansionFactor
        };
    }
    
    calculateHeadHeight(target) {
        let height = 1.68; // Standing
        
        if (target.isCrouching) height = 1.25;
        if (target.isProne) height = 0.85;
        if (target.isJumping) height += Math.min(0.75, target.jumpProgress * 1.5);
        if (target.isVaulting) height += 0.45;
        if (target.isSliding) height = 0.95;
        
        return height;
    }
}

// ================== QUANTUM AIM SYSTEM (UPGRADED) ==================
class QuantumAimSystem {
    constructor() {
        this.lockSystem = new DistanceBasedLock();
        this.predictionEngine = new HeadPredictionEngine();
        this.aimSmoothing = 0.97;
        this.maxAimHeight = 1.88;
        this.hyperLockMode = false;
        this.headFocusFactor = 0.99; // Increased
        this.headLockAggressiveness = 1.25; // NEW
    }
    
    quantumAcquire(target, currentAimPos, playerPos, weaponType, gameState, hyperLock = false) {
        this.hyperLockMode = hyperLock;
        
        // Calculate perfect aim position with prediction
        const perfectAim = this.predictionEngine.calculatePerfectAim(
            target, 
            playerPos, 
            weaponType,
            gameState
        );
        
        // Move aim to target with distance-based parameters
        const newAimPos = this.lockSystem.moveToHead(
            currentAimPos, 
            perfectAim, 
            target,
            weaponType,
            this.hyperLockMode,
            this.headLockAggressiveness // NEW
        );
        
        // Calculate lock strength with head focus
        const lockStrength = this.calculateHeadFocus(newAimPos, perfectAim, target);
        
        return {
            position: newAimPos,
            lockStrength: lockStrength
        };
    }
    
    calculateHeadFocus(aimPos, targetPos, target) {
        const distance = Math.sqrt(
            Math.pow(aimPos.x - targetPos.x, 2) +
            Math.pow(aimPos.y - targetPos.y, 2)
        );
        
        const maxDistance = target.headHitbox.radius * 2.2; // Reduced
        const focus = Math.max(0, 1 - (distance / maxDistance));
        
        // Apply head focus factor
        return Math.min(1, focus * this.headFocusFactor);
    }
}

// ================== DISTANCE BASED LOCK (UPGRADED) ==================
class DistanceBasedLock {
    constructor() {
        this.lockProfiles = {
            close: { speed: 0.28, smoothing: 0.94, snapDistance: 1.2 },
            medium: { speed: 0.22, smoothing: 0.96, snapDistance: 1.8 },
            far: { speed: 0.16, smoothing: 0.98, snapDistance: 2.5 },
            extreme: { speed: 0.12, smoothing: 0.99, snapDistance: 3.2 } // NEW
        };
        this.currentProfile = "medium";
        this.headLockBoost = 1.0; // NEW
    }
    
    moveToHead(currentPos, targetPos, target, weaponType, hyperLock = false, headLockAggressiveness = 1.0) {
        // Select lock profile based on distance
        this.selectProfile(target.distance);
        const profile = this.lockProfiles[this.currentProfile];
        this.headLockBoost = headLockAggressiveness; // NEW
        
        // Calculate move speed
        let moveSpeed = hyperLock ? profile.speed * 2.0 : profile.speed;
        moveSpeed *= this.headLockBoost; // NEW
        
        // Weapon-based adjustments
        if (weaponType === 'sniper') moveSpeed *= 0.88;
        else if (weaponType === 'shotgun') moveSpeed *= 1.18;
        
        // Direction vector
        const direction = {
            x: targetPos.x - currentPos.x,
            y: targetPos.y - currentPos.y,
            z: targetPos.z - currentPos.z
        };
        
        // Apply smoothing
        const newPos = {
            x: currentPos.x + direction.x * moveSpeed * profile.smoothing,
            y: currentPos.y + direction.y * moveSpeed * profile.smoothing,
            z: currentPos.z + direction.z * moveSpeed * profile.smoothing * 0.94
        };
        
        // For hyper lock, snap directly to head center when close
        if (hyperLock) {
            const distance = Math.sqrt(
                Math.pow(newPos.x - targetPos.x, 2) +
                Math.pow(newPos.y - targetPos.y, 2)
            );
            
            if (distance < profile.snapDistance) {
                return {
                    x: target.headHitbox.x,
                    y: target.headHitbox.y,
                    z: target.headHitbox.z
                };
            }
        }
        
        return newPos;
    }
    
    selectProfile(distance) {
        if (distance < 15) this.currentProfile = "close";
        else if (distance < 45) this.currentProfile = "medium";
        else if (distance < 120) this.currentProfile = "far";
        else this.currentProfile = "extreme"; // NEW
    }
}

// ================== HEAD PREDICTION ENGINE (UPGRADED) ==================
class HeadPredictionEngine {
    calculatePerfectAim(target, playerPos, weaponType, gameState) {
        const basePos = target.headHitbox;
        
        // Calculate bullet travel time
        const travelTime = this.calculateTravelTime(playerPos, basePos, weaponType);
        
        // Predict head movement
        const predictedMovement = this.predictHeadMovement(target, travelTime, gameState);
        
        return {
            x: basePos.x + predictedMovement.x,
            y: basePos.y + predictedMovement.y,
            z: basePos.z + predictedMovement.z
        };
    }
    
    calculateTravelTime(startPos, endPos, weaponType) {
        const distance = Math.sqrt(
            Math.pow(endPos.x - startPos.x, 2) +
            Math.pow(endPos.y - startPos.y, 2) +
            Math.pow(endPos.z - startPos.z, 2)
        );
        
        const weaponProfile = this.getWeaponProfile(weaponType);
        return distance / weaponProfile.bulletVelocity;
    }
    
    predictHeadMovement(target, time, gameState) {
        // Advanced prediction with game state context
        const baseMovement = {
            x: target.velocity.x * time * 1.35, // Increased
            y: target.velocity.y * time * 1.35, // Increased
            z: target.velocity.z * time * 0.88
        };
        
        // Add environmental factors
        if (gameState.mapType === 'urban') {
            baseMovement.x *= 0.92;
            baseMovement.z *= 0.94;
        }
        
        // Add gravity effect
        if (!target.isGrounded) {
            baseMovement.y -= 0.5 * 9.81 * time * time;
        }
        
        // NEW: Predict dodge movements
        if (target.predictedDodge) {
            switch (target.predictedDodge.type) {
                case 'jump':
                    baseMovement.y += 1.8 * time;
                    break;
                case 'crouch':
                    baseMovement.y -= 0.6;
                    break;
                case 'slide':
                    baseMovement.y -= 0.4;
                    baseMovement.x += target.velocity.x * time * 0.5;
                    baseMovement.z += target.velocity.z * time * 0.5;
                    break;
            }
        }
        
        return baseMovement;
    }
    
    getWeaponProfile(weaponType) {
        const profiles = {
            default: { bulletVelocity: 380 },
            sniper: { bulletVelocity: 950 },
            ak47: { bulletVelocity: 360 },
            m4a1: { bulletVelocity: 400 },
            shotgun: { bulletVelocity: 300 },
            awm: { bulletVelocity: 1020 },
            groza: { bulletVelocity: 390 },
            mp40: { bulletVelocity: 340 } // NEW
        };
        
        return profiles[weaponType] || profiles.default;
    }
}

// ================== CURVED BULLET TRACKER (UPGRADED) ==================
class CurvedBulletTracker {
    calculateCurvedTrajectory(startPos, aimPos, target, weaponType, gameState, guarantor, bender) {
        // Calculate initial travel time
        const travelTime = this.calculateTravelTime(startPos, aimPos, weaponType);
        
        // Predict target position at impact
        const predictedPos = this.predictFuturePosition(target, travelTime);
        
        // Get guaranteed hit position with bending
        const curvedHitPos = bender.calculateCurvedPath(
            startPos,
            predictedPos,
            target,
            weaponType,
            gameState
        );
        
        // NEW: Final guarantee from Headshot God
        const finalHitPos = guarantor.guaranteeHeadshot(startPos, curvedHitPos, target, weaponType);
        
        return {
            start: startPos,
            end: finalHitPos,
            travelTime: travelTime,
            curved: true,
            bendAngle: bender.lastBendAngle,
            guaranteedHit: true
        };
    }
    
    calculateTravelTime(startPos, endPos, weaponType) {
        const distance = Math.sqrt(
            Math.pow(endPos.x - startPos.x, 2) +
            Math.pow(endPos.y - startPos.y, 2) +
            Math.pow(endPos.z - startPos.z, 2)
        );
        
        const weaponProfile = this.getWeaponProfile(weaponType);
        return distance / weaponProfile.bulletVelocity;
    }
    
    predictFuturePosition(target, time) {
        // Enhanced prediction with dodge anticipation
        let predictionFactor = 1.25;
        if (target.predictedDodge) {
            predictionFactor = 1.45; // Increase prediction for dodging targets
        }
        
        return {
            x: target.position.x + target.velocity.x * time * predictionFactor,
            y: target.position.y + target.velocity.y * time * predictionFactor,
            z: target.position.z + target.velocity.z * time * 0.92
        };
    }
    
    getWeaponProfile(weaponType) {
        // Same as in HeadPredictionEngine
    }
}

// ================== BALLISTIC CURVE ENGINE (UPGRADED) ==================
class BallisticCurveEngine {
    constructor() {
        this.maxBendAngle = 0.22; // radians
        this.bendFactor = 0.88;
        this.lastBendAngle = 0;
        this.distanceFactors = {
            close: 0.75,
            medium: 1.0,
            far: 1.3,
            extreme: 1.5
        };
        this.velocityCurve = {
            low: 0.8,
            medium: 1.0,
            high: 1.25
        };
    }
    
    calculateCurvedPath(startPos, targetPos, target, weaponType, gameState) {
        // Calculate necessary bend based on movement
        const velocityMagnitude = Math.sqrt(
            target.velocity.x * target.velocity.x +
            target.velocity.y * target.velocity.y +
            target.velocity.z * target.velocity.z
        );
        
        // Get velocity category
        const velocityCategory = velocityMagnitude < 5 ? 'low' : 
                                velocityMagnitude < 10 ? 'medium' : 'high';
        
        // Get distance factor
        const distFactor = this.distanceFactors[this.getRangeCategory(target.distance)];
        const velFactor = this.velocityCurve[velocityCategory];
        
        // Calculate bend angle based on velocity and distance
        const bendAngle = this.calculateBendAngle(velocityMagnitude, target.distance) * distFactor * velFactor;
        
        // Calculate direction vector
        const dx = targetPos.x - startPos.x;
        const dy = targetPos.y - startPos.y;
        const dz = targetPos.z - startPos.z;
        
        // Apply bending in movement direction with prediction
        const predictionTime = this.calculatePredictionTime(target.distance, weaponType);
        const predictedVelocity = {
            x: target.velocity.x * predictionTime,
            z: target.velocity.z * predictionTime
        };
        
        const bendX = bendAngle * predictedVelocity.x * this.bendFactor;
        const bendY = bendAngle * target.velocity.y * this.bendFactor * 0.6;
        
        // Apply environmental factors
        let environmentFactor = 1.0;
        if (gameState.mapType === 'windy') environmentFactor = 1.15;
        if (gameState.weather === 'rain') environmentFactor = 1.08;
        
        return {
            x: targetPos.x + bendX * environmentFactor,
            y: targetPos.y + bendY,
            z: targetPos.z + bendX * environmentFactor
        };
    }
    
    calculatePredictionTime(distance, weaponType) {
        // Base prediction based on distance
        let time = distance * 0.0018;
        
        // Weapon-specific adjustments
        const weaponSpeeds = {
            sniper: 0.6,
            awm: 0.55,
            shotgun: 1.3,
            rifle: 0.8,
            smg: 0.9,
            pistol: 1.1
        };
        
        time *= weaponSpeeds[weaponType] || 1.0;
        return Math.min(0.3, time);
    }
     
    calculateBendAngle(velocity, distance) {
        // Base angle based on velocity
        let angle = Math.min(this.maxBendAngle, velocity * 0.028); // Increased coefficient
        
        // Distance scaling
        if (distance > 100) angle *= 1.35;
        else if (distance > 50) angle *= 1.15;
        
        return angle;
    }
}

// ================== HEADSHOT GOD (UPGRADED) ==================
class HeadshotGod {
    guaranteeHeadshot(startPos, predictedPos, target, weaponType) {
        const head = target.headHitbox;
        
        // If predicted position is within head hitbox, use it
        if (this.isPointInHead(predictedPos, head)) {
            return predictedPos;
        }
        
        // For moving targets, predict the edge of the hitbox
        if (target.movementSpeed > 1.5) {
            return this.predictLeadingEdge(predictedPos, head, target.velocity);
        }
        
        // Otherwise adjust to nearest point in head hitbox
        return this.nearestHeadPoint(predictedPos, head);
    }
    
    isPointInHead(point, head) {
        const distance = Math.sqrt(
            Math.pow(point.x - head.x, 2) +
            Math.pow(point.y - head.y, 2)
        );
        
        return distance <= head.radius;
    }
    
    nearestHeadPoint(point, head) {
        const angle = Math.atan2(point.y - head.y, point.x - head.x);
        
        return {
            x: head.x + Math.cos(angle) * head.radius * 0.92,
            y: head.y + Math.sin(angle) * head.radius * 0.92,
            z: head.z
        };
    }
    
    predictLeadingEdge(point, head, velocity) {
        const velocityAngle = Math.atan2(velocity.y, velocity.x);
        const edgeX = head.x + Math.cos(velocityAngle) * head.radius;
        const edgeY = head.y + Math.sin(velocityAngle) * head.radius;
        
        return {
            x: edgeX,
            y: edgeY,
            z: head.z
        };
    }
}

// ================== INSTANT TRIGGER SYSTEM (UPGRADED) ==================
class InstantTriggerSystem {
    constructor() {
        this.hyperLockActive = false;
        this.activationTime = 0;
        this.lockDuration = 0.42; // Increased lock duration
        this.cooldown = 90; // Reduced cooldown (ms)
        this.headLockBoost = 1.3; // NEW
    }
    
    activateHyperLock() {
        const now = Date.now();
        if (now - this.activationTime > this.cooldown) {
            this.hyperLockActive = true;
            this.activationTime = now;
        }
    }
    
    isHyperLockActive() {
        if (this.hyperLockActive) {
            // Auto disable after duration
            if (Date.now() - this.activationTime > this.lockDuration * 1000) {
                this.hyperLockActive = false;
            }
            return true;
        }
        return false;
    }
    
    getHeadLockBoost() {
        return this.headLockBoost;
    }
}

// ================== AI PREDICTOR (UPGRADED) ==================
class AIPredictor {
    constructor() {
        this.predictionModels = {
            linear: new LinearPredictionModel(),
            erratic: new ErraticPredictionModel(),
            jumping: new JumpPredictionModel(),
            tactical: new TacticalMovementModel(),
            dodging: new DodgePredictionModel() // NEW
        };
        this.movementHistory = new Map();
        this.maxHistorySize = 35; // Increased
        this.predictionAccuracy = 0.98; // Increased
        this.behaviorDatabase = new BehaviorDatabase();
        this.dodgePredictor = new DodgePredictor(); // NEW
    }
    
    predictHeadPosition(target, timeAhead, movementAnalyzer, antiDodgeSystem) {
        // Get movement history
        const history = this.getMovementHistory(target.id);
        
        // Update with current position
        this.updateHistory(target, history);
        
        // Analyze movement pattern
        const patternType = movementAnalyzer.determineMovementPattern(target, history);
        
        // NEW: Check dodge prediction
        const dodgePrediction = antiDodgeSystem.getCurrentDodgePrediction();
        if (dodgePrediction) {
            target.predictedDodge = dodgePrediction;
            return this.predictionModels.dodging.predictHead(target, history, timeAhead);
        }
        
        // Select prediction model
        const predictionModel = this.predictionModels[patternType];
        
        // Generate prediction
        return predictionModel.predictHead(target, history, timeAhead);
    }
    
    getMovementHistory(targetId) {
        if (!this.movementHistory.has(targetId)) {
            this.movementHistory.set(targetId, {
                positions: [],
                timestamps: [],
                velocities: [],
                actions: []
            });
        }
        return this.movementHistory.get(targetId);
    }
    
    updateHistory(target, history) {
        const currentTime = Date.now();
        
        // Add current position
        history.positions.push({...target.position});
        history.timestamps.push(currentTime);
        history.actions.push(target.currentAction);
        
        // Calculate velocity if possible
        if (history.positions.length > 1) {
            const lastPos = history.positions[history.positions.length - 2];
            const currentPos = history.positions[history.positions.length - 1];
            const timeDiff = (history.timestamps[history.timestamps.length - 1] - 
                             history.timestamps[history.timestamps.length - 2]) / 1000;
            
            if (timeDiff > 0) {
                const velocity = {
                    x: (currentPos.x - lastPos.x) / timeDiff,
                    y: (currentPos.y - lastPos.y) / timeDiff,
                    z: (currentPos.z - lastPos.z) / timeDiff
                };
                history.velocities.push(velocity);
            }
        }
        
        // Limit history size
        if (history.positions.length > this.maxHistorySize) {
            history.positions.shift();
            history.timestamps.shift();
            history.actions.shift();
            if (history.velocities.length > 0) history.velocities.shift();
        }
    }
}

// ================== NEW: DODGE PREDICTION MODEL ==================
class DodgePredictionModel {
    predictHead(target, history, timeAhead) {
        // Predict head position during dodge
        if (!target.predictedDodge) {
            return new LinearPredictionModel().predictHead(target, history, timeAhead);
        }
        
        const basePos = target.headHitbox;
        let dodgeAdjustment = { x: 0, y: 0, z: 0 };
        
        switch (target.predictedDodge.type) {
            case 'jump':
                dodgeAdjustment.y = 1.2 * timeAhead;
                break;
            case 'crouch':
                dodgeAdjustment.y = -0.5;
                break;
            case 'slide':
                dodgeAdjustment.y = -0.3;
                dodgeAdjustment.x = target.velocity.x * timeAhead * 0.6;
                dodgeAdjustment.z = target.velocity.z * timeAhead * 0.6;
                break;
            case 'strafe':
                dodgeAdjustment.x = target.velocity.x * timeAhead * 1.2;
                dodgeAdjustment.z = target.velocity.z * timeAhead * 1.2;
                break;
        }
        
        return {
            x: basePos.x + dodgeAdjustment.x,
            y: basePos.y + dodgeAdjustment.y,
            z: basePos.z + dodgeAdjustment.z
        };
    }
}

// ================== ADVANCED MOVEMENT ANALYZER (UPGRADED) ==================
class AdvancedMovementAnalyzer {
    determineMovementPattern(target, history) {
        if (history.velocities.length < 6) return 'tactical';
        
        // Calculate direction changes
        let directionChanges = 0;
        let speedChanges = 0;
        let lastSpeed = 0;
        
        for (let i = 1; i < history.velocities.length; i++) {
            const prev = history.velocities[i-1];
            const curr = history.velocities[i];
            
            // Direction change detection
            const angleChange = Math.abs(
                Math.atan2(curr.y, curr.x) - Math.atan2(prev.y, prev.x)
            );
            
            if (angleChange > 0.35) directionChanges++;
            
            // Speed change detection
            const prevSpeed = Math.sqrt(prev.x*prev.x + prev.y*prev.y);
            const currSpeed = Math.sqrt(curr.x*curr.x + curr.y*curr.y);
            if (Math.abs(currSpeed - prevSpeed) > 1.8) speedChanges++;
            
            lastSpeed = currSpeed;
        }
        
        const changeRatio = directionChanges / history.velocities.length;
        const speedChangeRatio = speedChanges / history.velocities.length;
        
        // Pattern recognition
        if (target.isJumping) return 'jumping';
        if (changeRatio > 0.55 && speedChangeRatio > 0.65) return 'erratic';
        if (history.actions.filter(a => a === 'cover').length > 3) return 'tactical';
        if (history.actions.filter(a => a === 'dodge').length > 2) return 'dodging'; // NEW
        return 'linear';
    }
    
    assessMovementThreat(target) {
        let threat = 0;
        
        // Speed-based threat
        if (target.movementSpeed > 8) threat += 5;
        else if (target.movementSpeed > 5) threat += 3;
        
        // Movement type threat
        if (target.isFlanking) threat += 6;
        if (target.isRushing) threat += 5;
        if (target.isRetreating) threat -= 1;
        
        // Environmental threat
        if (target.isInCover) threat += 4;
        
        // NEW: Dodge threat
        if (target.isDodging) threat += 3;
        
        return threat;
    }
}

// ================== TACTICAL MOVEMENT MODEL (UPGRADED) ==================
class TacticalMovementModel {
    predictHead(target, history, timeAhead) {
        // Predict based on tactical behavior
        const lastAction = history.actions[history.actions.length - 1];
        let prediction;
        
        switch (lastAction) {
            case 'cover':
                prediction = this.predictCoverMovement(target, history);
                break;
            case 'flanking':
                prediction = this.predictFlankingMovement(target, history);
                break;
            case 'retreat':
                prediction = this.predictRetreatMovement(target, history);
                break;
            case 'dodge': // NEW
                prediction = this.predictDodgeMovement(target, history);
                break;
            default:
                prediction = new LinearPredictionModel().predictHead(target, history, timeAhead);
        }
        
        // Add head height
        prediction.y += target.headHitbox.baseRadius;
        
        return prediction;
    }
    
    predictCoverMovement(target, history) {
        // Find nearest cover
        const coverPosition = this.findNearestCover(target.position);
        
        return {
            x: coverPosition.x,
            y: target.position.y,
            z: coverPosition.z
        };
    }
    
    findNearestCover(position) {
        // Advanced cover finding
        return {
            x: position.x + 1.8,
            y: position.y,
            z: position.z + 0.7
        };
    }
    
    predictFlankingMovement(target, history) {
        const playerPosition = history.context.playerPosition;
        const angleToPlayer = Math.atan2(
            playerPosition.y - target.position.y,
            playerPosition.x - target.position.x
        );
        
        const flankAngle = angleToPlayer + (Math.random() > 0.5 ? Math.PI/2.8 : -Math.PI/2.8);
        
        return {
            x: target.position.x + Math.cos(flankAngle) * 4.5,
            y: target.position.y,
            z: target.position.z + Math.sin(flankAngle) * 4.5
        };
    }
    
    // NEW: Predict dodge movement
    predictDodgeMovement(target, history) {
        const dodgeType = history.actions.filter(a => a === 'dodge').slice(-1)[0];
        let dodgeVector = { x: 0, y: 0, z: 0 };
        
        if (dodgeType === 'jump') {
            dodgeVector.y = 1.5;
        } else if (dodgeType === 'crouch') {
            dodgeVector.y = -0.6;
        } else if (dodgeType === 'slide') {
            dodgeVector.y = -0.4;
            dodgeVector.x = target.velocity.x * 0.7;
            dodgeVector.z = target.velocity.z * 0.7;
        } else { // Strafe
            dodgeVector.x = target.velocity.x * 1.1;
            dodgeVector.z = target.velocity.z * 1.1;
        }
        
        return {
            x: target.position.x + dodgeVector.x,
            y: target.position.y + dodgeVector.y,
            z: target.position.z + dodgeVector.z
        };
    }
}

// ================== ADAPTIVE LOCK CONTROLLER (UPGRADED) ==================
class AdaptiveLockController {
    constructor() {
        this.lockSensitivity = 0.98; // Increased
        this.minLockTime = 0.06; // Reduced
        this.maxLockDistance = 400; // Increased
        this.lastLockTime = 0;
        this.hyperLockMode = false;
        this.currentDistanceProfile = "medium";
        this.headStabilization = 0.995; // Increased
        this.headLockStrength = 1.0; // NEW
    }
    
    isTargetLocked(target, aimPosition) {
        const distance = this.calculateAimDistance(aimPosition, target.headHitbox);
        return distance < (target.headHitbox.radius * 0.35); // Tighter threshold
    }
    
    isTargetMoving(target) {
        return target.movementSpeed > 0.1;
    }
    
    quantumAdjust(currentAim, newPosition, target) {
        // Calculate movement vector
        const moveVector = {
            x: newPosition.x - currentAim.x,
            y: newPosition.y - currentAim.y,
            z: newPosition.z - currentAim.z
        };
        
        // Distance-based sensitivity
        let sensitivity = this.lockSensitivity;
        if (target.distance < 15) sensitivity *= 1.15;
        else if (target.distance > 90) sensitivity *= 0.88;
        
        // Apply stabilization
        return {
            x: currentAim.x + moveVector.x * sensitivity * this.headStabilization * this.headLockStrength, // NEW
            y: currentAim.y + moveVector.y * sensitivity * this.headStabilization * this.headLockStrength, // NEW
            z: currentAim.z + moveVector.z * sensitivity * 0.88
        };
    }
    
    stabilizeAim(newAim, currentAim) {
        // Smoother transition
        return {
            x: currentAim.x * 0.25 + newAim.x * 0.75,
            y: currentAim.y * 0.15 + newAim.y * 0.85,
            z: currentAim.z * 0.35 + newAim.z * 0.65
        };
    }
}

// ================== SMART RECOIL SYSTEM (UPGRADED) ==================
class SmartRecoilSystem {
    constructor() {
        this.recoilPatterns = {
            default: { vertical: 0.1, horizontal: 0.03 },
            sniper: { vertical: 0.25, horizontal: 0.01 },
            ak47: { vertical: 0.15, horizontal: 0.05 },
            m4a1: { vertical: 0.12, horizontal: 0.04 },
            shotgun: { vertical: 0.18, horizontal: 0.08 },
            awm: { vertical: 0.28, horizontal: 0.009 },
            groza: { vertical: 0.16, horizontal: 0.055 },
            mp40: { vertical: 0.14, horizontal: 0.042 } // NEW
        };
        this.distanceFactors = {
            close: { vertical: 0.88, horizontal: 0.92 },
            medium: { vertical: 1.0, horizontal: 1.0 },
            far: { vertical: 1.12, horizontal: 0.88 },
            extreme: { vertical: 1.18, horizontal: 0.82 } // NEW
        };
        this.learnRate = 0.92;
        this.recoilMemory = new Map(); // NEW
    }
    
    smartCompensate(aimPosition, weaponType, recoilData, distance) {
        // Get recoil pattern for weapon
        const pattern = this.getRecoilPattern(weaponType);
        
        // Update pattern based on actual data
        this.updatePattern(weaponType, recoilData);
        
        // Get distance factor
        const range = distance < 15 ? 'close' : 
                     distance < 50 ? 'medium' : 
                     distance < 120 ? 'far' : 'extreme';
        const distFactor = this.distanceFactors[range];
        
        // NEW: Apply memory-based compensation
        const memoryCompensation = this.getMemoryCompensation(weaponType);
        
        // Calculate compensation
        const compensation = {
            x: (pattern.horizontal + memoryCompensation.x) * distFactor.horizontal,
            y: (pattern.vertical + memoryCompensation.y) * distFactor.vertical,
            z: 0
        };
        
        // Apply compensation
        return {
            x: aimPosition.x - compensation.x,
            y: aimPosition.y - compensation.y,
            z: aimPosition.z - compensation.z
        };
    }
    
    // NEW: Memory-based compensation
    getMemoryCompensation(weaponType) {
        if (!this.recoilMemory.has(weaponType)) {
            return { x: 0, y: 0 };
        }
        return this.recoilMemory.get(weaponType);
    }
    
    // NEW: Update recoil memory
    updateMemory(weaponType, recoilData) {
        // ... implementation ...
    }
}

// ================== GHOST STEALTH (UPGRADED) ==================
class GhostStealth {
    concealAimBehavior(gameData, contextAnalyzer) {
        const currentTime = Date.now();
        
        // Change behavior pattern based on situation
        if (currentTime - this.lastBehaviorChange > 40000 || 
            contextAnalyzer.isSuspicionHigh()) {
            this.randomizeBehaviorPattern(contextAnalyzer.getPlayerSkillLevel());
            this.lastBehaviorChange = currentTime;
        }
        
        // Apply current pattern
        this.applyAdvancedPattern(gameData);
        
        // NEW: Head lock concealment
        this.concealHeadLock(gameData);
    }
    
    randomizeBehaviorPattern(skillLevel) {
        // Create random behavior pattern based on skill level
        const basePrecision = 0.08 + (0.1 * (1 - skillLevel));
        
        this.behaviorPatterns = [
            { type: 'reaction', value: Math.random() * 0.22 },
            { type: 'precision', value: basePrecision + Math.random() * 0.08 },
            { type: 'smoothness', value: 0.7 + Math.random() * 0.25 },
            { type: 'error', value: 0.04 + Math.random() * 0.08 }
        ];
    }
    
    applyAdvancedPattern(gameData) {
        for (const pattern of this.behaviorPatterns) {
            switch (pattern.type) {
                case 'reaction':
                    gameData.responseTime += pattern.value * 100;
                    break;
                case 'precision':
                    if (gameData.aimPosition) {
                        const errorX = (Math.random() * 2 - 1) * pattern.value;
                        const errorY = (Math.random() * 2 - 1) * pattern.value * 0.65;
                        gameData.aimPosition.x += errorX;
                        gameData.aimPosition.y += errorY;
                    }
                    break;
                case 'error':
                    if (Math.random() < 0.04) {
                        gameData.aimPosition.x += (Math.random() > 0.5 ? 1 : -1) * pattern.value * 2.8;
                    }
                    break;
            }
        }
    }
    
    // NEW: Conceal head lock behavior
    concealHeadLock(gameData) {
        if (!gameData.aimPosition || !gameData.targets || gameData.targets.length === 0) return;
        
        const target = gameData.targets[0];
        const headCenter = {
            x: target.headHitbox.x,
            y: target.headHitbox.y,
            z: target.headHitbox.z
        };
        
        const distanceToHead = Math.sqrt(
            Math.pow(gameData.aimPosition.x - headCenter.x, 2) +
            Math.pow(gameData.aimPosition.y - headCenter.y, 2)
        );
        
        // Add random noise when locked on head
        if (distanceToHead < target.headHitbox.radius * 0.5) {
            const noiseX = (Math.random() * 2 - 1) * 0.05;
            const noiseY = (Math.random() * 2 - 1) * 0.03;
            gameData.aimPosition.x += noiseX;
            gameData.aimPosition.y += noiseY;
        }
    }
}

// ================== TACTICAL ANALYZER (UPGRADED) ==================
class TacticalAnalyzer {
    tacticalAnalyze(gameState) {
        if (!gameState) return;
        
        // Calculate threat score with environment
        const threatScore = this.calculateTacticalThreat(gameState);
        
        // Update combat state
        this.updateCombatState(threatScore);
        
        // NEW: Analyze headshot opportunities
        this.analyzeHeadshotOpportunities(gameState);
        
        // Save state history
        this.stateHistory.push({
            state: this.currentState,
            timestamp: Date.now(),
            threatScore: threatScore
        });
    }
    
    calculateTacticalThreat(gameState) {
        let score = 0;
        
        // Enemy count with positioning
        score += Math.min(7, gameState.enemyCount) * 1.3;
        
        // Positional threat
        if (gameState.isSurrounded) score += 5.0;
        if (gameState.isFlanked) score += 7.0;
        
        // Nearest enemy distance with weapon factor
        if (gameState.nearestEnemyDistance < 15) score += 4.5;
        else if (gameState.nearestEnemyDistance < 40) score += 3.0;
        
        // Player health with critical state
        if (gameState.playerHealth < 20) score += 4.5;
        else if (gameState.playerHealth < 45) score += 2.5;
        
        // Ammo status
        if (gameState.ammoStatus === 'low') score += 2.5;
        if (gameState.ammoStatus === 'critical') score += 4.0;
        
        // NEW: Headshot opportunity
        if (gameState.headshotOpportunity > 0.7) score += 3.5;
        
        return Math.min(10, score);
    }
    
    // NEW: Analyze headshot opportunities
    analyzeHeadshotOpportunities(gameState) {
        let opportunity = 0;
        
        if (gameState.enemyCount === 1) opportunity += 0.4;
        if (gameState.nearestEnemyDistance < 30) opportunity += 0.3;
        if (!gameState.enemyHasCover) opportunity += 0.5;
        if (gameState.enemyIsMoving) opportunity += 0.2;
        
        gameState.headshotOpportunity = Math.min(1, opportunity);
    }
    
    getCombatState() {
        return this.currentState;
    }
}

// ================== AI PERFORMANCE OPTIMIZER (UPGRADED) ==================
class AIPerformanceOptimizer {
    adaptiveAdjust(performanceState) {
        if (!performanceState) return;
        
        this.currentFPS = performanceState.fps || 60;
        this.aiWorkload = performanceState.aiLoad || 0.5;
        
        if (this.currentFPS < 45) {
            this.currentProfile = "low";
            this.aimPredictionLevel = 8;
        } else if (this.currentFPS < 60) {
            this.currentProfile = "medium";
            this.aimPredictionLevel = 12;
        } else if (this.currentFPS < 80) {
            this.currentProfile = "high";
            this.aimPredictionLevel = 18;
        } else {
            this.currentProfile = "ultra";
            this.aimPredictionLevel = 25;
        }
        
        // Adjust AI workload
        if (this.aiWorkload > 0.75) {
            this.aimPredictionLevel = Math.max(6, this.aimPredictionLevel - 4);
        }
        
        // NEW: Adjust based on battery
        if (performanceState.batteryLevel < 20) {
            this.aimPredictionLevel = Math.max(5, this.aimPredictionLevel - 3);
        }
    }
}

// ================== HEAD TRACKING SYSTEM (UPGRADED) ==================
class HeadTrackingSystem {
    constructor() {
        this.historySize = 30;
        this.headPositionHistory = new Map();
        this.movementPredictionLevel = 0.9;
    }

    trackHead(target) {
        // Lịch sử vị trí đầu
        if (!this.headPositionHistory.has(target.id)) {
            this.headPositionHistory.set(target.id, []);
        }
        
        const history = this.headPositionHistory.get(target.id);
        const currentHeadPos = this.calculateCurrentHeadPosition(target);
        
        // Lưu lịch sử
        history.push({
            position: currentHeadPos,
            timestamp: Date.now(),
            velocity: target.velocity
        });
        
        // Giới hạn lịch sử
        if (history.length > this.historySize) {
            history.shift();
        }
        
        // Dự đoán vị trí tiếp theo
        const predictedPosition = this.predictNextPosition(history);
        target.headPosition = predictedPosition;
        
        return predictedPosition;
    }

    calculateCurrentHeadPosition(target) {
        // Tính toán chi tiết dựa trên hoạt ảnh nhân vật
        let headHeight;
        
        switch (target.stance) {
            case 'standing':
                headHeight = 1.68;
                break;
            case 'crouching':
                headHeight = 1.25;
                break;
            case 'prone':
                headHeight = 0.85;
                break;
            case 'jumping':
                const jumpProgress = Math.min(1, (Date.now() - target.jumpStartTime) / 800);
                headHeight = 1.68 + Math.sin(jumpProgress * Math.PI) * 0.7;
                break;
            case 'vaulting':
                headHeight = 1.68 + 0.4;
                break;
            case 'sliding':
                headHeight = 1.05;
                break;
            default:
                headHeight = 1.68;
        }
        
        // Điều chỉnh theo vũ khí đang cầm
        if (target.weaponType === 'sniper') headHeight -= 0.05;
        
        return {
            x: target.position.x,
            y: target.position.y + headHeight,
            z: target.position.z
        };
    }

    predictNextPosition(history) {
        if (history.length < 3) return history[history.length - 1].position;
        
        const lastEntry = history[history.length - 1];
        const prevEntry = history[history.length - 2];
        
        // Tính toán vận tốc
        const timeDiff = (lastEntry.timestamp - prevEntry.timestamp) / 1000;
        const velocity = {
            x: (lastEntry.position.x - prevEntry.position.x) / timeDiff,
            y: (lastEntry.position.y - prevEntry.position.y) / timeDiff,
            z: (lastEntry.position.z - prevEntry.position.z) / timeDiff
        };
        
        // Dự đoán với Kalman Filter đơn giản
        const prediction = {
            x: lastEntry.position.x + velocity.x * this.movementPredictionLevel,
            y: lastEntry.position.y + velocity.y * this.movementPredictionLevel,
            z: lastEntry.position.z + velocity.z * this.movementPredictionLevel
        };
        
        // Hiệu chỉnh theo trọng lực nếu đang nhảy
        if (lastEntry.velocity.y > 0) {
            prediction.y -= 0.5 * 9.8 * timeDiff * timeDiff;
        }
        
        return prediction;
    }
}

// ================== COMBAT CONTEXT PROCESSOR (UPGRADED) ==================
class CombatContextProcessor {
    processContext(gameState) {
        this.playerSkillLevel = gameState.playerSkill || 0.7;
        this.mapType = gameState.map || 'unknown';
        this.timeRemaining = gameState.matchTime || 0;
        this.suspicionLevel = 0;
        this.headshotOpportunity = 0; // NEW
        
        // NEW: Calculate suspicion level
        this.calculateSuspicion(gameState);
    }
    
    calculateSuspicion(gameState) {
        let suspicion = 0;
        
        // Headshot rate
        if (gameState.headshotRate > 0.8) suspicion += 0.4;
        
        // Accuracy
        if (gameState.accuracy > 0.7) suspicion += 0.3;
        
        // Reaction time
        if (gameState.avgReactionTime < 150) suspicion += 0.5;
        
        this.suspicionLevel = Math.min(1, suspicion);
    }
    
    isSuspicionHigh() {
        return this.suspicionLevel > 0.75;
    }
    
    getPlayerSkillLevel() {
        return this.playerSkillLevel;
    }
    
    getHeadshotOpportunity() {
        return this.headshotOpportunity;
    }
}

// ================== NEW: SKELETAL TRACKING SYSTEM ==================
class SkeletalTrackingSystem {
    trackBodies(skeletalData) {
        return skeletalData.bodies.map(body => {
            const headJoint = body.joints.find(j => j.name === 'head');
            const neckJoint = body.joints.find(j => j.name === 'neck');
            
            return {
                id: body.id,
                position: {
                    x: (headJoint.x + neckJoint.x) / 2,
                    y: (headJoint.y + neckJoint.y) / 2 + 0.12,
                    z: (headJoint.z + neckJoint.z) / 2
                },
                confidence: body.confidence,
                headVisibility: this.calculateHeadVisibility(body.joints),
                stance: this.detectStance(body.joints)
            };
        });
    }
    
    calculateHeadVisibility(joints) {
        const head = joints.find(j => j.name === 'head');
        const visibilityFactors = {
            covered: 0.3,
            partial: 0.7,
            visible: 0.95
        };
        
        return visibilityFactors[head.visibility] || 0.5;
    }
    
    detectStance(joints) {
        const head = joints.find(j => j.name === 'head');
        const hip = joints.find(j => j.name === 'hip');
        
        const heightDiff = Math.abs(head.y - hip.y);
        
        if (heightDiff < 0.5) return 'prone';
        if (heightDiff < 0.8) return 'crouch';
        if (heightDiff > 1.2) return 'jumping';
        return 'standing';
    }
}

// ================== INITIALIZATION ==================
const omegaSystem = new OmegaHeadshotSystem();
$done({ body: omegaSystem.process($response.body) });
