// HEADSHOT MASTER v14.0 (200% Head Zone & Auto-Correction)
class PerfectLockHeadshotMaster {
    constructor() {
        this.lockStrength = 0.9999;
        this.targetHistory = new Map();
        this.sessionToken = `HS_ULTRA_${Date.now().toString(36)}`;
        this.weaponProfiles = this.getPrecisionWeaponProfiles();
        this.ballisticSystem = new AdvancedBallisticSystem();
        this.lastLockTime = 0;
        this.aimPredictionLevel = 11; // Tăng độ chính xác dự đoán
        this.aimStabilizer = 0.997; // Tăng ổn định
        this.headshotAccuracy = 0.995;
        this.maxHistory = 20; // Tăng lịch sử theo dõi
        this.overshootProtection = 0.75; // Giảm overshoot 25%
        this.stickyHeadLock = true;
        this.bulletStabilization = true;
        this.headLockPro = true;
        this.performanceProfile = "ultra";
        this.headshotAreaMultiplier = 2.0; // Mở rộng vùng headshot 200%
        this.distancePullFactor = 0.0;
        this.headZoneFocus = true;
        this.headZoneRadius = 0.45; // Tăng bán kính vùng đầu
        this.chestCorrectionBoost = 1.8; // Lực kéo từ ngực lên đầu
    }

    process(body) {
        try {
            const startTime = Date.now();
            const data = JSON.parse(body);
            this.updatePerformanceMode(data.performanceState);
            
            if (data.gameState) this.updateCombatState(data.gameState);
            
            if (data.targets?.length > 0) {
                const enhancedTargets = this.enhanceTargetsWithHeadFocus(data.targets, data.playerPosition);
                const lockedTarget = this.selectOptimalTarget(enhancedTargets);
                
                if (lockedTarget) {
                    let perfectAim = this.calculateHeadFocusAim(lockedTarget, data.playerPosition, data.currentWeapon);
                    
                    // TỰ ĐỘNG HIỆU CHỈNH NẾU TÂM SÚNG Ở VÙNG NGỰC
                    if (this.isAimingAtChest(data.currentAimPosition, lockedTarget)) {
                        perfectAim = this.applyChestCorrection(data.currentAimPosition, perfectAim);
                    }
                    
                    this.distancePullFactor = this.calculateDistancePullFactor(lockedTarget.distance);
                    
                    data.aimPosition = this.applyHeadLockPro(
                        perfectAim, 
                        data.currentAimPosition, 
                        lockedTarget,
                        data.gameState?.isFiring
                    );
                    
                    // TĂNG CƯỜNG ỔN ĐỊNH ĐƯỜNG ĐẠN
                    if (this.bulletStabilization) {
                        data.bulletTrajectory = this.calculateStabilizedTrajectory(
                            data.playerPosition,
                            data.aimPosition,
                            lockedTarget,
                            data.currentWeapon
                        );
                    }
                    
                    // SIÊU KÉO TÂM VỚI HEADSHOT 200%
                    if (this.lockStrength > 0.99 && data.recoilSystem?.crosshairStabilization) {
                        const stabilizationBoost = 5.0 - (lockedTarget.distance * 0.0003) + this.distancePullFactor;
                        data.aimPosition = {
                            x: data.aimPosition.x * data.recoilSystem.crosshairStabilization.x * stabilizationBoost,
                            y: data.aimPosition.y * data.recoilSystem.crosshairStabilization.y * stabilizationBoost,
                            z: data.aimPosition.z * data.recoilSystem.crosshairStabilization.z * (stabilizationBoost * 0.99)
                        };
                    }
                    
                    this.lastLockTime = Date.now();
                }
                
                data.aimData = {
                    targets: enhancedTargets,
                    lockedTarget,
                    lockStrength: this.lockStrength,
                    predictionLevel: this.aimPredictionLevel,
                    headshotRate: this.headshotAccuracy,
                    headshotArea: this.headshotAreaMultiplier,
                    processingTime: Date.now() - startTime
                };
            }
            
            data.aimSystem = this.getSystemMetadata();
            return JSON.stringify(data);
        } catch (e) {
            console.error("[HEADSHOT MASTER] Ultra Error:", e.message.substring(0, 30));
            return body;
        }
    }

    // CƠ CHẾ TỰ ĐỘNG KÉO TÂM TỪ NGỰC VỀ ĐẦU
    applyChestCorrection(currentAim, headAim) {
        const correctionVector = {
            x: (headAim.x - currentAim.x) * this.chestCorrectionBoost,
            y: (headAim.y - currentAim.y) * this.chestCorrectionBoost * 1.3, // Ưu tiên trục dọc
            z: (headAim.z - currentAim.z) * this.chestCorrectionBoost
        };
        
        return {
            x: currentAim.x + correctionVector.x,
            y: currentAim.y + correctionVector.y,
            z: currentAim.z + correctionVector.z
        };
    }

    // KIỂM TRA TÂM SÚNG CÓ ĐANG Ở VÙNG NGỰC
    isAimingAtChest(aimPosition, target) {
        const chestY = target.position.y + 0.5; // Vị trí ước lượng ngực
        const headY = target.headHitbox.y;
        const yDiff = Math.abs(aimPosition.y - chestY);
        const yHeadDiff = Math.abs(aimPosition.y - headY);
        
        // Nếu khoảng cách tới ngực gần hơn tới đầu 30%
        return yDiff < yHeadDiff * 0.7;
    }

    // CẢI TIẾN: HEAD ZONE FOCUS VỚI HEADSHOT 200%
    enhanceTargetsWithHeadFocus(targets, playerPosition) {
        return targets
            .filter(target => {
                const distance = Math.sqrt(
                    Math.pow(target.headHitbox.x - playerPosition.x, 2) +
                    Math.pow(target.headHitbox.y - playerPosition.y, 2)
                );
                return target.isVisible && distance < 250;
            })
            .map(target => {
                target.headHitboxSize = this.calculateHeadHitboxSize(target) * this.headshotAreaMultiplier;
                target.movementSpeed = Math.sqrt(target.movement.x**2 + target.movement.y**2);
                target.headZonePriority = this.calculateHeadZonePriority(target, playerPosition);
                return target;
            });
    }
    
    // TÍNH TOÁN VÙNG HEADSHOT 200%
    calculateHeadFocusAim(target, playerPosition, weaponType) {
        let headPosition = {
            x: target.headHitbox.x,
            y: target.headHitbox.y,
            z: target.headHitbox.z
        };
        
        const weaponProfile = this.weaponProfiles[weaponType] || this.weaponProfiles.default;
        const travelTime = target.distance / weaponProfile.bulletVelocity;
        
        // HIỆU CHỈNH CHUYỂN ĐỘNG VỚI HEADSHOT 200%
        const headMovement = this.calculateHeadMovement(target, travelTime);
        headPosition.x += headMovement.x;
        headPosition.y += headMovement.y;
        headPosition.z += headMovement.z;
        
        // TẠO VÙNG HEADSHOT RỘNG 200%
        const headshotArea = target.headHitboxSize;
        const focusOffset = this.calculateSmartOffset(headshotArea, target.movement);
        
        return {
            x: headPosition.x + focusOffset.x,
            y: headPosition.y + focusOffset.y,
            z: headPosition.z
        };
    }

    // TÍNH TOÁN OFFSET THÔNG MINH TRONG VÙNG HEADSHOT 200%
    calculateSmartOffset(areaSize, movement) {
        // Ưu tiên hướng di chuyển của địch
        const movementFactor = {
            x: Math.min(1.0, Math.abs(movement.x) * 2),
            y: Math.min(1.0, Math.abs(movement.y) * 2)
        };
        
        // Tạo offset theo hướng di chuyển
        return {
            x: (Math.random() * areaSize - areaSize/2) * movementFactor.x * (movement.x > 0 ? 1 : -1),
            y: (Math.random() * areaSize/2 - areaSize/4) * movementFactor.y * (movement.y > 0 ? 1 : -1)
        };
    }

    // CÔNG NGHỆ HEAD LOCK PRO NÂNG CẤP
    applyHeadLockPro(targetPosition, currentPosition, target, isFiring) {
        const direction = {
            x: targetPosition.x - currentPosition.x,
            y: targetPosition.y - currentPosition.y,
            z: targetPosition.z - currentPosition.z
        };
        
        const distance = Math.max(1, target.distance);
        const distanceFactor = Math.min(2.5, 1.0 + (150 / distance)); // Tăng lực kéo
        const speedFactor = 1.2 - (Math.sqrt(target.movement.x**2 + target.movement.y**2) * 0.02);
        const stickyFactor = 0.985; // Tăng độ dính
        
        let finalPosition = {
            x: currentPosition.x + (direction.x * distanceFactor * speedFactor * stickyFactor * this.overshootProtection),
            y: currentPosition.y + (direction.y * distanceFactor * speedFactor * stickyFactor * this.aimStabilizer * this.overshootProtection),
            z: currentPosition.z + (direction.z * distanceFactor * speedFactor * stickyFactor * 0.97 * this.overshootProtection)
        };
        
        // GIỚI HẠN TRONG VÙNG HEADSHOT 200%
        const maxMovement = {
            x: target.headHitbox.x * (1.1 * this.headshotAreaMultiplier),
            y: target.headHitbox.y * (1.1 * this.headshotAreaMultiplier),
            z: target.headHitbox.z * (1.1 * this.headshotAreaMultiplier)
        };
        
        finalPosition.x = Math.min(maxMovement.x, Math.max(target.headHitbox.x * (0.9 / this.headshotAreaMultiplier), finalPosition.x));
        finalPosition.y = Math.min(maxMovement.y, Math.max(target.headHitbox.y * (0.9 / this.headshotAreaMultiplier), finalPosition.y));
        finalPosition.z = Math.min(maxMovement.z, Math.max(target.headHitbox.z * (0.9 / this.headshotAreaMultiplier), finalPosition.z));
        
        return finalPosition;
    }

    // LỰC KÉO THEO KHOẢNG CÁC (MẠNH HƠN 30%)
    calculateDistancePullFactor(distance) {
        if (distance < 50) return 2.2; 
        if (distance < 100) return 1.8; 
        if (distance < 150) return 1.4; 
        if (distance < 200) return 1.0; 
        return 0.8; 
    }

    // CẢI TIẾN DỰ ĐOÁN CHUYỂN ĐỘNG ĐẦU
    neuralMovementPrediction(target) {
        // [Thuật toán nâng cao đã triển khai ở phiên bản trước]
        // Giữ nguyên hoặc tối ưu thêm nếu cần
    }

    // CẢI TIẾN TÍNH TOÁN CHUYỂN ĐỘNG ĐẦU
    calculateHeadMovement(target, travelTime) {
        const headMovement = {
            x: target.movement.x * travelTime * 1.35, // Tăng độ nhạy
            y: target.movement.y * travelTime * 1.35,
            z: target.movement.z * travelTime * 1.35
        };
        
        // HIỆU CHỈNH CHO HÀNH ĐỘNG ĐẶC BIỆT
        if (target.isJumping) headMovement.y += target.jumpHeight * 0.8;
        else if (target.isCrouching) headMovement.y -= target.height * 0.18;
        else if (target.isProne) headMovement.y -= target.height * 0.3;
        
        return headMovement;
    }

    updateCombatState(gameState) {
        const timeSinceCombat = Date.now() - this.lastLockTime;
        
        if (gameState.isInCombat || timeSinceCombat < 3000) {
            this.lockStrength = Math.min(0.9999, 0.997 + (gameState.combatIntensity * 0.003));
        } else {
            this.lockStrength = Math.max(0.99, this.lockStrength - 0.0005);
        }
        
        if (gameState.isAiming) this.lockStrength = 0.999;
        if (gameState.playerHealth < 30) {
            this.lockStrength = 0.9999;
            this.headshotAccuracy = 0.998;
            this.headshotAreaMultiplier = 2.5; // Mở rộng 250% khi nguy hiểm
            this.chestCorrectionBoost = 2.2; // Tăng lực kéo từ ngực
        }
        
        this.aimStabilizer = 0.99 + (this.lockStrength * 0.008);
    }

    // TỐI ƯU CHỌN MỤC TIÊU VỚI HEADSHOT 200%
    selectOptimalTarget(targets) {
        if (targets.length === 0) return null;
        
        return targets.reduce((best, current) => {
            // Ưu tiên mục tiêu có vùng headshot lớn và gần
            const currentScore = current.headHitboxSize * 200 - current.distance;
            const bestScore = best.headHitboxSize * 200 - best.distance;
            return currentScore > bestScore ? current : best;
        }, targets[0]);
    }
    
    calculateHeadHitboxSize(target) {
        let size = 0.4; // Kích thước cơ bản
        if (target.isCrouching) size *= 1.25; 
        if (target.isJumping) size *= 0.85; 
        if (target.isProne) size *= 1.15;
        return size;
    }

    getPrecisionWeaponProfiles() {
        return {
            "default": {bulletVelocity: 380, stability: 0.96},
            "sniper": {bulletVelocity: 980, stability: 0.995},
            "ak47": {bulletVelocity: 370, stability: 0.94},
            "m4a1": {bulletVelocity: 410, stability: 0.95},
            "shotgun": {bulletVelocity: 320, stability: 0.88}
        };
    }

    getSystemMetadata() {
        return {
            version: "14.0",
            mode: "headshot_200",
            features: {
                headLockPro: this.headLockPro,
                headshotArea: this.headshotAreaMultiplier,
                chestCorrection: this.chestCorrectionBoost,
                maxHeadZone: 2.5
            },
            securityToken: this.sessionToken
        };
    }
}

class AdvancedBallisticSystem {
    getGravity(weaponType) {
        const gravities = {
            sniper: 9.78, dmr: 9.79, ar: 9.80, smg: 9.81, 
            shotgun: 9.82, ak47: 9.80, m4a1: 9.80, scar: 9.80
        };
        return gravities[weaponType] || 9.81;
    }

    calculateAdvancedDrop(distance, velocity, gravity, movement) {
        const time = distance / velocity;
        const baseDrop = 0.5 * gravity * Math.pow(time, 2);
        const movementCompensation = movement.y * time * 0.92; // Tăng hiệu chỉnh
        return baseDrop + movementCompensation;
    }
}

const aimSystem = new PerfectLockHeadshotMaster();
$done({ body: aimSystem.process($response.body) });
